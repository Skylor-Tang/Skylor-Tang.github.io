<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ajax 跨域问题解决方案</title>
      <link href="2021/03/10/Ajax-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2021/03/10/Ajax-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>由于浏览器安全方面的限制，大多数Ajax请求遵守“同源策略”，也就是说无法从不同的域、子域或协议中获取数据。本文主要通过CORS解决Ajax跨域请求的问题。<br>文中关于CORS的定义主要参考<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">廖雪峰–跨域资源共享 CORS 详解</a>，本文使用<code>$.ajax</code>以及<code>flask</code>实现CORS的处理。</p><h2 id="原生CORS方式解决："><a class="header-anchor" href="#原生CORS方式解决：">¶</a>原生CORS方式解决：</h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<font color="red">因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</font></p><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><h3 id="简单请求"><a class="header-anchor" href="#简单请求">¶</a>简单请求</h3><p>处理简单的请求的时候，Ajax发送的跨域请求头中会多提供一个<code>Origin</code>字段，用来说明，本次请求来自哪个源<code>（协议+域名+端口）</code>。服务器根据这个值，决定是否同意这次请求。</p><p>此时只要在服务端获取Origin字段判断后是否同意，如果同意跨域，则在返回的响应中添加<code>Access-Control-Allow-Origin</code>字段，值为允许接受的请求的域名，可以使用具体域名，或者<code>&quot;*&quot;</code>表示允许所有的请求。</p><h5 id="flask服务端处理："><a class="header-anchor" href="#flask服务端处理：">¶</a>flask服务端处理：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, jsonify, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">"JSON_AS_ASCII"</span>] = <span class="literal">False</span>  </span><br><span class="line"><span class="comment"># 用于设置jsonify返回的json数据支持中文</span></span><br><span class="line"><span class="comment"># json.dumps()解决同样的问题可以加入ensure_ascii=False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">  data = [&#123;<span class="string">"name"</span>:<span class="string">"小杰"</span>, <span class="string">"sex"</span>:<span class="string">"男"</span>, <span class="string">"age"</span>: <span class="number">24</span>&#125;]</span><br><span class="line">  origin = request.headers.get(<span class="string">"Origin"</span>, <span class="literal">None</span>)</span><br><span class="line">  response = jsonify(data)</span><br><span class="line">  <span class="keyword">if</span> origin == <span class="string">"http://localhost:8080"</span>:</span><br><span class="line">    response = make_response(response)</span><br><span class="line">    response.headers[<span class="string">'Access-Control-Allow-Origin'</span>] = <span class="string">'*'</span> <span class="comment"># 处理简单请求的设置</span></span><br><span class="line">  <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>响应头除了必须含有<code>Access-Control-Allow-Origin</code>字段之外，还包括两个可选字段：</p><ul><li><p>Access-Control-Expose-Headers: (可选)<br>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</p></li><li><p>Access-Control-Allow-Credentials: (可选)<br>它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p>只是在服务端设置允许还是不够的，此时还需要对请求进行设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>JQuery中ajax的设置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"http://localhost:8080"</span>,</span><br><span class="line">  type: <span class="string">"GET"</span>,</span><br><span class="line">  xhrFields: &#123;</span><br><span class="line">    withCredentials: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  crossDomain: <span class="literal">true</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>xhrFields</code>以及<code>crossDomain</code>是必须要设置的。</p><blockquote><p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。<strong>（就是跨源能上传的Cookie，也只是服务器同域名的Cookie）</strong></p></blockquote></li></ul><h3 id="非简单请求"><a class="header-anchor" href="#非简单请求">¶</a>非简单请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，会<font color="red"><strong>自动增加</strong></font>一次HTTP查询请求，称为&quot;预检&quot;请求（preflight），在chrome浏览器的network中，该条请求的Type为<code>preflight</code>，请求类型是<code>OPTIONS</code>，包含的关键字除了Origin字段（该字段在简单和非简单请求中都会使用到）之外还有：</p><ul><li><p>Access-Control-Request-Method： (必须)<br>​浏览器CORS请求使用到的请求方法</p></li><li><p>Access-Control-Request-Headers： (可选)<br>​该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。<br>​在前端，通过对XMLHttpRequest对象采用如下方式进行设置：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"X-Custom-Header"</span>, <span class="string">"value"</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="预检的响应，服务器返回的响应头部需要包含："><a class="header-anchor" href="#预检的响应，服务器返回的响应头部需要包含：">¶</a>预检的响应，服务器返回的响应头部需要包含：</h5><ul><li><p>Access-Control-Allow-Origin： (必须)<br>设置允许跨域的源，设置为*表示允许任意的源。</p></li><li><p>Access-Control-Allow-Methods：(必须)<br>必须字段，值为逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p></li><li><p>Access-Control-Allow-Credentials: (可选)<br>为布尔值，和跨域简单请求的一样，表示是否允许发送Cookie。</p></li><li><p>Access-Control-Allow-Headers：(根据请求设置)<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p></li><li><p>Access-Control-Max-Age：(可选，不要轻易设置)<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p></li></ul><p><font color="red"><strong>注意：一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段（该字段每次都会包含，这时简单请求响应的要求）。</strong></font></p><h5 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h5><p>前端ajax请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"http://127.0.0.1:5000/index"</span>,</span><br><span class="line">  type: <span class="string">"put"</span>,</span><br><span class="line">  dataType: <span class="string">"json"</span>,</span><br><span class="line">  beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="built_in">console</span>.log(xhr)  <span class="comment">// 为XMLHttpRequest对象</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">"X-Custom-Header"</span>, <span class="string">"value"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">    $.each(data, <span class="function"><span class="keyword">function</span>(<span class="params">index, info</span>)</span>&#123;</span><br><span class="line">      str += <span class="string">"姓名："</span> + info[<span class="string">"name"</span>] + <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">      str += <span class="string">"性别："</span> + info[<span class="string">"sex"</span>] + <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">      str += <span class="string">"年龄："</span> + info[<span class="string">"age"</span>] + <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">      str += <span class="string">"&lt;hr/&gt;"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"div"</span>).html(str);  <span class="comment">// .html(字符串) 用于对字符串不进行转义，会显示网页效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>flask代码实现：</p><p>注意：预检会单独发送一次请求，也就是说，一次跨域请求实际上会发生两次请求，第一次是预检，第二次是正常的请求。</p><p>只有第一次预检的时候（发送的是一个<code>OPTIONS</code>请求），请求中包含有<code>Origin: http://127.0.0.1:8080</code>、 <code>Access-Control-Request-Headers</code>以及 <code>Access-Control-Request-Method</code>，此时返回的响应需要设置<code>Access-Control-Allow-Origin</code>，<code>Access-Control-Allow-Methods</code>，<code>Access-Control-Allow-Headers</code>（这一项只有在请求中设置了<code>Access-Control-Request-Headers</code>的时候才需要）。</p><p>在预检通过之后，紧接着会再次向相同的url发送原始的请求，请求中只会发送<code>Origin: http://127.0.0.1:8080</code>， 需要返回的响应头中包含<code>Access-Control-Allow-Origin</code>字段。</p><p>可以使用<code>app.before_request</code>请求钩子完成非简单请求的预检过程，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, jsonify, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">"JSON_AS_ASCII"</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过before_request处理预检过程</span></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cors</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">"OPTIONS"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">      </span><br><span class="line">    access_control_request_method = request.headers.get(<span class="string">'Access-Control-Request-Method'</span>, <span class="literal">None</span>)</span><br><span class="line">    access_control_request_headers = request.headers.get(<span class="string">"Access-Control-Request-Headers"</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> access_control_request_method:</span><br><span class="line">        response = make_response(<span class="string">''</span>)  <span class="comment"># 预检可以发送任何东西</span></span><br><span class="line">        response.headers[<span class="string">'Access-Control-Allow-Origin'</span>] = <span class="string">'*'</span> <span class="comment"># 处理简单请求的设置</span></span><br><span class="line">        response.headers[<span class="string">'Access-Control-Allow-Methods'</span>] = <span class="string">"DELETE, PUT"</span> <span class="comment"># 注意是methods</span></span><br><span class="line">        response.headers[<span class="string">'Access-Control-Allow-Headers'</span>] = access_control_request_headers</span><br><span class="line">        <span class="comment"># response.headers['Access-Control-Max-Age'] = 1728000</span></span><br><span class="line">        <span class="comment"># response.headers['Access-Control-Allow-Credentials'] = "true"  # 注意使用的是js中true</span></span><br><span class="line">        <span class="keyword">return</span> response        </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index', methods=['POST', 'GET', 'DELETE', 'PUT', 'OPTIONS'])  </span></span><br><span class="line"><span class="comment"># 注意，该视图函数需要设置预检以及cors请求的类型，否则无法处理delete以及options请求。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    data = [&#123;<span class="string">"name"</span>:<span class="string">"小杰"</span>, <span class="string">"sex"</span>:<span class="string">"男"</span>, <span class="string">"age"</span>: <span class="number">24</span>&#125;]</span><br><span class="line">    origin = request.headers.get(<span class="string">"Origin"</span>, <span class="literal">None</span>)</span><br><span class="line">    response = jsonify(data)  </span><br><span class="line">    <span class="keyword">if</span> origin == <span class="string">"http://127.0.0.1:8080"</span>:</span><br><span class="line">        response = make_response(response)</span><br><span class="line">        response.headers[<span class="string">'Access-Control-Allow-Origin'</span>] = <span class="string">'*'</span> <span class="comment"># 处理简单请求的设置</span></span><br><span class="line">        <span class="comment"># response.headers['Access-Control-Allow-Credentials'] = "true"  # 注意使用的是js中true</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>除此以外，还提供了flask还提供了第三方插件，如<code>Flask-Cros</code>插件来完成跨域请求问题。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 开发问题 </category>
          
          <category> Flask </category>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> Flask </tag>
            
            <tag> 前后端跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 元类编程思考</title>
      <link href="2020/09/13/Python-%E5%85%83%E7%B1%BB%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/"/>
      <url>2020/09/13/Python-%E5%85%83%E7%B1%BB%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/c1ca0b9c777d" target="_blank" rel="noopener">https://www.jianshu.com/p/c1ca0b9c777d</a></p><h2 id="什么是元类"><a class="header-anchor" href="#什么是元类">¶</a>什么是元类</h2><p>python中一切皆对象，type创建了一切对象，包括类、函数等。类创建了实例对象，而类本身也是对象，创建类的类就是元类。<br>元类（metaclass）可以控制类的创建过程，它主要做三件事： 1.拦截类的创建 2.修改类的定义 3.返回修改后的类对象。type就是Python中最基础的一个元类。</p><h2 id="使用type动态的创建类"><a class="header-anchor" href="#使用type动态的创建类">¶</a>使用type动态的创建类</h2><p>type除了用于返回当前对象的类型之外，还可以用于动态的创建类。chuang<br>#三个参数 ： 类的名称， 类的基类tuple类型， 类属性和类方法实例方法 dict类型</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法数据结构</title>
      <link href="2020/08/03/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/08/03/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="算法复杂度"><a class="header-anchor" href="#算法复杂度">¶</a>算法复杂度</h2><p>算法复杂度分为时间复杂度和空间复杂度。<br>时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体现在运行某个算法时计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度。）</p><h3 id="时间复杂度"><a class="header-anchor" href="#时间复杂度">¶</a>时间复杂度</h3><p>时间复杂度排序：<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n²logn) &lt; O(n³)</p><p>简单快速判断算法的时间复杂度（适用于大部分简单的代码）</p><ul><li>确定问题规模 n</li><li>循环减半过程  --&gt; logn</li><li>k层关于n的循环 --&gt; nᵏ</li><li>复杂情况 --&gt; 根据算法执行过程判断</li></ul><h3 id="空间复杂度"><a class="header-anchor" href="#空间复杂度">¶</a>空间复杂度</h3><p>空间复杂度：评估算法内存占用大小的式子<br>空间复杂度的表现方式和时间复杂度一致：</p><ul><li>算法使用了几个变量： O(1)</li><li>算法使用了长度为n的以为列表： O(n)</li><li>算法使用了m行n列的二维列表： O(mn)</li><li>递归需要使用到系统栈的空间，因为需要记录上次递归中函数的位置，每走一层就需要消耗1个空间，所以没走k层，就需要消耗O(k)的空间</li></ul><p>空间换时间</p><p>冒泡后 选标记前 插移位 快归位(找到元素应有的位置)递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    简易算法时间装饰器</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">"%s running time: %s secs."</span> % (func.__name__, t2-t1))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p><strong>以下所有的排序算法的实现，都是基于列表的下标完成的</strong></p><h2 id="递归问题"><a class="header-anchor" href="#递归问题">¶</a>递归问题</h2><p>递归的特点： 1.调用自身 2.结束条件<br>递归案例： 汉诺塔问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span><span class="params">(n, a, b ,c)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    n 表示圆盘个数</span></span><br><span class="line"><span class="string">    三个参数代表三个柱子相对位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        hanoi(n<span class="number">-1</span>, a, c, b)</span><br><span class="line">        print(<span class="string">'moving from %s to %s'</span> %(a, c))</span><br><span class="line">        hanoi(n<span class="number">-1</span>, b, a, c)</span><br><span class="line"></span><br><span class="line">hanoi(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure><p>算法解析：<br>为了保证小的盘子只能放在大的盘子之上，将n个盘子分为两个部分（1以及n-1两个部分），1 表示最后的一个大盘子，n-1 看作一个整体。</p><h2 id="列表查找"><a class="header-anchor" href="#列表查找">¶</a>列表查找</h2><p>列表查找（线性表查找）：从列表中查找指定元素</p><ul><li>输入：列表、待查找元素</li><li>输出：元素下标（未找到元素时一般返回None或-1）</li></ul><p>list类型内置查找函数：index()   —  是线性（顺序）查找，因为二分查找要求列表是有序列表，故采用的是线性查找</p><h3 id="顺序查找-Linear-Search"><a class="header-anchor" href="#顺序查找-Linear-Search">¶</a>顺序查找 (Linear Search)</h3><p>也叫线性查找，从列表的第一个元素开始，顺序进行搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_search</span><span class="params">(li, val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> ind, v <span class="keyword">in</span> enumerate(li):</span><br><span class="line">        <span class="keyword">if</span> v == val:</span><br><span class="line">            <span class="keyword">return</span> ind</span><br><span class="line">    <span class="keyword">else</span>:                                       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p><em><strong>python 中独创了 <code>for...else...</code> 以及 <code>while...else...</code> 语法，用于在循环结束之后直接执行else中的内容，好处是当循环中因为break退出时，else中的内容将不在执行。</strong></em></p><h3 id="二分查找-Binary-Search"><a class="header-anchor" href="#二分查找-Binary-Search">¶</a>二分查找 (Binary Search)</h3><p>又叫折半查找，从有序列表的初始候选区 li[0:n] 开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。</p><p>算法的前提：查找目标<code>必须是排序好的</code>列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(li, val)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(li) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span>  </span><br><span class="line">        <span class="keyword">if</span> li[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; val:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>时间复杂度：涉及到循环减半，所以复杂度是O(logn)</p><p>小结：<br>list类型内置查找函数<code>index()</code> 是线性（顺序）查找，因为二分查找要求列表是有序列表，故采用的是线性查找，<br>二分查找要求列表的顺序为有序列表，而排序算法的复杂度都大于O(n)，所以在选用查找方式的时候就需要斟酌：</p><ul><li>有序列表，肯定采用二分查找（binary serarch）</li><li>无序列表，看查找的次数，如果查找只进行你一次，为了避免采用二分查找的列表排序的过程的消耗，推荐采用线性查找（linear search）<br>如果进行多次查找，可采用二分查找，此时排序的消耗时间可以忽略。</li></ul><h2 id="列表排序"><a class="header-anchor" href="#列表排序">¶</a>列表排序</h2><p>将无序列表变成有序的列表</p><ul><li>输入： 列表</li><li>输出： 有序列表</li></ul><p>排序方式：升序与降序</p><p>内置排序函数： sort()</p><h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序">¶</a>冒泡排序</h3><p>冒泡排序的一趟过程：列表每两个相邻的数，如果前面比后面大，则交换两个数。（箭头只会到倒数第二个元素）  —&gt; 导致列表中的最大数的排到末尾。<br>最大值所在的区为有序区，剩下的为无序区，每一趟从无序区中得到一个最大值放到有序区中。<br>循环的次数（趟数）为列表长度n-1，因为最后一个元素不需要进行了。</p><p>代码的关键点： 趟、无序区范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>):  <span class="comment"># 排序的趟数 = 总元素个数 - 1 因为剩下的最后一个元素(表首)不需要排序</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)-i<span class="number">-1</span>):  <span class="comment"># 总长度-有序区长度 - 1 = 无序区长度 -1 </span></span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:  <span class="comment"># 当前为升序排序，若降序则改为小于即可</span></span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">li = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(li)</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure><p>时间复杂度： O(n²)</p><p>冒泡排序算法改进：<br>以上的实现中，默认是对所有的元素都进行了比较查看，<br>可能会存在的情况是说在一趟排序中，如<code>[9, 8, 7, 1, 2, 3, 4]</code>这样，在进行了3次冒泡之后，已经不需要再进行排序了，所以可以通过设置标记的方式将不在排序之后退出代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>):  </span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)-i<span class="number">-1</span>): </span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>算法改进（设置了标记值）之后，当列表值是顺序的时候，此时列表只会遍历一边，此时就达到了冒泡排序的最好情况时间复杂度 <code>O(n)</code>。</p><p>算法要点：每次循环找出并固定表尾的最大值。</p><h3 id="选择排序"><a class="header-anchor" href="#选择排序">¶</a>选择排序</h3><p>遍历列表，每次找出列表中的最小值，继续找剩下的列表中的最小值，即多次遍历列表，每次取最小数。</p><p>一般实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort_simple</span><span class="params">(li)</span>:</span></span><br><span class="line">    li_new = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)):</span><br><span class="line">        min_val = min(li)  <span class="comment"># O(n)</span></span><br><span class="line">        li_new.append(min_val)</span><br><span class="line">        li.remove(min_val) <span class="comment"># O(n)</span></span><br><span class="line">    <span class="keyword">return</span> li_new</span><br></pre></td></tr></table></figure><p>算法的时间复杂度为 O(n²)，该算法虽然实现了选择排序的功能，但却另外开辟了内存空间，我们需要做到 <code>原地排序</code> ，即不额外创建新的列表，而只在当前待排序的列表上进行操作。</p><p>改进方案：<br>将找出的小值从开头开始放，原先位置上的值与小值所在的位置进行交换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>):  <span class="comment"># i表示第几趟， 减少1 是最后剩下的一定是最大的数</span></span><br><span class="line">        min_loc = i  <span class="comment"># 将无序区第一个元素作为最小值进行比较，为了好进行位置交换操作，所以采用下标的形式</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(li)):  <span class="comment"># 此处使用i+1作为第一个元素，去除了自己和自己比的过程</span></span><br><span class="line">            <span class="keyword">if</span> li[j] &lt; li[min_loc]:</span><br><span class="line">                min_loc = j  <span class="comment"># 记录最小值的下标</span></span><br><span class="line">        li[i], li[min_loc] = li[min_loc], li[i]</span><br></pre></td></tr></table></figure><p>时间复杂度： O(n²)</p><p>算法要点：<br>每次得到表首的最小值，通过做标记，每次找出相对的较小值记录下标，一趟找出无序区的最小值与有序区某位交换位置。</p><h3 id="插入排序"><a class="header-anchor" href="#插入排序">¶</a>插入排序</h3><p>类似打牌插牌，初始手里（有序区）只有一张牌，每次（从无序区）摸一张牌，插入到手里已有牌的正确位置。</p><p>思路：<br>头部第一个数据为有序区第一个值，然后从第二个数据开始做为无序区提供的值（使用参数记录元素值，因为位置需要提供给有序区），与有序区中现有值进行比较，确定插入的位置，现有值按序挪动位置，占用无序区数据的位置。</p><blockquote><p>挪位置的规则：从有序区最后一个值与待插入值进行大小比较，如果大于待插入值，则该元素移动（下标+1）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):  <span class="comment"># i表示待插入的元素的下标</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 因为其所在位置要提供给有序区挪位，故记录</span></span><br><span class="line">        j = i - <span class="number">1</span>  <span class="comment"># j表示有序区最后元素的下标</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span>  li[j] &gt; tmp :</span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j+<span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure><p>时间复杂度： O(n²)</p><p>最好情况时间复杂度：O(n)  顺序情况，此时内部while不执行。</p><p>算法要点：和选择排序的起始下标不同，为1开始，因为默认0已经是有序区的最小值。</p><h3 id="快速排序"><a class="header-anchor" href="#快速排序">¶</a>快速排序</h3><p>思路：<br>取第一个元素p，使元素p归位（列表被分为两部分，左边都比p小，右边都比p大）。<br>递归完成所有元素的排序（左右两部分分别归位（归位时都是取部分的第一个值作为归位元素），直到归位元素一侧元素个数为1或者0），从而完成整个列表的排序。<br>所以，排序只要实现元素归位功能，然后递归即可。</p><p>快排算法框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(data, left, right)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    data 表示待排序的列表</span></span><br><span class="line"><span class="string">    left 待排序列表的起始下标</span></span><br><span class="line"><span class="string">    right 待排序列表的终点下标</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:  <span class="comment"># 递归的终止条件，当左右相等的时候说明列表中只有一个元素，此时不需要进行排序</span></span><br><span class="line">        mid = partition(data, left, right)  <span class="comment"># mid 为归位元素的下标</span></span><br><span class="line">        quick_sort(data, left, mid<span class="number">-1</span>)</span><br><span class="line">        quick_sort(data, mid+<span class="number">1</span>, right)</span><br></pre></td></tr></table></figure><p>归位算法实现：<br>归位，指回到其该有的位置（在排序后应该在的位置），实现步骤如下：</p><ol><li>以列表的第一个值为待归位的元素（归位元素：使该元素左边的元素都是小于归位元素，右边的元素都大于归位元素），并记录该元素的值，此时列表产生一个空位。</li><li>从列表的最右边开始（因为步骤1选取列表第一个元素为待归位元素后，left指向的是待填补的空位），依次找小于待归位元素的值，没有就往前一个找，找到后，将元素放到空位left上，此时右边的位置提供了一个空位，然后从左边开始找大于待归位元素的元素，依次找大于待归位元素的值，找到后当到right空位上。</li><li>以此右边左边这样循环找，直到left=right，此时的空位为待归位元素的位置（最后必定是重叠的，都指向了归位元素所在的空位），保证了左边的元素都小于等于，右边都大于等于归位元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(li, left, right)</span>:</span></span><br><span class="line">    tmp = li[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 当两侧指针重叠，取消循环</span></span><br><span class="line">        <span class="comment"># 一定要先从右边开始找，因为此时左侧有空位</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;=tmp:  <span class="comment"># 从右边往左找</span></span><br><span class="line">            right -= <span class="number">1</span>  <span class="comment"># 一旦大于等于tmp，往左一步</span></span><br><span class="line">        li[left] = li[right]  <span class="comment"># 将右边找出的小的值放在空位上</span></span><br><span class="line">        <span class="comment"># 右边找到填补空位后，再从左边开始找填补右边的空位</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]  <span class="comment"># 左边的值填补到右边的空位上</span></span><br><span class="line">    li[left] = tmp  <span class="comment"># 循环结束后，此时left = right ，并且都指向了空位</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># left 和 right 是同一个值</span></span><br></pre></td></tr></table></figure><p>快速排序的时间复杂度：O(nlogn)</p><p>复杂度的粗略估计依据：</p><ul><li>递归分层，对半分 <code>n/2</code>，每次减半，一共要分logn层，为 O(logn)</li><li>每层从全局上看是从左往右扫，扫描整个列表一次，所以每层的时间复杂度为 O(n)</li></ul><p>所以时间复杂度是 O(nlogn)</p><p>空间复杂度：O(logn)<br>算法使用到了递归，递归需要消耗系统的内存资源，考虑平均情况下递归分层为 logn 层，所以使用空间复杂度为 O(logn)。</p><p>快速排序的问题，递归：</p><ul><li>python有递归最大深度的限制（可以更改），默认的递归深度是有限制的，当递归深度超过默认值的时候，就会引发RuntimeError。<br>递归深度解决方式：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)  <span class="comment"># 表示递归深度为100w</span></span><br></pre></td></tr></table></figure></li><li>递归会消耗相当大的系统资源 — 内存</li></ul><p>快速排序最坏情况：<br>好的情况下每次分层都是能够对半分 <code>n/2</code>，所以分层要分logn层，为 O(logn) ，但是最坏的情况，如 <code>[5,4,3,2,1]</code> 这种有顺序的列表，当前算法选取的left每次都是最大值，会导致分层的时候不是对半分，而是分为 <code>1</code> 和 <code>n-1</code> 两个部分，这就导致递归分层是的层数和 <code>n</code> 相同，此时分层的时间复杂度为 O(n)，所以最坏的情况下的时间复杂度为 O(n²)。同理，此时对应的最坏空间复杂度就为O(n)。</p><p>解决措施： 为了避免有序的列表使用快排产生的问题，此时可以使用 <code>随机主元</code> 的方式，即随机选取需要归位的元素，而非使用left位置的元素，这样可以一定程度上减轻倒序列表的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_partition</span><span class="params">(li, left, right)</span>:</span></span><br><span class="line">    i = random.randint(left, right)  <span class="comment"># 随机产生需要归位的元素下标</span></span><br><span class="line">    tmp = li[i]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> right &gt; i <span class="keyword">and</span> li[right] &gt;= tmp:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[i] = li[right]</span><br><span class="line">        i = right  <span class="comment"># 将i指向新的空位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; i <span class="keyword">and</span> li[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[i] = li[left]</span><br><span class="line">        i = left</span><br><span class="line">    li[i] = tmp</span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>通过运行时间分析，在处理倒序列表时，性能提升到处理一般数据的性能，在常规列表的测试下，性能与选取left位置元素相差无几。</p><p>算法要点：配合动画理解<br>判断的标准始终是左边指针小于右指针，i始终指向的是空位。<br>默认采用的以左边第一个为待归位值，实际上是一种特殊的情况，在代码实现中left和right即作为了元素指针，又作为空位指针。</p><h3 id="堆排序"><a class="header-anchor" href="#堆排序">¶</a>堆排序</h3><h4 id="树和二叉树"><a class="header-anchor" href="#树和二叉树">¶</a>树和二叉树</h4><p>树是一种数据结构<br>一些概念：</p><ul><li>节点的度：表示某个节点的分叉个数</li><li>树的度：书中度最多的节点的度为树的度</li></ul><p>二叉树定义：</p><ul><li>度不超多2的树</li><li>每个节点最多有两个孩子节点</li></ul><p>完全二叉树：叶节点只能出现在最下层和次下层，并且最下层的节点都集中在该层最左边的若干位置的二叉树。<br>满二叉树：一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树，满二叉树是特殊的完全二叉树。</p><p>二叉树的存储方式：</p><ul><li>链式存储方式</li><li>顺序存储方式：使用列表来存储</li></ul><p>完全二叉树父节点和左孩子节点的编号下标的关系： i -&gt; 2i+1     (i从0开始)<br>完全二叉树父节点和左孩子节点的编号下标的关系： i -&gt; 2i+2     (i从0开始)<br>反之，从孩子节点找父节点都可以采用 (孩子节点编号-1)//2 ，注意使用的是整除。</p><h4 id="堆"><a class="header-anchor" href="#堆">¶</a>堆</h4><p>一种特殊的完全二叉树。<br>大根堆：一个完全二叉树，满足任一父节点都比其他孩子节点大。<br>小根堆：一个完全二叉树，满足任一父节点都比其他孩子节点小。</p><p>升序排序采用大根堆排序，利用堆的向下调整的性质实现。<br>向下调整性质：<br>当根节点的左右子树都已经是堆（假设是最大值）的时候，但根不满足堆，可以通过一次向下的调整来将其变成一个堆。<br>向下调整原理：<br>根节点不是最大值，从其两个子节点中选取较大的值替换现在的根节点（选两者的较大值保证了堆的性质，能保证根大于孩子节点），出现的空位再使用空位节点的两个子节点以及之前的根节点中的较大值最为根节点值替换，以此类推，最后的空位使用出来的变量替换。</p><p>堆排序的过程：</p><ol><li>建立一个堆（升序使用的大根堆）。</li><li>得到堆顶的元素，为当前数据中的最大值。</li><li>去除堆顶，将堆的最后一个叶子结点（选取最后一个叶子节点，是为了保证经过调整之后，最后得到的树是一个完全二叉树）的元素放到堆顶，此时可通过一次调整性质得到大根堆。</li><li>将堆顶元素抛出，为当前数据中的第二大值。</li><li>重复步骤3，直到堆为空。</li></ol><p>堆的构造：<br>一个完全二叉树，从最后一个非叶子节点开始，对每个小的子树进行向下调整，最后得到的就是一个堆。</p><h4 id="堆排序代码实现"><a class="header-anchor" href="#堆排序代码实现">¶</a>堆排序代码实现</h4><p>算法实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    大根堆向下调整实现</span></span><br><span class="line"><span class="string">    注意对的前提是此堆除了堆顶外，其他部分已经满足大根堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param li: 列表</span></span><br><span class="line"><span class="string">    :param low: 堆的根节点</span></span><br><span class="line"><span class="string">    :param high： 堆的最后一个元素的位置</span></span><br><span class="line"><span class="string">    :return</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = low  <span class="comment"># 开始指向根节点</span></span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># 开始指向左孩子节点</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 将堆顶元素存储</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:  <span class="comment"># 只要j没有越界，就表示i指向的节点不是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j+<span class="number">1</span>] &gt; li[j]:  <span class="comment"># 如果有右孩子节点，且相对较大</span></span><br><span class="line">            j = j + <span class="number">1</span>  <span class="comment"># 将j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &gt; tmp:</span><br><span class="line">            li[i] = li[j]  <span class="comment"># 直接兑换，因为以j为根的子树已经是大根堆，所以li[j]此时已经是最大的了</span></span><br><span class="line">            i = j  <span class="comment"># 同理，指向下一层，执行同样的步骤，为tmp找位置</span></span><br><span class="line">            j = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="comment"># 首先构造一个大根堆</span></span><br><span class="line">    n = len(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((n<span class="number">-2</span>)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 倒推，从最后一个父节点开始找所有的父节点</span></span><br><span class="line">        <span class="comment"># i表示建堆开始的时候调整的部分的根的下标</span></span><br><span class="line">        sift(li, i, n<span class="number">-1</span>)  <span class="comment"># 从最后一个堆开始，每个小堆都可以使用向下调整得到大根堆，循环结束后，整个大根堆构造完成</span></span><br><span class="line">        <span class="comment"># 传递的high参数使用了一个小技巧</span></span><br><span class="line">    <span class="comment"># 开始挨个提出大根堆堆顶元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):  <span class="comment"># 从最后一个元素开始，用于替换为树的根节点，剩下的最后一个不需要进行调整，所以到0即可</span></span><br><span class="line">        li[<span class="number">0</span>], li[i] = li[i], li[<span class="number">0</span>]  <span class="comment"># 堆顶和最后一个元素交换，存储堆顶最大值，将最后一个叶子节点值放到堆顶开始调整</span></span><br><span class="line">        sift(li, <span class="number">0</span>, i<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)<br>其中，sift()函数的时间复杂度为O(logn)，这是因为最坏的情况需要进行二叉树的深度次数大概是logn，即当前完全二叉树的根值需要放到最底层的叶子节点位置才完成了大根堆。</p><p>实际表现堆排序相对快速排序要稍微慢一些。</p><h4 id="heapq模块"><a class="header-anchor" href="#heapq模块">¶</a>heapq模块</h4><p>python内置的堆排序模块heapq， 其中的 _siftdown() 方法实现的就是向下调整。<br>heapq 表示的意思是 heap queue , 即用堆实现的优先队列（优先队列指小的元素先出，或者大的元素先出）。<br>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">li = list(range(<span class="number">100</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heapq.heapify(li)  <span class="comment"># 建堆，建造一个小根堆</span></span><br><span class="line"></span><br><span class="line">print(heapq.heappop(li))  <span class="comment"># 往外弹出一个最小的元素</span></span><br></pre></td></tr></table></figure><h4 id="堆的思想的应用"><a class="header-anchor" href="#堆的思想的应用">¶</a>堆的思想的应用</h4><p>topk 问题：现有n个数，设计算法得到前k大的数（k &lt; n）。<br>解决该问题的几种方式：</p><ul><li>排序后进行切片 O(nlogn)，k &lt; n，此处忽略切片的复杂度 O(k)，只考虑了排序的时间复杂度（排序采用时间复杂度更低的快排或者堆排）。</li><li>使用复杂度为 O(n²) 的排序算法，但只进行k次排序（因为topk问题只要前k大的数），总的时间复杂度为 O(kn)，当数据多，k小的时候，该算法明显优于方法1。</li><li>采用堆，思路和堆排序的实现类似，但是堆的元素只有k个，时间复杂度为 O(nlogk)。</li></ul><p>使用堆解决 topk 问题思路：</p><ol><li>取列表前 k 个元素建立一个 <strong>小根堆</strong>，堆顶就是目前第 k 大的数（ k 个元素中的最小的那个元素）。</li><li>依次向后遍历原列表，将列表中的元素与当前小根堆的堆顶元素比较，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素（此时堆内的元素就是目前 k 个最大的元素，堆顶是 k 个元素中最小的），并且对堆进行依次调整。</li><li>遍历列表所有元素后，倒序弹出堆顶元素。</li></ol><blockquote><p>topk 问题一定要采用小根堆，因为堆中元素的大小关系，只能保证的是堆顶元素一定是最大的（使用大根堆）或者最小的（使用小根堆）。</p></blockquote><p>此方式的时间复杂度为 O(nlogk)，需要遍历所有的数 n，但是堆的元素个数始终只有 k 个，所以此时 sift() 函数的时间复杂度和 k 相关，为O(logk)，所以使用堆解决 topk 的时间复杂度为O(nlogk)</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    小根堆向下调整</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = low  </span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>  </span><br><span class="line">    tmp = li[low] </span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:  </span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j+<span class="number">1</span>] &lt; li[j]:  </span><br><span class="line">            j = j + <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">if</span> li[j] &lt; tmp:</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j  </span><br><span class="line">            j = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(li, k)</span>:</span></span><br><span class="line">    heap = li[<span class="number">0</span>:k]</span><br><span class="line">    <span class="comment"># 建堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((k<span class="number">-2</span>)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        sift(heap, i, k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 遍历列表剩余元素，如果比堆顶元素大，就替换并重新调整小根堆</span></span><br><span class="line">    print(<span class="string">'最初的根堆：'</span>, heap)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(li)):</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>] = li[i]</span><br><span class="line">            sift(heap, <span class="number">0</span>, k<span class="number">-1</span>)</span><br><span class="line">        print(<span class="string">'小排序：'</span>, heap)</span><br><span class="line">    print(<span class="string">'完成：'</span>, heap)</span><br><span class="line">    <span class="comment"># 倒序输出堆中的元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        heap[<span class="number">0</span>], heap[i] = heap[i], heap[<span class="number">0</span>]</span><br><span class="line">        sift(heap, <span class="number">0</span>, i<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a class="header-anchor" href="#归并排序">¶</a>归并排序</h3><p>归并：将两个有序的列表合并为一个有序的列表</p><p>归并排序步骤：</p><ol><li>分解：将列表越分越小，直至分成一个元素为一个列表。</li><li>终止条件： 一个元素是有序的。</li><li>合并： 将两个有序列表归并，列表越来越大。</li></ol><p>算法实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(li, low, mid, high)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    归并</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    i = low</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    ltmp = []  <span class="comment">#  设置临时变量</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;= mid <span class="keyword">and</span> j &lt;= high:  <span class="comment"># 只要左右两边都有数</span></span><br><span class="line">        <span class="keyword">if</span> li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># while执行完，两部分肯定有一部分是没有值的</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    li[low:high+<span class="number">1</span>] = ltmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:  <span class="comment"># 至少有两个元素，递归，只有一个元素时不需要处理</span></span><br><span class="line">        mid = (low+high) // <span class="number">2</span></span><br><span class="line">        merge_sort(li, low, mid)</span><br><span class="line">        merge_sort(li, mid+<span class="number">1</span>, high)</span><br><span class="line">        merge(li, low, mid, high)  <span class="comment"># 通过递归，此函数第一次执行的时候，一定是两个各位1个元素的列表的集合。</span></span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)<br>之前的排序都是原地排序，但是归并排序需要使用一个中间列表存储一次归并后的列表，所以需要使用额外的空间，需要考虑空间复杂度</p><p>Python 内置的 <code>list.sort()</code> 方法内部实现是基于归并排序的 <code>TimSort</code> 排序算法，是结合了归并排序以及插入排序的排序算法。</p><h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3><p>一般情况下，就运行时间而言：<br>快速排序 &lt; 归并排序 &lt; 堆排序</p><p>三种排序算法的缺点：</p><ul><li>快速排序：极端情况下（倒序）效率低，为 O(n²)。</li><li>归并排序：需要额外的内存开销。</li><li>堆排序： 在快的排序算法中相对较慢 。</li></ul><p><img src="/2020/08/03/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4.jpg" alt="常规算法时间空间复杂度"></p><p>排序的稳定性：当两个元素的值一样的时候，保证他们的相对位置不变。<br>一般的，挨个比较的都是稳定的，如冒泡排序、插入排序、归并排序等。</p><h3 id="希尔排序"><a class="header-anchor" href="#希尔排序">¶</a>希尔排序</h3><p>由插入排序变形而来，是一种分组插入排序。<br>步骤：</p><ol><li>首先取一个整数d𝟭=n/2，将元素分为d𝟭个组，每组相邻两个元素之间的距离为 d𝟭，在各组内进行直接插入排序。</li><li>取第二个整数d𝟮=d𝟭/2， 重复上述分组排序过程，直到d𝐢=1，即所有元素在同一个组内进行直接插入排序。</li></ol><p>希尔排序每趟并不使元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p><p>实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort_gap</span><span class="params">(li, gap)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, len(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i- gap</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; tmp:</span><br><span class="line">            li[j+gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j+gap] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    d = len(li) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> d &gt;= <span class="number">1</span>:</span><br><span class="line">        insert_sort_gap(li, d)</span><br><span class="line">        d //= <span class="number">2</span></span><br></pre></td></tr></table></figure><p>和插入排序的性能对比：强于普通的插入排序，稍慢于堆排序（所以也比快速排序以及归并排序慢）</p><p>希尔排序的时间复杂度：没有明确的值，取决于 gap 的选择，不同的 gap，得到的时间复杂度也不相同，我们选取的 gap 为 N/2ᴷ，时间复杂度介于 O(nlogn) 和 O(n²) 之间。</p><h3 id="计数排序"><a class="header-anchor" href="#计数排序">¶</a>计数排序</h3><p>是一个非基于比较的排序算法。<br><strong>前提条件是，需要知晓待排序的列表中的元素值的范围。</strong></p><p>解决诸如以下问题：<br>对列表进行排序，已知列表中数的范围都在0到100之间，设计时间复杂度为O(n)的排序算法。</p><p>实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(li, max_count=<span class="number">100</span>)</span>:</span></span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_count+<span class="number">1</span>)]  <span class="comment"># 建立一个用于计数的列表，列表的下标用于记录数，下标上的值作为统计的个数</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">        count[val] += <span class="number">1</span></span><br><span class="line">    li.clear()  <span class="comment"># 使用原先的列表空间作为排序后的列表空间</span></span><br><span class="line">    <span class="keyword">for</span> ind, val <span class="keyword">in</span> enumerate(count):  <span class="comment"># 操作的对象不是n(这里的排序对象li），所以不参与时间复杂度计算，涉及到n的部分实际上就是li.append(ind)的过程，为O(n)，所以整体的时间复杂度为O(n)</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(val):  </span><br><span class="line">            li.append(ind)</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">li = [random.randint(<span class="number">0</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">count_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure><p>它的优势在于在对一定范围内的整数排序时，它的复杂度为 Ο(n+k)（其中k是整数的范围），快于其他任何的 <code>比较排序</code> 算法。当然这是一种牺牲空间换取时间的做法，而且当 O(k)&gt;O(nlog(n)) 的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是 O(nlog(n)), 如归并排序，堆排序）。</p><h3 id="桶排序"><a class="header-anchor" href="#桶排序">¶</a>桶排序</h3><p>在计数排序中，如果元素范围比较大，为了构造相应的列表就会消耗大量的资源，此时可以使用桶排序的方式进行改造(避免了未存在的元素占用列表空间)。<br>桶排序（Bucket Sort）：首先将元素分在不同的桶中，再对每个桶中元素进行排序。</p><p>实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(li, n=<span class="number">100</span>, max_num=<span class="number">10000</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    n : 桶的个数</span></span><br><span class="line"><span class="string">    max_num: 所有的数中的最大值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    bucketes = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]  <span class="comment"># 创建桶</span></span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> li:  <span class="comment"># 数据入桶</span></span><br><span class="line">        i = min(var // (max_num//n), n<span class="number">-1</span>) <span class="comment"># i 表示 var 放到几号桶里，桶号从0开始</span></span><br><span class="line">        <span class="comment"># 使用min(.., n-1)是为了处理临界情况，超过的数放到最后的桶中</span></span><br><span class="line">        bucketes[i].append(var)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(bucketes[i])<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> bucketes[i][j] &lt; bucketes[i][j<span class="number">-1</span>]:</span><br><span class="line">                bucketes[i][j], bucketes[i][j<span class="number">-1</span>] = bucketes[i][j<span class="number">-1</span>], bucketes[i][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    sorted_li = []</span><br><span class="line">    <span class="keyword">for</span> buc <span class="keyword">in</span> bucketes:</span><br><span class="line">        <span class="comment"># sorted_li += buc</span></span><br><span class="line">        sorted_li.extend(buc)</span><br><span class="line">    <span class="keyword">return</span> sorted_li</span><br></pre></td></tr></table></figure><p>分析：<br>代码的核心内容是<code>i = min(var // (max_num//n), n-1) </code>，该语句巧妙的完成了分桶以及数据的入桶，这是一种平均情况下的分桶策略，对于如果数据分布集中的情况下，可以对集中部分的桶再进行分桶，这取决于具体的数据情况。<br>分桶的桶的数量取决于数据中的最大值。</p><p>桶排序的表现取决于数据的分布，假使大部分的数据都集中在一个桶中，则性能就取决于一个桶的排序性能，而我们使用桶排序的目的是为了将数据分散在不同的桶中，每个桶中存储等量较少值，然后对较少的值进行排序，这样排序性能才会有所提升。也就是需要对不同数据排序时采取不同的分桶策略。</p><p>平均情况的时间复杂度：O(n+k)<br>最坏情况时间复杂度：O(n²k)<br>空间复杂度：O(nk)<br>*k 通过n和m算出（n表示数据的个数，m表示桶的个数），k表示一个桶的大小。</p><p>优化建议：桶内数据的排序方式、不同数据分布下，分桶的策略。</p><h3 id="基数排序"><a class="header-anchor" href="#基数排序">¶</a>基数排序</h3><p>类似关键字排序，基于桶排序，但是不使用桶内排序，而是借助桶的顺序（0-9的桶），完成每个数位上的数值大小的排序，从而实现所有数据的排序。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    max_num = max(li)  <span class="comment"># 最大值的位数决定了循环的次数</span></span><br><span class="line">    it = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">10</span> ** it &lt;= max_num:</span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> var <span class="keyword">in</span> li:</span><br><span class="line">            digit = (var // <span class="number">10</span> ** it) % <span class="number">10</span></span><br><span class="line">            buckets[digit].append(var)</span><br><span class="line">        <span class="comment"># 分桶完成</span></span><br><span class="line">        li.clear()</span><br><span class="line">        <span class="keyword">for</span> buc <span class="keyword">in</span> buckets:</span><br><span class="line">            li.extend(buc)  <span class="comment"># 把数据直接写会原来的数组，此时数组已经完成了个位数的排序，然后继续执行十位数的排序，依次进行。</span></span><br><span class="line">        it += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>关键点：没有使用内部排序，而是借助0-9的桶的相对位置来完成数据的排序。<br>时间复杂度：O(kn)<br>空间复杂度：O(k+n)<br>k表示数字的位数，代码中的it。</p><p>分析：基数排序的时间复杂度是线性的，相比于非线性的快速排序，在特定的情况下的数据</p><h3 id><a class="header-anchor" href="#">¶</a></h3>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64 编码</title>
      <link href="2020/07/23/Base64-%E7%BC%96%E7%A0%81/"/>
      <url>2020/07/23/Base64-%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Base64 是网络上最常见的用于传输 8Bit 字节码的编码方式之一，Base64 就是一种基于64个可打印字符来表示二进制数据的方法。</p><p>Base64编码由以下64个字符构成： ‘A-Z’(26)，‘a-z’(26)，‘0-9’(10)，’+’(1)，’/’(1)</p><h2 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h2><p>以 <code>Hello,World!</code> 共12个字符为例，需要经过以下几个步骤完成编码过程：</p><ol><li><p>将原文字符每3个字节一组进行划分<br>划分为  <code>Hel</code> <code>lo,</code> <code>Wor</code> <code>ld!</code> 这四个部分</p></li><li><p>将每组3个字节转化为24位二进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hel    010010000110010101101100</span><br><span class="line">lo,    011011000110111100101100</span><br><span class="line">Wor    010101110110111101110010</span><br><span class="line">ld!    011011000110010000100001</span><br></pre></td></tr></table></figure></li><li><p>将24位二进制数按6位一组转化成4个十进制数<br>之所以按6位一组，是因为6个二进制位正好表示0～63，对应 Base64 字符表的64个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hel    [18, 6, 21, 44]</span><br><span class="line">lo,    [27, 6, 60, 44]</span><br><span class="line">Wor    [21, 54, 61, 50]</span><br><span class="line">ld!    [27, 6, 16, 33]</span><br></pre></td></tr></table></figure></li><li><p>将十进制数按 Base64 字符表编号查找相应字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hel    SGVs</span><br><span class="line">lo,    bG8s</span><br><span class="line">Wor    V29y</span><br><span class="line">ld!    bGQh</span><br></pre></td></tr></table></figure></li><li><p>将每组字符按原先字符组成顺序连接为原字符的 Base64 编码<br><code>Hello,World!</code> 的 Base64 编码为 <code>SGVsbG8sV29ybGQh</code></p></li></ol><p>总的操作过程是：将所有的字符转换为二进制，然后每6个二进制位一组，不足6位的低位补充0，每6个二进制位转换为对应的十进制数查ascii表得到对应的ascii。</p><h2 id="代码实现"><a class="header-anchor" href="#代码实现">¶</a>代码实现</h2><p>根据基本原理，使用 Python 代码实现基础功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base</span><span class="params">(string:str)</span>-&gt;str:</span></span><br><span class="line">    oldstr = <span class="string">''</span></span><br><span class="line">    newstr = []</span><br><span class="line">    base = <span class="string">''</span></span><br><span class="line">    base64_list = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>, <span class="string">'K'</span>, <span class="string">'L'</span>, </span><br><span class="line">                   <span class="string">'M'</span>, <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>,<span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'S'</span>, <span class="string">'T'</span>, <span class="string">'U'</span>, <span class="string">'V'</span>, <span class="string">'W'</span>, <span class="string">'X'</span>, </span><br><span class="line">                   <span class="string">'Y'</span>, <span class="string">'Z'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>,<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, </span><br><span class="line">                   <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>,</span><br><span class="line">                   <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, </span><br><span class="line">                   <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'+'</span>, <span class="string">'/'</span>]</span><br><span class="line">    <span class="comment">#把原始字符串转换为二进制，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">        oldstr += <span class="string">'&#123;:08&#125;'</span>.format(int(str(bin(ord(i))).replace(<span class="string">'0b'</span>, <span class="string">''</span>)))</span><br><span class="line">    <span class="comment">#把转换好的二进制按照6位一组分好，最后一组不足6位的后面补0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(oldstr), <span class="number">6</span>):</span><br><span class="line">        newstr.append(<span class="string">'&#123;:&lt;06&#125;'</span>.format(oldstr[j:j + <span class="number">6</span>]))</span><br><span class="line">    <span class="comment">#在base_list中找到对应的字符，拼接</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(len(newstr)):</span><br><span class="line">        base += base64_list[int(newstr[l], <span class="number">2</span>)]</span><br><span class="line">    <span class="comment">#判断base字符结尾补几个‘=’</span></span><br><span class="line">    <span class="keyword">if</span> len(string) % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">        base += <span class="string">'=='</span></span><br><span class="line">    <span class="keyword">elif</span> len(string) % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">        base += <span class="string">'='</span></span><br><span class="line">    <span class="keyword">return</span>  base</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a class="header-anchor" href="#代码解释">¶</a>代码解释</h3><p>进制转换内置函数只能是数字作为对象，或者其他进制表示的数字</p><ul><li><code>bin()</code> 用于将各进制数转换为二进制表示，开头以<code>0b</code>表示，如 <code>0b1001000</code></li><li><code>oct()</code> 用于将各进制数转换为八进制表示，开头以<code>0o</code>表示，如 <code>0o110</code></li><li><code>hex()</code> 用于将各进制数转换为十六进制表示，开头以<code>0x</code>表示，如 <code>0x48</code></li><li><code>int()</code> 用于将各进制数转换为十进制表示，如 <code>72</code></li></ul><p><code>int(x, base=10)</code> 可以接受各进制数，以及字符串形式的数字转换为对应的整型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将二进制<span class="string">'0b1001000'</span>转换为对应的十进制表示</span><br><span class="line">int(<span class="number">0b1001000</span>)     输出 <span class="number">72</span></span><br><span class="line">或者使用 int(<span class="string">'1001000'</span>, <span class="number">2</span>)  注意，此时需要使用字符串形式，且必须指明该数字之前的类型，<span class="number">2</span>表示之前是二进制，否则默认的base是<span class="number">10</span>，为十进制，则输出的结果是 <span class="number">1001000</span></span><br></pre></td></tr></table></figure><p><code>ord()</code>用于获得字符对应的ASCII码，<code>chr()</code>相反，用于获得ASCII码对应的字符。<br>所以要获得字符的二进制码，需要使用先使用<code>ord()</code>函数得到字符对应的ascii码，然后使用<code>bin()</code>得到对应的二进制。</p><p>如果最后剩下两个输入数据，在编码结果后加1个“=”；如果最后剩下一个输入数据，编码结果后加2个“=”；如果没有剩下任何数据，就什么都不要加，<strong>这样才可以保证资料还原的正确性</strong>。</p><blockquote><p>注意：以上代码只是原理的简单实现，只适用于ASCII的码，不能用于汉字</p></blockquote><h2 id="Python内置模块"><a class="header-anchor" href="#Python内置模块">¶</a>Python内置模块</h2><p>Python 内置的 base64模块 可以直接进行base64的编解码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要注意的是，b64encode()方法接收一个字节类对象，所以需要使用 encode() 或者 b'' 的形式</span></span><br><span class="line">print(base64.b64encode(<span class="string">"Hello,World!"</span>.encode(<span class="string">'utf-8'</span>)))  <span class="comment"># b'SGVsbG8sV29ybGQh'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码 Base64 编码过的 bytes-like object 或 ASCII 字符串 并返回解码过的 bytes。</span></span><br><span class="line">print(base64.b64decode(<span class="string">b'SGVsbG8sV29ybGQh'</span>))  <span class="comment"># b'Hello,World!'</span></span><br><span class="line"><span class="comment"># 需要解码后返回str，可以使用 decode('utf-8')</span></span><br><span class="line">print(base64.b64decode(<span class="string">b'SGVsbG8sV29ybGQh'</span>).decode(<span class="string">'utf-8'</span>))  <span class="comment"># Hello,World!</span></span><br></pre></td></tr></table></figure><p>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符+和/分别变成-和_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">print(base64.b64encode(<span class="string">b'i\xb7\x1d\xfb\xef\xff'</span>))  <span class="comment"># b'abcd++//'</span></span><br><span class="line">print(base64.urlsafe_b64encode(<span class="string">b'i\xb7\x1d\xfb\xef\xff'</span>))  <span class="comment"># b'abcd--__'</span></span><br></pre></td></tr></table></figure><h2 id="编码与转码"><a class="header-anchor" href="#编码与转码">¶</a>编码与转码</h2><p>常用编码说明：<br>ASCII码：只有一个字节，且开始的时候连最高位都没有用，为0，只用了后7位，共127个来存储英文。<br>GB2312:为了能使用两个字节表示一个汉字，所以使用两个字节来存储一个字符。<br>Unicode：是编码标准，规定了使用两个字节来表示一个字符，足以涵盖世界上所有的语言，<font color="red">是计算机内数据存储的编码方式</font>。<br>UTF-8：诞生是因为Unicode编码标准规定所有的都是用两个字节，但是英文只要一个字节存储足矣，所以为了节省空间，提出了utf-8, 是一种针对Unicode的可变长度字符编码，它可以使用1~4个字节表示一个符号（用一个字节表示英文，三个字节表示汉字），根据不同的符号改变字节长度，当字符在ASCII码的范围时，就用一个字节表示，所以是兼容ASCII编码的。这样显著的好处是，虽然在我们内存中的数据都是unicode，但当数据要保存到磁盘或者用于网络传输时，直接使用unicode就远不如utf8省空间,这也是为什么utf8是我们的推荐编码方式。</p><p>Unicode与utf8的关系：<br>一言以蔽之：Unicode是内存编码表示方案（是规范），而UTF是如何保存和传输Unicode的方案（是实现）这也是UTF与Unicode的区别。<br><img src="/2020/07/23/Base64-%E7%BC%96%E7%A0%81/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2.png" alt="编码转换图"><br>解释：<br>可见在计算机内部的编码是unicode标准存储的，即一个字符两个字节。<br>通过 <code>encode</code> 使用utf-8编码后，一个汉字占3个字节<br>通过 <code>encode</code> 使用gbk编码后，一个汉字占2个字节<br>想要获得unicode，需要使用对应的编码 <code>decode</code> 进行还原。<br>所以不同的编码规则之间是不可以直接进行转换的，否则会因为存储字节数的不同（有的即使字节数一样，使用的编码表也是不同的），导致乱码，即使不是乱码，也和原本要存储的不一致。所以若要将utf-8的数据要变成gbk类型的数据，需要先 <code>decode(utf-8)</code> 还原成unicode标准，然后再 <code>encode(gbk)</code> 变成gbk类型。</p><h3 id="Python3-编码处理"><a class="header-anchor" href="#Python3-编码处理">¶</a>Python3 编码处理</h3><p>Python3中字符串就是unicode编码，而计算机内存中处理的时候也是使用的unicode编码。<br>这里需要明确一点就是：计算机在内存中处理信息时使用的是unicode编码，但是存储的时候会转换成某种编码方式编码的bytes字节串进行存储，不同的系统、不同的软件使用的编码格式可能不同，</p><p>因为utf-8为可变长编码，占用的空间要少于unicode，所以在网络传输，硬盘存储的时候都是将unicode编码变成utf-8编码在去处理，主要是英文只占了一个字节，而英文是网络传输和存储中被大量使用的字符。</p><p>如果一个我们读取一个文件，改文件保存时的编码是比如gbk，则我们在读取的时候，就应该先 encoding = ‘gbk’ （只用encoding，此时的encoding和encode()不是同一个意思，encode指定的进行编码这个动作的格式，而encoding是指定文本的使用的编码方式）  或是  文本.decode(“gbk”) 解码为unicode在进行操作。<br>再如网络传输的时候，都要先使用str.encode(“utf-8”) 将unicode转变为utf-8编码进行传输，在接受到数据的时候再使用 数据.decode(“utf-8”) 将str解码为 unicode处理</p><p>Python3中str类型存unicode数据（两个字节），bytse类型存bytes数据（字节型）</p><p>通过在字符串之前使用 <code>b’字符串’</code> 的方式，可以声明字节类型，但是这种方式后面的字符串只能是ASCII码，此外可以使用 <code>bytes(‘字符串’,encoding = ‘编码方式’)</code> 得到相应编码的二进制数据。<br>使用 <code>str(‘二进制编码’, encoding = “解码方式”)</code> 可以还原到原始的str类型数据（使用的unicode两个字节存储的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'小明'</span></span><br><span class="line">name = bytes(name, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># name = name.encode('utf-8')  # b'\xe5\xb0\x8f\xe6\x98\x8e'</span></span><br><span class="line">print(name)  <span class="comment"># b'\xe5\xb0\x8f\xe6\x98\x8e' </span></span><br><span class="line"></span><br><span class="line">name = str(<span class="string">b'\xe5\xb0\x8f\xe6\x98\x8e'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(name)  <span class="comment"># 小明</span></span><br></pre></td></tr></table></figure><p>这是一对互逆操作。</p><p>Python3的解释器的默认解码方式是utf-8，而Python2的解释器使用的默认解码方式是ascii，所以要在开头声明 <code>#coding:utf8</code>，用于指定python2解释器读取python文件使用的解码方式（此时需要python文件的编码格式是utf8，否则需换成相应的格式，如 #coding:gbk， 但是目前使用的都是utf8）。<br>这里要注意区分，Python3的解释器的默认解码方式是utf-8，指的是以utf-8去解释Python文件，读取其中的内容，所以Python文件在创建的时候使用utf-8编码（一般应用创建的文件多数都采用的utf-8编码，磁盘存取时会自动完成utf-8和unicode的转换）。<br>而Python3中str类型存unicode数据，是指在内存的操作（通过 <code>.encode('unicode_escape')</code> 的编码方式，发现是使用的2个字节的unicode存储方式），两者不是一个层面的意思。</p><p>在Python3中定义str类型，既可以使用直接的表述<code>（a =’你好’）</code>，也可以使用它对应的unicode编码，因为str在内存中以unicode表示。<code>a = b'\xe4\xbd\xa0\xe5\xa5\xbd'</code> 两者是等价的，因为本质上都是同一个二进制数据的不同的表现形式，一个是string类型，一个是它使用utf-8编码格式对应的字节类型。</p><p>所以说unicode表示的内容是不变的，然后通过 <code>.encode(编码格式)</code> 编码得到相应编码格式的二进制字节型数据，因为各种编码格式不同（占用的字节不同），所以编码后续使用原来的编码格式进行解码才能得到源数据，不能混用，会出现乱码。</p><p>所以说：当我们有需求说要将一个str装换为字节型数据的时候，实际就只要 <code>encod(&quot;一种编码格式&quot;)</code> ，由于使用的编码格式不同，我们转换的字节型数据就有多种，这是没有问题的，而我们之所以会一般选择utf-8来进行编码，因为占用的资源较少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">编码解码的过程中必须显示的指定编码格式</span></span><br><span class="line"><span class="string">bytes()方法是一定要指定encoding参数的，但是str()在转换时候不一定</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">be = <span class="string">b'\xe4\xbd\xa0\xe5\xa5\xbd'</span></span><br><span class="line">print(type(be))                     <span class="comment"># &lt;class 'bytes'&gt;</span></span><br><span class="line">st = str(be)</span><br><span class="line">print(st)                           <span class="comment"># b'\xe4\xbd\xa0\xe5\xa5\xbd'</span></span><br><span class="line">print(type(st))                     <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">st1 = str(be, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(st1))                     <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(st1)                           <span class="comment"># 你好</span></span><br><span class="line">print(be.decode(<span class="string">'utf-8'</span>))             <span class="comment"># 你好</span></span><br></pre></td></tr></table></figure><p>文本文件，都是使用unicode存在内存中的，当涉及到音频、视频、图像文件的时候，都是二进制流，所以open操作这些类型的文件的时候要加b。</p><h3 id="乱码问题"><a class="header-anchor" href="#乱码问题">¶</a>乱码问题</h3><p>创建一个urf-8编码的文件<code>test.txt</code>，内容是<code>hello，王小明</code>，使用下面的程序，分别在win和非win系统下运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'./test.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure><p>在win系统下，打印的内容为：<code>hello锛岀帇灏忔槑</code><br>在非win系统下，打印的内容为：<code>hello，王小明</code>， 可以正常打印。</p><p>这是因为你的win的操作系统安装时是默认的gbk编码，而linux操作系统默认的是utf8编码。当执行open函数时，调用的是操作系统打开文件，操作系统用默认的gbk编码去解码utf8的文件，自然乱码，此时只要添加<code>encoding='utf-8'</code>参数，指定使用的编码方式为utf8即可。如果你的文件保存的是gbk编码，在win 下就不用指定encoding了。另外，如果你的win上不需要指定给操作系统encoding=‘utf8’，那就是你安装时就是默认的utf8编码或者已经通过命令修改成了utf8编码。<br>所以，为了代码的兼容性，推荐还是需要设置 encoding 参数的。</p><p><strong>编码的本质： 使用不同的字符表获得相应的字符，底层存数据的时候都是二进制，只是各种编码方式的字节不同，也就是断句不同，所以要以相应的编码处理。</strong></p><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。<br>除了使用标准的 Base64 字母表，还可以自己定义64个字符的排列顺序，这样就可以自定义 Base64 编码，不过，通常情况下完全没有必要。</p><p>Base64 是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。<br>Base64 适用于小段内容的编码，比如数字证书签名、Cookie的内容等。<br>Base64是一种任意二进制到文本字符串的编码方法，常用于在 URL、Cookie、网页中传输少量二进制数据。</p><p>参考：官方文档：<a href="https://docs.python.org/zh-cn/3/library/base64.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/base64.html</a><br>廖雪峰：<a href="https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576</a><br>python编码：<a href="https://www.cnblogs.com/yuanchenqi/articles/5956943.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanchenqi/articles/5956943.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base64 标准库库 </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask初探</title>
      <link href="2020/06/01/Flask%E5%88%9D%E6%8E%A2/"/>
      <url>2020/06/01/Flask%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="flask初探"><a class="header-anchor" href="#flask初探">¶</a>flask初探</h2><p>一个最小的应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')  # 通过装饰器声明路由</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br></pre></td></tr></table></figure><p>上面的例子中index()函数注册为应用根地址的处理程序。使用<code>app.route()</code>装饰器注册视图函数是首选方法，但不是唯一的方法。Flask还支持一种更传统的方式：使用<code>app.add_url_rule()</code>方法。这个方法最简单的形式接受3个参数：URL、端点名和视图函数。下述示例使用app.add url rule()方法注册index()函数，其作用与前例相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line">app.add_url_rule(<span class="string">'/'</span>, <span class="string">'index'</span>, index)</span><br></pre></td></tr></table></figure><h3 id="启动项目"><a class="header-anchor" href="#启动项目">¶</a>启动项目</h3><p>一个完成的应用应该包括一个应用实例、一个路由和一个视图函数，此时运行以上的程序就可以完成一个小型的网页请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FLASK_APP=app.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> flask run</span></span><br><span class="line"> * Running on http://127.0.0.1:5000/</span><br></pre></td></tr></table></figure><p>命令解释：</p><ul><li><p>export FLASK_APP=<a href="http://hello.py" target="_blank" rel="noopener">hello.py</a> ：设置环境变量，用于指定运行的应用文件，若没有设置，则默认会在项目根目录下找名为<code>wsgi.py</code> 或者 <code>app.py</code>的文件进行启动，否则会报异常。</p></li><li><p>flask run ：运行项目</p></li></ul><p>此时访问默认路径<code>http://127.0.0.1:5000/</code>即可进行访问，和Django类似，若想被外部服务器、特定的端口访问，可以使用<code>flask run --host=0.0.0.0 --port=5050</code>，此时外部就可以进行访问。</p><p>处理通过 <code>flask run</code> 命令的方式启动项目之外，还可以通过python脚本的方式启动项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以python脚本方式启动项目</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')  # 通过装饰器声明路由</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  app.run()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python app.py</span></span><br></pre></td></tr></table></figure><p>该方式在单元测试中用较多。</p><h3 id="调试模式"><a class="header-anchor" href="#调试模式">¶</a>调试模式</h3><p>通过设置环境变量 <code>export FLASK_ENV=development</code> 启动调试模式，在该模式下，每次修改代码服务器都会自动重启，并且当应用出错的时候，还会提供调试工具。和Django一样，调试模式不应该应用在生产环境中。</p><h2 id="路由"><a class="header-anchor" href="#路由">¶</a>路由</h2><p>通过使用装饰器 <code>@route()</code> 或者 <code>app.add_url_rule()</code>将视图函数绑定到URL中，可以在URL中添加变量，实现动态路由，除了添加变量之外，还可以指定变量的类型。</p><table><thead><tr><th>类型</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td><code>string</code></td><td style="text-align:left">（缺省值） 接受任何不包含斜杠的文本</td></tr><tr><td><code>int</code></td><td style="text-align:left">接受正整数</td></tr><tr><td><code>float</code></td><td style="text-align:left">接受正浮点数</td></tr><tr><td><code>path</code></td><td style="text-align:left">类似 <code>string</code> ，但可以包含斜杠</td></tr><tr><td><code>uuid</code></td><td style="text-align:left">接受 UUID 字符串（通用唯一识别码）</td></tr></tbody></table><p>path演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cgi <span class="keyword">import</span> escape</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/path/&lt;path:subpath&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_subpath</span><span class="params">(subpath)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Subpath %s'</span> % escape(subpath)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 访问 localhost:5000/path/baidu/google</span></span><br><span class="line"><span class="comment"># 返回结果：Subpath baidu/google</span></span><br></pre></td></tr></table></figure><p>uuid演示： UUID是由一组32位数的16进制数字所构成，以连字号分隔的五组来显示，形式为 8-4-4-4-12，总共有 36个字符（即三十二个英数字母和四个连字号）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/uuid/&lt;uuid:uuid&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_uuid</span><span class="params">(uuid)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Uuid %s'</span> % uuid</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 访问 localhost:5000/uuid/123e4567-e89b-12d3-a456-426655440000</span></span><br><span class="line"><span class="comment"># 返回结果：Uuid 123e4567-e89b-12d3-a456-426655440000</span></span><br></pre></td></tr></table></figure><h3 id="关于URL后是否添加-的问题"><a class="header-anchor" href="#关于URL后是否添加-的问题">¶</a>关于URL后是否添加 / 的问题</h3><p>在访问尾部有斜杠的url的时候，若是填写url时没有添加/，则此次的访问会自动重定向到尾部含有斜杠的路径中，所以在访问尾部有斜杠的url的时候，无论手动添加斜杠与否，最终都会访问有斜杠的路径。</p><p>在访问尾部没有斜杠的url的时候，要是手动在末尾添加了斜杠，则得到404错误。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Flask </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django+Vue 前后端分离项目的跨域请求问题</title>
      <link href="2020/05/24/Django-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/"/>
      <url>2020/05/24/Django-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>产生问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;categorys&#x2F;&#39; from origin &#39;http:&#x2F;&#x2F;localhost:8080&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>分析：<br>接口调试的时候，前端 vue 使用的端口是 8080，而请求的后端服务器使用的端口是 8000，两者之间跨端口，这里已经产生前后端<a href="https://blog.csdn.net/ppxin/article/details/94717173" target="_blank" rel="noopener">跨域请求</a>的问题，从浏览器角度是禁止跨域请求的。</p><p>解决：</p><ul><li>从前端vue角度进行解决：在 vue 中设置 proxy 代理、</li><li>从后端django角度解决：借助 <code>django-cors-headers</code> 模块，实现服务器端的跨域请求</li></ul><br><p>本例中主要从后端服务器角度解决跨域请求的问题，使用 <code>django-cors-headers</code> 模块解决跨域问题：</p><ol><li>首先使用 <code>pip install django-cors-headers</code> 进行安装安装</li><li>在 <a href="http://settings.py" target="_blank" rel="noopener">settings.py</a> 中的 INSTALLED_APPS 添加 <code>'corsheaders'</code></li><li>在MIDDLEWARE中添加中间件 <code>'corsheaders.middleware.CorsMiddleware'</code>，该中间件需要放在’django.middleware.csrf.CsrfViewMiddleware’ 之前。</li><li>在settings.py进行相关配置<br>设置 CORS_ORIGIN_ALLOW_ALL：值为 True 则表示所有域名下都能访问（忽略跨域问题），默认为 False。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span></span><br></pre></td></tr></table></figure>设置 CORS_ORIGIN_WHITELIST：允许访问的白名单，只有在白名单内的可以忽略跨域问题访问（该项的设置只有在CORS_ORIGIN_ALLOW_ALL设置为False时有效）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">False</span>  <span class="comment"># 此时，该值必须设置为False</span></span><br><span class="line">CORS_ORIGIN_WHITELIST = (</span><br><span class="line">    <span class="comment"># 凡是出现在白名单中的域名，都可以访问后端接口</span></span><br><span class="line">    <span class="string">'127.0.0.1:8080'</span>,</span><br><span class="line">    <span class="string">'localhost:8080'</span>,</span><br><span class="line">    <span class="string">'www.meiduo.site:8080'</span>,</span><br><span class="line">    <span class="string">'api.meiduo.site:8000'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>设置 CORS_ALLOW_CREDENTIALS：指明在跨域访问中，后端是否支持对cookie的操作，默认是True。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ol><p>django-cors-headers 为开源项目，更多功能配置参考项目地址：<a href="https://github.com/adamchainz/django-cors-headers" target="_blank" rel="noopener">https://github.com/adamchainz/django-cors-headers</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> 跨域请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django静态资源配置</title>
      <link href="2020/04/30/Django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
      <url>2020/04/30/Django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="静态文件"><a class="header-anchor" href="#静态文件">¶</a>静态文件</h2><p>静态文件的配置，一般需要使用到以下几个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL</span><br><span class="line">STATIC_ROOT</span><br><span class="line">STATICFILES_DIRS</span><br></pre></td></tr></table></figure><h3 id="STATIC-URL"><a class="header-anchor" href="#STATIC-URL">¶</a>STATIC_URL</h3><p><code>STATIC_URL</code> 是必须设置的，提供了静态文件访问的映射关系，如设置 <code>STATIC_URL='/static/'</code> 时（名字可以自定义，这个是访问所有的静态文件的根名），访问静态文件的路径就是 <code>127.0.0.1：8000/static/静态文件名</code>。在设置了该参数之后，Django实际上就有了访问静态文件的能力，所以说该参数是必须设置的。</p><p>在开发模式下（DEBUG设置为True），Django提供了静态文件代理的功能，会自动识别每个 app下静态文件（前提是，这些静态文件夹必须设置在每个app之下，且使用的名字必须是static，这是因为Django内部做了相应的处理，只有名字 <code>static</code> 才会被Django自带的静态文件代理服务器识别），提供访问。</p><p>设置app下的静态文件夹的时候，内部最好有一个用当前app名字命名的文件夹，并在该文件夹下放置相应的静态文件（这是因为不做区分，万一多个app之间有同名的静态文件，Django就会混淆），此时这些静态文件的访问地址就是： 127.0.0.1：8000/static/app命名的文件夹/相应的静态文件<br>例如，第三方插件xadmin这个app就是这样设计的：<br><img src="/2020/04/30/Django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/xadmin.png" alt="第三方插件xadmin图片"></p><p>此外，设置了该参数之后，在模板层通过引入 <code>{ % load staticfiles % }</code> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>标签，可以在模板中使用 <code>href=&quot;{ % static 'css/reset.css' % }&quot;</code><sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup> 构建静态资源路径的构建，这样当对 <code>STATIC_URL</code> 指定的静态文件的根名方法改变的时候，不需要修改模板中的访问路径，依然能够访问，效果和<code>{ % url '' % }</code><sup class="footnote-ref"><a href="#fn1" id="fnref1:2">[1:2]</a></sup>类似。</p><h3 id="STATICFILES-DIRS"><a class="header-anchor" href="#STATICFILES-DIRS">¶</a>STATICFILES_DIRS</h3><p>只在开发模式下有效，对于一些公共的静态文件，或者在项目中自建app的时候不想为每个app单独设置静态文件夹，为了方便管理，可以单独在项目的根目录下设置一个文件夹统一管理所有的静态文件（但是这个文件夹无法被开发模式下Django自带的静态文件代理服务定位到，所以必须使用STATICFILES_DIRS进行设置），设置如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局静态文件访问配置</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'集中管理的文件名'</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 也可以设置多个静态文件夹</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>),</span><br><span class="line">    os.path.join(BASE_DIR,  <span class="string">'xxx/static'</span>)  <span class="comment"># 可以设置多个静态文件查找路径</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样在项目根目录下创建 <code>集中管理的文件名</code>文件，在里面放置静态文件，此时静态文件的访问地址是 <code>127.0.0.1：8000/static/集中管理的文件名中的静态文件</code> 。</p><blockquote><p>STATICFILES_DIRS 的设置只是提供给开发模式下的Django自带静态文件代理服务定位静态文件用的。</p></blockquote><h3 id="STATIC-ROOT"><a class="header-anchor" href="#STATIC-ROOT">¶</a>STATIC_ROOT</h3><p>在Django项目部署上线的时候，DEBUG需要设置为False，Django 不再提供静态文件代理功能，app自带的静态文件夹分布在各app下无法访问到，此时需使用 <code>pyhton manage.py collectstatic</code> 收集所有的静态文件，STATIC_ROOT就是用来设置所有的静态文件的聚合目录，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">'static'</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>python manage.py collectstatic</code> 之后，django会把所有的static文件都复制到STATIC_ROOT文件夹下。</p><h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3><ol><li>无论是开发模式还是生产环境下，Django项目都依赖STATIC_URL=’/static/'的设置，因为这提供了静态文件访问的映射关系，有了他，Django才能够访问静态文件。</li><li>STATICFILES_DIRS用于指定在项目根目录下统一管理的静态文件夹的名字，但只是在开发过程中有效以及使用，生产环境下，所有的静态文件都将被收集到统一的目录下（包括 STATICFILES_DIRS 的），交给第三方静态服务器调度提供。</li><li>若存在app下的static和STATICFILES_DIRS设置中同名的文件，默认访问的是STATICFILES_DIRS设置的静态文件下的，所以在app下的static中再设置一个app名的文件夹对静态文件管理，这样在访问时加上app名127.0.0.1：8000/static/app名，这样可以有效避免一些重名问题。</li><li>关于static目录的位置设置使用建议，若website中的每个app的独立性非常强的话，就在每个单独的app下设置static目录，这样app就会支持热插拔，独立性强。若app的独立性不强，app之间相互联系的话，建议使用集中管理static的方法。但是无论使用哪种方式，在项目部署的时候，都会进行静态文件的收集，由第三方静态服务器管理。</li></ol><h2 id="media文件"><a class="header-anchor" href="#media文件">¶</a>media文件</h2><p>设置和static类似，因为在开发模式下（DEBUG需要设置为True），Django并不提供media文件的代理服务，所以即使在开发模式下，也需要手动设置medai文件的代理。</p><h3 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h3><p>需要同时设置MEDIA_URL和MEDIA_ROOT</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># media文件的路径</span></span><br><span class="line">MEDIA_URL = <span class="string">"/media/"</span> <span class="comment"># 可以改名</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'media'</span>)  <span class="comment"># media为放置 media文件的文件夹名</span></span><br></pre></td></tr></table></figure><p>解释：<br>设置<code>MEDIA_ROOT</code>后，Django做了一定的处理，能够使上传的文件传到<code>MEDIA_ROOT</code>指定的文件中，如models.py中指定的模型有些有 <code>upload_to=&quot;org/%Y/%m&quot;</code>，这样指定后，就会在media中创建 <code>org/年/月</code> 的文件夹存储文件。此时仅仅设置 <code>MEDIA_ROOT</code> 参数，就可以完成上传时自动放到设置的media目录下。但是此时的图片访问地址是当前所在页面的地址，加上存储的地址，为<code>当前所在地址/org/%Y/%m/图片</code>。</p><p>若想访问到meida中的地址，还需要设置<code>MEDIA_URL=&quot;/media/&quot; </code>，设置之后访问media的路径就变成了<code>127.0.0.1：8000/media/org/%Y/%m/图片</code>。但是目前通过这个地址还是访问不了media（这点和static不同），Django没有对media的访问做处理，还需要我们手动对url的访问处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目urls.py中设置url</span></span><br><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve  <span class="comment"># 静态文件处理的view，该方法接受path参数</span></span><br><span class="line"><span class="comment"># 配置上传文件的访问url</span></span><br><span class="line">url(<span class="string">r'^media/(?P&lt;path&gt;.*)$'</span>, serve, &#123;<span class="string">"document_root"</span>: MEDIA_ROOT&#125;),</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">(request, path, document_root=None, show_indexes=False)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这个方法serve是一个专门用于处理静态文件的view，这里的用法就和我们定义一个view视图处理url请求一样，&lt;path&gt;中设置的参数path会传递给view处理函数，也就是这里的serve函数，</span></span><br><span class="line"><span class="string">&#123;"document_root": MEDIA_ROOT&#125;这叫额外参数，为dict类型，额外参数只能被视图函数（这里的serve）读取</span></span><br><span class="line"><span class="string">通过serve参数可见，设置的path和document_root都是serve()的参数</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>此时就完成了media文件的访问。</p><h3 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h3><p>媒体文件都是通过models.py中模型通过设置 <code>upload_to</code> 字段将文件的路径存储在数据库中，文件存储在MEDIA_ROOT设置的路径之中，所以在使用的时候，数据库中只能读取到 <code>upload_to</code> 时的路径 <code>/org/年/月/文件名</code>，而这个路径是不完整的，想要访问到文件还需要添加MEDIA_URL设置的前缀。<br>在模板层中想要获得MEDIA_URL设置的前缀可以view视图进行传递，然后在模板层中使用 <code>data-url=&quot;{ { MEDIA_URL } } { { org.image } }&quot;</code><sup class="footnote-ref"><a href="#fn1" id="fnref1:3">[1:3]</a></sup>，但是这样写的话，意味着要在每个views中传递MEDIA_URL参数，这是非常不好的。可以使用类似注入的方式，将MEDIA_URL注入到模板中，使其可以在模板中直接被调用。<br>Django自带了一些注入，如在模板中，直接可以使用<code>{ % if request.user.is_authenticated % }</code><sup class="footnote-ref"><a href="#fn1" id="fnref1:4">[1:4]</a></sup>调用request.user设置直接使用user进行操作，这是因为在settings.py中的进行了如下的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)]  <span class="comment"># 该项目一定要配置</span></span><br><span class="line">        ,</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,  <span class="comment"># 注册了该条语句，能够使用request</span></span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,  <span class="comment"># 能够直接使用user， 返回的也是request.user</span></span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return context variables required by apps that use Django's authentication</span></span><br><span class="line"><span class="string">    system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If there is no 'user' attribute in the request, use AnonymousUser (from</span></span><br><span class="line"><span class="string">    django.contrib.auth).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(request, <span class="string">'user'</span>):</span><br><span class="line">        user = request.user </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AnonymousUser</span><br><span class="line">        user = AnonymousUser()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'user'</span>: user,</span><br><span class="line">        <span class="string">'perms'</span>: PermWrapper(user),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>django中已经提供好了<code>django.template.context_processors.media</code>只要添进去即可<br>我们看一下这个函数media的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">media</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="string">'MEDIA_URL'</span>: settings.MEDIA_URL&#125;</span><br></pre></td></tr></table></figure><p>逻辑相当简单，这样我们也可以模仿使用类似的方式定义我们自己的context_processors<br>之后再模板中使用图片的方式为：src=&quot;{ { MEDIA_URL } }{ { hot_course.image } }&quot;<sup class="footnote-ref"><a href="#fn1" id="fnref1:5">[1:5]</a></sup></p><p>若不不使用模板层的<code>context_processors</code>注入方法，还可以使用image model（models.ImageField）的自带属性方法url，他会自动拼接形成一个可以方法的url，如src=&quot;{ { hot_course.image.url } }&quot;<sup class="footnote-ref"><a href="#fn1" id="fnref1:6">[1:6]</a></sup>。实际使用中也推荐使用该种方法，因为不需要做额外的操作，直接调用图片属性的url，即可自动拼接成图片相应的访问地址。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Django模版语法中，此处的两个中括号之间以及中括号和百分号之间是没有空格的，由于hexo的限制，写在一起无法显示，故作此说明。 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a> <a href="#fnref1:2" class="footnote-backref">↩︎</a> <a href="#fnref1:3" class="footnote-backref">↩︎</a> <a href="#fnref1:4" class="footnote-backref">↩︎</a> <a href="#fnref1:5" class="footnote-backref">↩︎</a> <a href="#fnref1:6" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 开发问题 </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django静态资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云部署Django项目</title>
      <link href="2020/04/20/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2Django%E9%A1%B9%E7%9B%AE/"/>
      <url>2020/04/20/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2Django%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>使用 Nginx + uWSGI 部署，Nginx完成端口的转发，uWSGI负责启动 Django</p><h2 id="Nginx、WSGI、uwsgi、uWSGI、django这几个关系"><a class="header-anchor" href="#Nginx、WSGI、uwsgi、uWSGI、django这几个关系">¶</a>Nginx、WSGI、uwsgi、uWSGI、django这几个关系</h2><p>WSGI，全称 Web Server Gateway Interface，或者 Python Web Server Gateway Interface ，是为 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。描述的是Web服务器如何与Web应用间进行通信。它不是服务器、python模块、框架、API或者任何软件，只是一种描述web服务器（如nginx，uWSGI等服务器）如何与web应用程序（如用Django、Flask框架写的程序）通信的规范。</p><p>uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，用于与nginx等代理服务器通信，它与WSGI相比是两样东西。</p><p>uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。</p><blockquote><p>为什么有了uWSGI为什么还需要nginx？因为nginx具备优秀的静态内容处理能力，然后将动态内容转发给uWSGI服务器，这样可以达到很好的客户端响应。</p></blockquote><h3 id="完整的访问过程"><a class="header-anchor" href="#完整的访问过程">¶</a>完整的访问过程</h3><ol><li>Nginx接收到浏览器的http请求，将包进行解析，分析url，如果是静态文件直接访问用户给Nginx配置静态文件目录，如果不是静态文件，是一个动态请求，Nginx会转发给uWSGI。</li><li>uWSGI接到请求会进行处理成WSGI可以接受的形式，并发给WSGI。</li><li>WSGI根据请求调用应用程序的某个文件，某个文件的某个函数处理完会返回给WSGI，WSGI将返回值进行打包，打包成uWSGI能够接受的格式，uWSGI接受WSGI的发送请求，转发给Nginx，Nginx最终将返回值返回给浏览器。</li></ol><h3 id="为什么不用uWSGI作为唯一服务器"><a class="header-anchor" href="#为什么不用uWSGI作为唯一服务器">¶</a>为什么不用uWSGI作为唯一服务器</h3><p>1.安全问题，程序不能直接被浏览器访问到，而是通过nginx,nginx只开放某个接口，uwsgi本身是内网接口，这样运维人员在nginx上加上安全性的限制，可以达到保护程序的作用。</p><p>2.负载均衡问题，一个uwsgi很可能不够用，即使开了多个work也是不行，毕竟一台机器的cpu和内存都是有限的，有了nginx做代理，一个nginx可以代理多台uwsgi完成uwsgi的负载均衡。</p><p>3.静态文件问题，用django或是uwsgi这种东西来负责静态文件的处理是很浪费的行为，而且他们本身对文件的处理也不如nginx好，所以整个静态文件的处理都直接由nginx完成，静态文件的访问完全不去经过uwsgi以及其后面的东西。</p><h2 id="工具安装（以CentOS7为例）"><a class="header-anchor" href="#工具安装（以CentOS7为例）">¶</a>工具安装（以CentOS7为例）</h2><h3 id="mysql"><a class="header-anchor" href="#mysql">¶</a>mysql</h3><p>安装完成之后，需要使用进行如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在/etc/my.cnf中需要设置</span><br><span class="line">在 [mysqld]:</span><br><span class="line">下面加一行</span><br><span class="line">bind-address = 0.0.0.0</span><br></pre></td></tr></table></figure><p>数据库的迁移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将本地的数据库(music_db)导出为sql文件(music_db.sql)</span></span><br><span class="line">mysqldump -uroot -p db_name &gt; db_name.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用scp命令将sql文件发送到服务器</span></span><br><span class="line">scp music_db.sql  远程登录账号@服务器ip:服务器目录/db_name.sql </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在服务器上登录mysql</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在服务器的mysql中新建同名数据库(music_db),然后退出mysql</span></span><br><span class="line">create database new_db_name charset=utf8;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">exit;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将通过scp命令传输过来的db_name.sql文件导入到,刚刚建立的同名数据库中</span></span><br><span class="line">mysql -uroot -p new_db_name &lt; db_name.sql</span><br></pre></td></tr></table></figure><h3 id="nginx"><a class="header-anchor" href="#nginx">¶</a>nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure><h3 id="python环境"><a class="header-anchor" href="#python环境">¶</a>python环境</h3><h3 id="uWSGI"><a class="header-anchor" href="#uWSGI">¶</a>uWSGI</h3><p>使用 <code>pip install uwsgi</code> 安装<br>在项目的根目录下，通过 <code>uwsgi --http :8001 --module 项目名.uwsgi</code> 运行项目，以http的方式，让uwsgi启动我们的项目。</p><blockquote><p>注意：端口需要在服务器的 安全策略组 中进行了开放</p></blockquote><p>当输出以下内容时，说明项目启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI worker 1 (and the only) (pid: 24712, cores: 1)</span><br></pre></td></tr></table></figure><h2 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2><p>在Django项目根目录下创建conf文件夹，文件夹下创建uwsgi文件夹和nginx文件夹，分别用于存储uwsgi和nginx的配置文件。</p><h3 id="nginx-v2"><a class="header-anchor" href="#nginx-v2">¶</a>nginx</h3><p>配置nginx文件，后缀名为 .conf，如myproject_nginx.conf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the upstream component nginx needs to connect to</span></span><br><span class="line">upstream django &#123;</span><br><span class="line">  <span class="comment"># server unix:///path/to/your/mysite/mysite.sock; # for a file socket</span></span><br><span class="line">  server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8001</span>; <span class="comment"># for a web port socket (we'll use this first)</span></span><br><span class="line">  <span class="comment"># 设置启动Django的端口，可以任意命名合法的端口号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># configuration of the server</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  <span class="comment"># the port your site will be served on</span></span><br><span class="line">  listen      <span class="number">80</span>;</span><br><span class="line">  <span class="comment"># the domain name it will serve for</span></span><br><span class="line">  server_name 云服务器公网IP或者域名 ; <span class="comment"># substitute your machine's IP address or FQDN</span></span><br><span class="line">  <span class="comment"># 配置服务器的IP地址</span></span><br><span class="line">  charset     utf<span class="number">-8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># max upload size</span></span><br><span class="line">  client_max_body_size <span class="number">75</span>M;   <span class="comment"># adjust to taste</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Django media</span></span><br><span class="line">  <span class="comment"># 配置使用nginx来代理静态文件，而不使用Django自带的代理，得益与nginx底层的io多路复用，nginx的性能高</span></span><br><span class="line">  location /media  &#123;</span><br><span class="line">    alias /root/projects/MxShop/media;  <span class="comment"># 指向django的media目录</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /static &#123;</span><br><span class="line">    alias /root/projects/MxShop/static; <span class="comment"># 指向django的static目录</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Finally, send all non-media requests to the Django server.</span></span><br><span class="line">  location / &#123;</span><br><span class="line">    uwsgi_pass  django;</span><br><span class="line">    include     uwsgi_params; <span class="comment"># the uwsgi_params file you installed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用nginx之后，项目中的静态文件就交给nginx代理了，而不使用Django自带的代理，得益与nginx底层的io多路复用，nginx的性能高。</p><blockquote><p>注意区分：listen监听的这个端口是外部浏览器访问nginx的端口，而uwsgi_pass这个端口是nginx访问uwsgi的端口，所以设置需要和uwsgi.ini配置文件中的socket指定的路径一致。</p></blockquote><h3 id="uwsgi配置"><a class="header-anchor" href="#uwsgi配置">¶</a>uwsgi配置</h3><p>配置uwsgi文件，后缀名为 .ini，如uwsgi.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysite_uwsgi.ini file</span></span><br><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Django-related settings</span></span><br><span class="line"><span class="comment"># the base directory (full path)  项目的地址</span></span><br><span class="line"><span class="attr">chdir</span>           = /root/MyProject</span><br><span class="line"><span class="comment"># Django's wsgi file 项目中的wsgi.py文件的位置，相对chdir的设置</span></span><br><span class="line"><span class="attr">module</span>          = MyProject.wsgi </span><br><span class="line"><span class="comment"># the virtualenv (full path)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># process-related settings</span></span><br><span class="line"><span class="comment"># master</span></span><br><span class="line"><span class="attr">master</span>          = <span class="literal">true</span></span><br><span class="line"><span class="comment"># maximum number of worker processes</span></span><br><span class="line"><span class="attr">processes</span>       = <span class="number">10</span></span><br><span class="line"><span class="comment"># the socket (use the full path to be safe )</span></span><br><span class="line"><span class="attr">socket</span>          = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8001</span> <span class="comment"># 和nginx中的server配置相对应                   </span></span><br><span class="line"><span class="comment"># ... with appropriate permissions - may be needed</span></span><br><span class="line"><span class="comment"># chmod-socket    = 664</span></span><br><span class="line"><span class="comment"># clear environment on exit</span></span><br><span class="line"><span class="attr">vacuum</span>          = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 虚拟环境的路径 ，当前的python环境文件</span></span><br><span class="line"><span class="attr">virtualenv</span> = /root/.virtualenvs/myproject     </span><br><span class="line"></span><br><span class="line"><span class="attr">pidfile</span>= uwsgi.pid  <span class="comment"># 生成包含当前uwsgi主进程的文件，用户管理uwsgi服务</span></span><br><span class="line"><span class="comment"># logto = /tmp/mylog.log  # 日志文件的存储地址</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：以上的配置启动后，配合nginx的设置进行使用，直接通过url无法访问。</p></blockquote><h4 id="参数解释"><a class="header-anchor" href="#参数解释">¶</a>参数解释</h4><ul><li>socket：socket文件，也可以是地址+端口，用于与某些第三方路由器（例如nginx）一起使用的http选项，如果直接通过http直接访问uWSGI，需要使用http；</li><li>master：是否启动主进程来管理其他进程；</li><li>chdir：项目的根目录；</li><li>module：wsgi文件相对路径；</li><li>vacuum：服务结束后时候删除对应的socket和pid文件；</li><li>pidfile：指定pid文件，设置该属性之后，uWSGI通过xxx.ini启动后会在相同目录下生成一个xxx.pid的文件，里面只有一行内容是uWSGI的主进程的进程号。</li></ul><h4 id="基本命令"><a class="header-anchor" href="#基本命令">¶</a>基本命令</h4><p>启动<br><code>uwsgi --ini xxx.ini</code><br>重启<br><code>uwsgi --reload xxx.pid</code> 需要设置pidfile属性<br>停止<br><code>uwsgi --stop xxx.pid</code> 需要设置pidfile属性<br><code>kill -9 uwsgi</code> 此方法会杀死所有的uWSGI服务，在启动了多个uWSGI服务时，谨慎使用</p><h2 id="启动Django项目"><a class="header-anchor" href="#启动Django项目">¶</a>启动Django项目</h2><p>先启动uWSGI，之后再启动Nginx</p><h3 id="启动uWSGI"><a class="header-anchor" href="#启动uWSGI">¶</a>启动uWSGI</h3><p>进入虚拟环境，进入uwsgi配置文件所在的目录，通过 <code>uwsgi --ini uwsgi.ini</code> 命令，使用uwsgi启动Django项目，出现以下输出，表示启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">uWSGI running as root, you can use --uid/--gid/--chroot options</span><br><span class="line">*** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** </span><br><span class="line">spawned uWSGI master process (pid: 25690)</span><br><span class="line">spawned uWSGI worker 1 (pid: 25693, cores: 1)</span><br><span class="line">spawned uWSGI worker 2 (pid: 25694, cores: 1)</span><br><span class="line">spawned uWSGI worker 3 (pid: 25695, cores: 1)</span><br><span class="line">spawned uWSGI worker 4 (pid: 25696, cores: 1)</span><br><span class="line">spawned uWSGI worker 5 (pid: 25697, cores: 1)</span><br><span class="line">spawned uWSGI worker 6 (pid: 25698, cores: 1)</span><br><span class="line">spawned uWSGI worker 7 (pid: 25699, cores: 1)</span><br><span class="line">spawned uWSGI worker 8 (pid: 25700, cores: 1)</span><br><span class="line">spawned uWSGI worker 9 (pid: 25701, cores: 1)</span><br><span class="line">spawned uWSGI worker 10 (pid: 25702, cores: 1)</span><br></pre></td></tr></table></figure><h3 id="启动Nginx"><a class="header-anchor" href="#启动Nginx">¶</a>启动Nginx</h3><p>通过以下命令，将nginx的配置文件放置到 <code>/etc/nginx/conf.d/</code> 目录下<br>sudo ln -s 你的目录/Mxonline/conf/nginx/uc_nginx.conf /etc/nginx/conf.d/</p><ul><li>conf.d 文件夹下可以放置多个启动配置文件，每个项目对应一个。</li><li>推荐使用软连接的方式，在conf.d目录下创建配置文件的软链接，这样在项目中修改，会直接同步到配置文件中，比较方便。</li></ul><blockquote><p>最好修改一下 /etc/nginx/nginx.conf中的权限配置，将第一行的user nginx;修改为user root;这样可以避免在后期nginx访问某些文件的时候出现权限问题，当然也可以选择给需要访问的文件给nginx权限。</p></blockquote><p>一切配置完成之后，通过 <code>sudo systemctl start nginx</code> 即可启动nginx服务，此时没有异常则为启动正常（可以通过 <code>sudo systemctl status nginx</code> 查看nginx服务的状态），之后即可用浏览器访问 <code>http://nginx配置文件中server_name指定的地址</code> 。</p><h2 id="后续问题"><a class="header-anchor" href="#后续问题">¶</a>后续问题</h2><h3 id="静态文件的访问"><a class="header-anchor" href="#静态文件的访问">¶</a>静态文件的访问</h3><p>Django中的静态文件访问设置需要分两种情况进行讨论（更加settings.py中DEBUG配置的状态分），即 开发测试场景下 和 生产环境中。</p><h4 id="开发测试场景下"><a class="header-anchor" href="#开发测试场景下">¶</a>开发测试场景下</h4><p>DEBUG设置为True。<br>此场景下Django自带的服务器提供静态文件的代理服务，此时只需要设置 <code>STATIC_URL</code> 以及 <code>STATICFILES_DIRS</code> 即可完成静态文件的访问，并且此时Django自带的服务器提供静态文件的代理服务还会自动代理项目中使用的外部app自带的静态文件（且不需要额外的设置）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line"><span class="comment"># 全局静态文件配置，开发模式下用于一些公共静态文件的路径提供，因为不是在app下单独设置，开发模式下Django自带的静态文件代理无法定位到这些文件，需要使用STATICFILES_DIRS进行设置。</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>),  <span class="comment"># 指向项目下的static文件夹</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>注意：STATICFILES_DIRS 和 STATIC_ROOT 的配置不能相同，否则提示 <code>(staticfiles.E002) The STATICFILES_DIRS setting should not contain the STATIC_ROOT setting.</code>。一般情况下，在生产环境中所有的静态资源都会收集到一起放到统一的文件夹下，交由第三方服务代理，此时STATICFILES_DIRS也就不需要使用了。</p></blockquote><h4 id="生产环境下"><a class="header-anchor" href="#生产环境下">¶</a>生产环境下</h4><p>DEBUG设置为False（此时注意：必须设置ALLOWED_HOSTS参数，用于设置允许访问当前网站的ip地址）<br>在Django部署上线之后，为了不对外暴露内部程序细节（测试开发过程中，DEBUG设置为True，异常会显示在浏览器），此时需要设置DEBUG为False，而一旦这样设置之后，Django将不再提供静态服务代理的功能，需要手动配置来完成。配置过程和media的配置相同（因为Django是不提供media文件的代理服务的，所以即使在开发阶段也是需要手动配置的）。<br>手动实现静态文件代理的方式有以下几种：</p><ol><li>通过配置url进行访问（Django只推荐在开发过程中使用，生产环境下最好使用第2种）<br>配置的过程和media的配置过程一样，配置内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py中的配置</span></span><br><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">'static'</span>)  <span class="comment"># 指向项目下的static文件夹</span></span><br><span class="line"><span class="comment"># media文件的路径</span></span><br><span class="line">MEDIA_URL = <span class="string">"/media/"</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'media'</span>)  <span class="comment"># 指向项目下的media文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py中的路由设置</span></span><br><span class="line"><span class="keyword">from</span> MyProject.settings <span class="keyword">import</span> STATIC_ROOT</span><br><span class="line"><span class="keyword">from</span> MyProject.settings <span class="keyword">import</span> STATIC_ROOT</span><br><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve  <span class="comment"># 用于提供静态文件的视图和功能。这些仅在开发过程中使用，不应在生产环境中使用。</span></span><br><span class="line"></span><br><span class="line">url(<span class="string">r'^media/(?P&lt;path&gt;.*)$'</span>, serve, &#123;<span class="string">"document_root"</span>: MEDIA_ROOT&#125;),</span><br><span class="line">url(<span class="string">r'^static/(?P&lt;path&gt;.*)$'</span>, serve, &#123;<span class="string">"document_root"</span>: STATIC_ROOT&#125;),</span><br></pre></td></tr></table></figure></li><li>通过第三方服务器，如使用Nginx来提供静态文件的代理服务（Nginx拥有更高的静态资源处理性能）<br>此时配置文件中只需要提供 <code>STATIC_URL</code> 和 <code>MEDIA_URL</code> 两个配置，如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">MEDIA_URL = <span class="string">'/media/'</span></span><br></pre></td></tr></table></figure>之后，Django所有静态资源的访问都将被转到Nginx，由Nginx提供。</li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx下的静态文件代理配置</span></span><br><span class="line">location /media  &#123;</span><br><span class="line">  alias /root/projects/MxShop/media;  <span class="comment"># 指向django项目下的media文件夹</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /static &#123;</span><br><span class="line">  alias /root/projects/MxShop/static; <span class="comment"># 指向django项目下的static文件夹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上两种方式既可以完成静态文件的访问了，但是可能某些静态文件依然无法访问，这是因为在开发的时候，除了手动设置的用到的静态文件之外，还有一些安装的app也需要使用到一些静态文件，而这些静态文件一般是app自带的，安装在这些app目录下的static文件夹中，在开发环境下（DEBUG设置为True），Django会自动找到这些app的静态文件并提供相应的静态文件代理，生产环境下由于Django不再提供静态文件代理，我们所有的静态文件的访问路由都指向了项目更目录下的总的静态文件夹下，所以这些app自带的静态文件就无法访问（<strong>这也是Django在开发模式下提供自带的静态文件代理服务的原因以及优点</strong>），好在django为我们提供了静态文件的收集方案，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 只需要在当前项目的根目录下，使用 python manage.py collectstatic 命令即可完成所有静态文件的收集</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，该条指令依赖STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">'static'</span>)的设置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python manage.py collectstatic</span></span><br><span class="line"></span><br><span class="line">You have requested to collect static files at the destination</span><br><span class="line">location as specified in your settings:</span><br><span class="line"></span><br><span class="line">    /root/projects/MyProject/static</span><br><span class="line"></span><br><span class="line">This will overwrite existing files!</span><br><span class="line">Are you sure you want to do this?</span><br><span class="line"></span><br><span class="line">Type 'yes' to continue, or 'no' to cancel: yes</span><br><span class="line"></span><br><span class="line">646 static files copied to '/root/projects/MyProject/static'.</span><br></pre></td></tr></table></figure><p>收集完成之后，所有的静态文件都可以正常访问了。</p><p><code>STATIC_ROOT = os.path.join(BASE_DIR, 'static')</code>的作用有两个：</p><ol><li>用于使用 <code>python manage.py collectstatic</code> 命令完成所有静态文件的收集</li><li>用于在 DEBUG 设置为 False（说明此时是生产模式下，不打印异常栈）时，想由django实现静态文件的访问路由 <code>url(r'^static/(?P&lt;path&gt;.*)$', serve, {&quot;document_root&quot;: STATIC_ROOT})</code></li></ol><h3 id="异常"><a class="header-anchor" href="#异常">¶</a>异常</h3><h4 id="Server-Error-500"><a class="header-anchor" href="#Server-Error-500">¶</a>Server Error (500)</h4><p>出现这种错误，一般是服务器内部，也就是代码出现错误，此时需要设置 <code>DEBUG = True</code>，开启调试模式，打印异常栈才能发现错误的地方。<br>像我就因为项目中使用了redis服务，但是因为 DEBUG 设置为 False，所以不知道错误在什么地方。</p><h4 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h4><ul><li>部署上线时，一定要设置DEBUG设置为False，防止错误栈对外输出，造成安全隐患。</li><li>Django开发模式下提供的静态文件代理服务为我们的开发提供了便利，不用考虑安装的额外app的静态文件的访问问题。</li><li>DEBUG设置为False后，Django不再提供静态文件代理，需要手动配置。</li><li>media文件不管在什么环境都需要手动设置，因为Django不提供高media文件的代理服务。</li><li>Ngingx拥有更高的静态资源处理性能，应该使用这种方式完成静态资源的获取。</li><li>一定要使用collectstatic完成所有静态资源的收集，保证所有静态文件的正常访问。此外，collectstatic命令的实现离不开STATIC_ROOT的设置。</li></ul><h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2><p>uWSGI 文档：<a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/WSGIquickstart.html" target="_blank" rel="noopener">https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/WSGIquickstart.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 开发问题 </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django部署 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django REST framework之JWT用户验证</title>
      <link href="2020/04/03/Django%20REST%20framework%E4%B9%8BJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/"/>
      <url>2020/04/03/Django%20REST%20framework%E4%B9%8BJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>在之前的 <a href="/2020/03/24/Django-REST-framework%E7%9A%84token%E7%99%BB%E9%99%86%E5%92%8C%E5%8E%9F%E7%90%86/" title="Django REST framework的token原理和验证登录">Django REST framework的token原理和验证登录</a> 中，使用了drf自带的Token认证类<code>rest_framework.authentication.TokenAuthentication</code> 实现了Token认证，但是drf自带的Token认证有以下几个问题：</p><ol><li>drf自带的token验证方式，token值是存储在生成的 <code>authtoken_token</code> 表中，是放在一台服务器上的，若采用分布式的话，还需要做数据的同步操作。</li><li>相比于 django_session 的设置，没有expire_date属性（过期时间），将是永久有效的，这样的话，一旦泄露将造成很大的安全问题。</li><li>和django_session存储同样的问题，随着用户的增多，token值会占用服务器大量空间，同时也会加大数据库的查询压力，导致性能下降。</li></ol><p>为了解决以上的问题，将使用第三方的开源库<a href="https://github.com/jpadilla/django-rest-framework-jwt" target="_blank" rel="noopener">djangorestframework-jwt</a>完成这一功能。</p><h2 id="JWT原理"><a class="header-anchor" href="#JWT原理">¶</a>JWT原理</h2><p>参考文章：<a href="https://lion1ou.win/2017/01/18/" target="_blank" rel="noopener">前后端分离之JWT用户认证</a></p><h3 id="摘要"><a class="header-anchor" href="#摘要">¶</a>摘要</h3><ol><li>HTTP协议的无状态存储，需要提供用户登录的验证功能。</li><li>前后端分离系统的传统解决方式是：前端登录，后端根据用户信息生成一个<code>token</code>，并保存这个 <code>token</code> 和对应的用户id到数据库或Session中，接着把 <code>token</code> 传给用户，存入浏览器 cookie，之后浏览器请求带上这个cookie，后端根据这个cookie值来查询用户，验证是否过期。</li></ol><p>JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p><ul><li>简洁(Compact)<br>可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快</li><li>自包含(Self-contained)<br>负载中包含了所有用户所需要的信息，避免了多次查询数据库</li></ul><h3 id="组成"><a class="header-anchor" href="#组成">¶</a>组成</h3><p>JWT由三部分组成</p><ul><li>HEAD 头部： 包含了两部分，token 类型和采用的加密算法</li><li>Payload 负载： 我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。<font color="red">默认情况下负载中的内容使用的是 base64 编码方式，是可逆的，所以任何人都可以解读该部分的内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露</font>。</li><li>Signature 签名： 保证内容没有被篡改。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥（存放在服务端），然后使用 header 中指定的签名算法（HS256）进行签名。生成的方式：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python实现 </span></span><br><span class="line">HMACSHA256(base64UrlEncode(header) + <span class="string">"."</span> + base64UrlEncode(payload), secret)  <span class="comment"># secret密钥保存在服务器端，且不对外公布</span></span><br></pre></td></tr></table></figure><p>完整的JWT构成：<code>base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload) + &quot;.&quot; + Signature 签名</code></p><h3 id="验证过程"><a class="header-anchor" href="#验证过程">¶</a>验证过程</h3><p>由前端和后端共同完成<br><img src="/2020/04/03/Django%20REST%20framework%E4%B9%8BJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/jwt.jpg" alt="jwt认证过程"></p><ul><li>前端进行登录，提供账号和密码在后端进行验证，后端对其验证通过后生成JWT，再发送给前端，前端保存在本地（一般是存储在本地的cookie中（推荐使用该种方式，只是使用cookie的存储机制），或者是保存在localStorage或sessionStorage上，退出登录时由前端删除保存的JWT即可）</li><li>前端在跳转到登录页或者请求API的时候，会发送JWT，到达后端时被过滤器拦截进行JWT的验证（在Django可以交给中间件完成），验证通过之后请求被传送给view，未通过，返回错误信息（可以交给Django中间件中的process_exception函数处理），跳转到登录页面。（前面的所有的Django中间件的功能都将由即将使用到的 <code>rest_framework_jwt.authentication.JSONWebTokenAuthentication</code> 来完成）</li></ul><h3 id="JWT的优势"><a class="header-anchor" href="#JWT的优势">¶</a>JWT的优势</h3><ul><li>完全使用算法进行验证，加密解密取得用户ID（相较于sessionid，后者还多了向服务器请求对应session_data的步骤），通过用户ID查询到用户信息，这意味着不需要存储token表，也不需要Django之中的session表，会减少服务器的存储压力</li><li>适用于<a href="https://www.jianshu.com/p/75edcc05acfd" target="_blank" rel="noopener">单点登录</a></li></ul><p>JWT详细解读：<a href="https://www.cnblogs.com/DeadBoy/p/11481146.html" target="_blank" rel="noopener">https://www.cnblogs.com/DeadBoy/p/11481146.html</a></p><h2 id="Django-REST-framework实现JWT的验证登录功能"><a class="header-anchor" href="#Django-REST-framework实现JWT的验证登录功能">¶</a>Django REST framework实现JWT的验证登录功能</h2><p>使用第三方库<code>djangorestframework-jwt</code>完成验证，使用方法详见<a href="https://jpadilla.github.io/django-rest-framework-jwt/" target="_blank" rel="noopener">官方文档</a></p><h3 id="安装后的配置过程"><a class="header-anchor" href="#安装后的配置过程">¶</a>安装后的配置过程</h3><ol><li>安装完成后，首先需要在REST_FRAMEWORK的<code>DEFAULT_AUTHENTICATION_CLASSES</code> 中配置</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [</span><br><span class="line">        ...</span><br><span class="line">        <span class="string">'rest_framework_jwt.authentication.JSONWebTokenAuthentication'</span>,</span><br><span class="line">    ], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和drf自带的token功能使用的<code>rest_framework.authentication.TokenAuthentication</code>作用一致，是对用户post过来的token进行验证，验证完成后返回user。该设置只有在需要用户访问view，发送token进行验证的时候才需要设置，单纯的提供token值是不需要设置的（只需要完成步骤2）。<br>另外，这个值，最好不要在settings.py中进行设置，而只在需要使用的view中进行设置，因为有些页面属于公共资源，不需要验证token也可以进行访问。通过设置<code>authentication_classes</code>参数进行配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line">authentication_classes = (JSONWebTokenAuthentication,)</span><br></pre></td></tr></table></figure><ol start="2"><li>在urls.py中添加url</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework_jwt.views <span class="keyword">import</span> obtain_jwt_token</span><br><span class="line"></span><br><span class="line">url(<span class="string">r'^api-token-auth/'</span>, obtain_jwt_token) <span class="comment"># jwt的认证接口，是一个post请求。可以自定义url地址，如jwt-auth</span></span><br><span class="line"><span class="comment"># 这里注意区分url(r'^api-token-auth/', views.obtain_auth_token)，这是drf自带的认证模式</span></span><br><span class="line"><span class="comment"># 自定义的jwt接口</span></span><br><span class="line">url(<span class="string">r'^jwt-auth/'</span>, obtain_jwt_token)</span><br></pre></td></tr></table></figure><p>此时访问<code>http://xxx/jwt-auth</code>，使用post请求传递用户信息（用户名和密码），验证通过之后就会直接返回一个jwt，采用的返回方式是k/v形式的json对象：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"token"</span>: <span class="string">"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNTg3NjMyODgzLCJlbWFpbCI6IjEyMzRAcXEuY29tIn0.YIcAYZC3aY0AsoCyRDR78-1D-zdIGN3jHZHqgBWtjxo"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传递的用于验证用户的信息（username和password）错误的时候，返回以下JSON数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"non_field_errors"</span>: [</span><br><span class="line">        <span class="string">"无法使用提供的认证信息登录。"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>验证方式（注意和drf自带的token验证方式的不同书写）<ul><li>在http Headers中通过 <code>Authorization: JWT &lt;your_token&gt;</code>格式传递获得的JWT</li><li>打断点，请求设置了 <code>authentication_classes = (JSONWebTokenAuthentication,)</code> 的view，查看request属性，可以发现用户存储在request中的user属性中，JWT值存储在auth属性中</li><li>JWT过期之后，返回的JSON格式数据</li></ul> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"non_field_errors"</span>: [</span><br><span class="line">        <span class="string">"无法使用提供的认证信息登录。"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="和前端vue登录功能的集成"><a class="header-anchor" href="#和前端vue登录功能的集成">¶</a>和前端vue登录功能的集成</h3><p>直接将<code>url(r'^api-token-auth/', obtain_jwt_token)</code>的url地址改为<code>url(r'^login/', obtain_jwt_token)</code>，变成登陆接口，前端向后端传递用户名和密码请求登陆，后端接受到请求后验证，验证通过返回JWT，前端保存，之后的每次请求，发送该JWT，验证用户，完成登录。<br>详细过程：<br>后端验证用户信息返回JWT：<br>url 请求的 view 是 rest_framework_jwt 中的 ObtainJSONWebToken，该 view 继承自 JSONWebTokenAPIView，使用的序列化类是 JSONWebTokenSerializer，该序列化类中通过重写 validate() 方法，进行用户的身份校验，验证通过后进行 token 的构建，并和用户名组合为字典存放到 <code>_validated_data</code> 参数中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码位于 rest_framework_jwt/serializers.py</span></span><br><span class="line"><span class="comment"># JSONWebTokenSerializer中的validate()方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, attrs)</span>:</span></span><br><span class="line">    credentials = &#123;</span><br><span class="line">        self.username_field: attrs.get(self.username_field),</span><br><span class="line">        <span class="string">'password'</span>: attrs.get(<span class="string">'password'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> all(credentials.values()):</span><br><span class="line">        <span class="comment"># 调用django的用户认证方法进行验证</span></span><br><span class="line">        user = authenticate(**credentials)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> user.is_active:</span><br><span class="line">                msg = _(<span class="string">'User account is disabled.'</span>)</span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(msg)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用户认证通过后进行token的构造，以下两个方法也是token构造的主要方法</span></span><br><span class="line">            payload = jwt_payload_handler(user)</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="comment"># 将token和用户对象存储到一起，通过validate()最终返回给 _validated_data</span></span><br><span class="line">                <span class="string">'token'</span>: jwt_encode_handler(payload),</span><br><span class="line">                <span class="string">'user'</span>: user</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = _(<span class="string">'Unable to log in with provided credentials.'</span>)</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(msg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg = _(<span class="string">'Must include "&#123;username_field&#125;" and "password".'</span>)</span><br><span class="line">        msg = msg.format(username_field=self.username_field)</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(msg)</span><br></pre></td></tr></table></figure><p>JSONWebTokenAPIView 中获取到生成的 token，通过可选的方式（通过判断 api_settings.JWT_AUTH_COOKIE 的值决定是否通过 cookie 的方式进行传递 token 值，默认是 None，也就是不通过 cookie 进行传递值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码位于 rest_framework_jwt/views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONWebTokenAPIView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 调用 JSONWebTokenSerializer 进行数据的序列化</span></span><br><span class="line">        serializer = self.get_serializer(data=request.data)   <span class="comment"># request为drf重写，内部通过data属性保存传递过来的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():  <span class="comment"># 进行验证（validata中进行了用户验证），验证通过之后，返回生成的token值和user属性</span></span><br><span class="line">            <span class="comment"># serializer.object属性为rest_framework_jwt设置的属性方法，之际返回的是self.validated_data，也就是_validated_data中的值</span></span><br><span class="line">            user = serializer.object.get(<span class="string">'user'</span>) <span class="keyword">or</span> request.user</span><br><span class="line">            token = serializer.object.get(<span class="string">'token'</span>)</span><br><span class="line">            <span class="comment"># jwt_response_payload_handler方法用于自定义响应的内容，默认的只是返回&#123;token:'token值'&#125; </span></span><br><span class="line">            response_data = jwt_response_payload_handler(token, user, request)</span><br><span class="line">            response = Response(response_data)  </span><br><span class="line">            <span class="comment"># 判断JWT_AUTH_COOKIE是否设置，默认为None,表示不使用cookie的方式，设置的时候为cookie中存储的名称</span></span><br><span class="line">            <span class="keyword">if</span> api_settings.JWT_AUTH_COOKIE:  </span><br><span class="line">                <span class="comment"># 设置过期时间，需要使用到api_settings.JWT_EXPIRATION_DELTA的配置，默认为300s</span></span><br><span class="line">                expiration = (datetime.utcnow() +</span><br><span class="line">                              api_settings.JWT_EXPIRATION_DELTA)  </span><br><span class="line">                <span class="comment"># 设置cookie, 使用WT_AUTH_COOKIE设置的名称，token,过期时间</span></span><br><span class="line">                response.set_cookie(api_settings.JWT_AUTH_COOKIE,</span><br><span class="line">                                    token,</span><br><span class="line">                                    expires=expiration,</span><br><span class="line">                                    httponly=<span class="literal">True</span>)  <span class="comment"># 如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性</span></span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure><p>vue前端获得返回的JWT：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.post(<span class="string">`<span class="subst">$&#123;host&#125;</span>/login/`</span>, params)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 登录调用的方法</span></span><br><span class="line">login(&#123;</span><br><span class="line">    <span class="comment">// vue传递 用户名和密码</span></span><br><span class="line">    username:<span class="keyword">this</span>.userName,  </span><br><span class="line">    password:<span class="keyword">this</span>.parseWord</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">response</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="comment">// 验证通过之后，本地存储返回的信息</span></span><br><span class="line">    <span class="comment">// 当前示例的返回的信息中由于使用的是djangorestframework_jwt默认的jwt_response_payload_handler(token, user, request)，该方法中只返回了token，所以name不通过后端获得，由前端获取</span></span><br><span class="line">    cookie.setCookie(<span class="string">'name'</span>,<span class="keyword">this</span>.userName,<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 设置token，同时设置过期时间，这是因为djangorestframework_jwt使用非cookie形式传递token时，没有传递过期时间值，此时需要设置cookie的过期时间，</span></span><br><span class="line">    <span class="comment">// 但是要注意，传递的token中在编码的时候，是有过期时间这个属性的，用于后端在接收到该token进行过期验证的，和这里的cookie的过期时间无关，token的构造参见 jwt_payload_handler(user) 的实现，由该方法定义。</span></span><br><span class="line">    <span class="comment">// 此处定义的cookie的过期时间是用在前端浏览器中设置cookie保存的时间，JWT也有单独设置的过期时间用于保证JWT的时效性，这是在生成token的时候就定义并存储好的，</span></span><br><span class="line">    <span class="comment">// 另外，此处cookie过期时间最好和JWT设置的过期时间保持一直，应小于等于JWT的值。</span></span><br><span class="line">    cookie.setCookie(<span class="string">'token'</span>,response.data.token,<span class="number">7</span>)  </span><br><span class="line">    <span class="comment">// 存储在store，更新store数据</span></span><br><span class="line">    that.$store.dispatch(<span class="string">'setInfo'</span>);</span><br><span class="line">    <span class="comment">// 获得返回值，说明用户验证通过，此时跳转到首页</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'index'</span>&#125;)  </span><br><span class="line">    &#125;)</span><br><span class="line">    .catch( <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>本例中使用的是非cookie传递的方式，后端直接将JWT通过Response进行返回，然后在Vue中通过response.data读取属性的方式获取到JWT并存储在cookie中，这里的cookie只起到了数据存储的作用，vue中之后会使用 cookie.getCookie(‘token’) 的方式读取数据使用。</p></blockquote><p>vue 传递 token 值给后端，用于身份验证：<br>根据 djangorestframework_jwt 文档要求，需要以 <code>Authorization: JWT &lt;your_token&gt;</code> 的形式进行传递，所以在前端设置 request拦截器，为 request 请求添加该信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue设置http request拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (store.state.userInfo.token) &#123;  <span class="comment">// 判断是否存在token，如果存在的话，则每个http header设置Authorization，添加token值</span></span><br><span class="line">      config.headers.Authorization = <span class="string">`JWT <span class="subst">$&#123;store.state.userInfo.token&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>通过这种方式向后端传递JWT，<br>后端通过设置 authentication_classes = (JSONWebTokenAuthentication,) 进行JWT认证<br>JSONWebTokenAuthentication 继承自 BaseJSONWebTokenAuthentication，该父类中提供了 <code>authenticate()</code> 方法用于验证用户，内部通过 <code>get_jwt_value(request)</code> 方法获得前端传递过来的token，内部通过调用 <code>jwt_decode_handler(jwt_value)</code> 反解 token 获得其中的 payload（该操作与之前的 <code>jwt_encode_handler(payload)</code> 相对），再通过 <code>authenticate_credentials(payload)</code> 获得user。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位于 rest_framework/authentication.py</span></span><br><span class="line"><span class="comment"># JSONWebTokenAuthentication 中的 get_jwt_value 调用该方法获得请求头中的 Authorization 属性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_authorization_header</span><span class="params">(request)</span>:</span></span><br><span class="line">    auth = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>, <span class="string">b''</span>)  <span class="comment"># 获得 Authorization 中的值</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(auth, str):</span><br><span class="line">        <span class="comment"># Work around django test client oddness</span></span><br><span class="line">        auth = auth.encode(HTTP_HEADER_ENCODING)</span><br><span class="line">    <span class="keyword">return</span> auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位于 rest_framework_jwt/authentication.py</span></span><br><span class="line"><span class="comment"># JSONWebTokenAuthentication 中的 get_jwt_value   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_jwt_value</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    auth = get_authorization_header(request).split() <span class="comment"># 通过split得到列表 ['JWT', 'token值']</span></span><br><span class="line">    auth_header_prefix = api_settings.JWT_AUTH_HEADER_PREFIX.lower()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> auth:  <span class="comment"># 如果auth中没有值，则可能是通过cookie传递，查看 JWT_AUTH_COOKIE 是否设置</span></span><br><span class="line">        <span class="keyword">if</span> api_settings.JWT_AUTH_COOKIE:  </span><br><span class="line">        <span class="comment"># 如果通过验证，则说明在之前是通过cookie的方式将JWT传递给前端的，那么这里也就一定会通过cookie返回了token，则之后的请求是一定会带上该cookie的，此时就可以直接获取并返回，不需要再进行下面的验证了。</span></span><br><span class="line">            <span class="keyword">return</span> request.COOKIES.get(api_settings.JWT_AUTH_COOKIE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证token 的前缀，这里使用的默认的 JWT</span></span><br><span class="line">    <span class="keyword">if</span> smart_text(auth[<span class="number">0</span>].lower()) != auth_header_prefix:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># auth中获得值是 ['JWT', 'token值'] 形式，长度一定是为2的</span></span><br><span class="line">    <span class="keyword">if</span> len(auth) == <span class="number">1</span>:</span><br><span class="line">        msg = _(<span class="string">'Invalid Authorization header. No credentials provided.'</span>)</span><br><span class="line">        <span class="keyword">raise</span> exceptions.AuthenticationFailed(msg)</span><br><span class="line">    <span class="keyword">elif</span> len(auth) &gt; <span class="number">2</span>:</span><br><span class="line">        msg = _(<span class="string">'Invalid Authorization header. Credentials string '</span></span><br><span class="line">                <span class="string">'should not contain spaces.'</span>)</span><br><span class="line">        <span class="keyword">raise</span> exceptions.AuthenticationFailed(msg)</span><br><span class="line">    <span class="keyword">return</span> auth[<span class="number">1</span>]  <span class="comment"># 返回token值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSONWebTokenAuthentication 从父类 BaseJSONWebTokenAuthentication 中继承过来的验证方法 autheiticate(self, request)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    jwt_value = self.get_jwt_value(request)  <span class="comment"># 获得前端传递过来的token值</span></span><br><span class="line">    <span class="keyword">if</span> jwt_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 调用jwt_decode_handler(jwt_value)反解token获得其中的payload</span></span><br><span class="line">        payload = jwt_decode_handler(jwt_value)  </span><br><span class="line">    <span class="keyword">except</span> jwt.ExpiredSignature:</span><br><span class="line">        msg = _(<span class="string">'Signature has expired.'</span>)</span><br><span class="line">        <span class="keyword">raise</span> exceptions.AuthenticationFailed(msg)</span><br><span class="line">    <span class="keyword">except</span> jwt.DecodeError:</span><br><span class="line">        msg = _(<span class="string">'Error decoding signature.'</span>)</span><br><span class="line">        <span class="keyword">raise</span> exceptions.AuthenticationFailed(msg)</span><br><span class="line">    <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">        <span class="keyword">raise</span> exceptions.AuthenticationFailed()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用反解得到的payload获得存储的用户</span></span><br><span class="line">    user = self.authenticate_credentials(payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (user, jwt_value)</span><br></pre></td></tr></table></figure><h3 id="可以定制的方法"><a class="header-anchor" href="#可以定制的方法">¶</a>可以定制的方法</h3><p>jwt_response_payload_handler(token, user, request)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jwt_response_payload_handler</span><span class="params">(token, user=None, request=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    可以自定义响应的内容，用于返回，可以定制要返回的数据，用于前端的获取</span></span><br><span class="line"><span class="string">    默认只返回了token值</span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def jwt_response_payload_handler(token, user=None, request=None):</span></span><br><span class="line"><span class="string">        return &#123;</span></span><br><span class="line"><span class="string">            'token': token,</span></span><br><span class="line"><span class="string">            'user': UserSerializer(user, context=&#123;'request': request&#125;).data</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'token'</span>: token</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以通过在settings.py中配置，用于定制返回的内容，默认只返回了token值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="string">'JWT_RESPONSE_PAYLOAD_HANDLER'</span>: <span class="string">'指定处理函数'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="djangorestframework-jwt-配置"><a class="header-anchor" href="#djangorestframework-jwt-配置">¶</a>djangorestframework_jwt 配置</h3><p>提供配置文件的方式，方便定制JWT的某些功能，除了上面的指定方法外，常用的配置还有以下几个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="string">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta(days=<span class="number">7</span>),  <span class="comment"># 设置JWT的过期时间</span></span><br><span class="line">    <span class="string">'JWT_AUTH_HEADER_PREFIX'</span>: <span class="string">'JWT'</span>,  <span class="comment"># 指定接受token的前缀，常用的有Token和JWT两种</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的 <code>JWT_AUTH_HEADER_PREFIX</code> 就是设置的 <code>JWT</code> 前缀，该设置在后端传递给前端token时并不其作用，而是在前端传递给后端的时候用到，用于在后端读取前端设置在 headers.Authorization 中的 <code>Authorization: JWT 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b</code> 时，验证前缀是否为settings.py中设置的前缀，所以该参数的设置只在后台验证的时候才会进行。</p><h3 id="token功能的项目代码内嵌"><a class="header-anchor" href="#token功能的项目代码内嵌">¶</a>token功能的项目代码内嵌</h3><p>有这样一种功能需求，我们在系统的注册功能中，当我们注册之后应该直接完成登录，显示登录状态，可以发现这部分的前端处理逻辑和登录功能的是类似，在跳转页面的时候也需要向后端传递token以完成身份的验证，但是djangorestframework_jwt只提供了login的url，并没有注册的，此时就需要我们手动在注册完成之后，手动构造符合djangorestframework_jwt要求的token并返回。<br>通过以上代码的分析，token的构造主要依赖两个方法，<code>jwt_payload_handler(user)</code>和<code>jwt_encode_handler(payload)</code>， 所以我们可以重写注册过程中需要使用到的 mixins.CreateModelMixin 中的create()方法，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    为了完成配合前端实现的 注册完成后即自动登录的要求</span></span><br><span class="line"><span class="string">    重载create方法，完成token的返回</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    serializer = self.get_serializer(data=request.data)</span><br><span class="line">    serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重载perform_create方法，使其返回创建的实例对象，这里获取到该返回值</span></span><br><span class="line">    user = self.perform_create(serializer)</span><br><span class="line">    re_dict = serializer.data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分析jwt源码，调用源码组件，完成token的构建</span></span><br><span class="line">    payload = jwt_payload_handler(user)</span><br><span class="line">    <span class="comment"># 获取返回的对象serializer.data，并添加token字段，由前端获取到</span></span><br><span class="line">    re_dict[<span class="string">"token"</span>] = jwt_encode_handler(payload)</span><br><span class="line">    re_dict[<span class="string">"name"</span>] = user.name <span class="keyword">if</span> user.name <span class="keyword">else</span> user.username</span><br><span class="line">    headers = self.get_success_headers(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回修改后的值</span></span><br><span class="line">    <span class="keyword">return</span> Response(re_dict, status=status.HTTP_201_CREATED, headers=headers)</span><br></pre></td></tr></table></figure><h2 id="登录状态和身份验证的关系"><a class="header-anchor" href="#登录状态和身份验证的关系">¶</a>登录状态和身份验证的关系</h2><p>注意这里要区分 登录状态 和 身份验证的关系:<br>身份验证是前端传递相关数据，如用户信息，或者通过session、token等认证机制判断当前用户是谁，以及获得用户的信息。<br>登录状态是前端的表现，如用户通过身份认证后会得到相应的信息作为标记，前端通过判断这个标记，显示是否为登录状态。</p><h2 id="session和token的区别"><a class="header-anchor" href="#session和token的区别">¶</a>session和token的区别</h2><ul><li>token 和 session 其实都是为了身份验证，session 一般翻译为会话，而 token 更多的时候是翻译为令牌。</li><li>session 服务器会保存一份，可能保存到缓存，文件，数据库，token 通过算法生成以及验证，后端不进行存储。</li><li>其实 token 与 session 的问题是一种时间与空间的博弈问题，session 是空间换时间，而 token 是时间换空间。两者的选择要看具体情况而定。虽然确实都是“客户端记录，每次访问携带”，但 token 很容易设计为自包含的，也就是说，后端不需要记录什么东西，每次一个无状态请求，每次解密验证，每次当场得出合法/非法的结论。这一切判断依据，除了固化在 CS 两端的一些逻辑之外，整个信息是自包含的。这才是真正的无状态。而 sessionid ，一般都是一段随机字符串，需要到后端去检索 id 的有效性。万一服务器重启导致内存里的 session 没了呢？万一 redis 服务器挂了呢？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 开发问题 </category>
          
          <category> Django REST framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django REST framework </tag>
            
            <tag> token原理 </tag>
            
            <tag> JWT用户验证 </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django REST framework的token原理和验证登录</title>
      <link href="2020/03/24/Django-REST-framework%E7%9A%84token%E7%99%BB%E9%99%86%E5%92%8C%E5%8E%9F%E7%90%86/"/>
      <url>2020/03/24/Django-REST-framework%E7%9A%84token%E7%99%BB%E9%99%86%E5%92%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="drf的登陆验证功能"><a class="header-anchor" href="#drf的登陆验证功能">¶</a>drf的登陆验证功能</h2><p>drf自带的登陆功能（drf Api Root中使用），通过定义路径访问 <code>rest_framework.urls</code> 中设置的路由进行访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^api-auth/'</span>, include(<span class="string">'rest_framework.urls'</span>, namespace=<span class="string">'rest_framework'</span>)),</span><br></pre></td></tr></table></figure><p>从子路径的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^login/$'</span>, views.LoginView.as_view(template_name=<span class="string">'rest_framework/login.html'</span>), name=<span class="string">'login'</span>),</span><br><span class="line">url(<span class="string">r'^logout/$'</span>, views.LogoutView.as_view(), name=<span class="string">'logout'</span>),</span><br></pre></td></tr></table></figure><p>可以发现，内部实现实际上是调用了Django的原生类 <code>LoginView</code> 和 <code>LogoutView</code>。<code>LoginView</code> 中添加了 <code>@method_decorator(csrf_protect)</code> 装饰器，所以在drf的API Root页面使用了<code>csrf_token </code> 标签，该标签会在渲染模版的时候替换为 <code>&lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=&quot;服务器随机生成的token值&quot;&gt;</code> ，配合  <code>django.middleware.csrf.CsrfViewMiddleware</code> 中间件防止csrf（跨站请求伪造），但是目前是一个前后端分离的系统，就不需要做csrf的验证（因为前后端分离的系统中，已经产生了跨站的问题，app和网站肯定不是一个站点，已经是跨站了），所以在做drf开发的时候，不需要关系csrf验证的问题。<br>综上，直接调用 <code>LoginView</code> 进行登录认证是不适合在前后端分离的系统中使用的。</p><h2 id="前后端分离的验证方式"><a class="header-anchor" href="#前后端分离的验证方式">¶</a>前后端分离的验证方式</h2><p>drf中的<a href="https://www.django-rest-framework.org/api-guide/authentication/" target="_blank" rel="noopener">Authentication</a>提供了一种 request 和 用户身份 绑定的机制。<br>使用方式：</p><ol><li>设置setting，设置认证方式，作用方式和Django中的中间件类似。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [ <span class="comment"># 设置权限验证的类，默认为以下两个类</span></span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>,</span><br><span class="line">        <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,  </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rest_framework.authentication.SessionAuthentication</code> 内部的实现很简单，只是从request中取出了user，实际还是依赖django的django.contrib.sessions.middleware.SessionMiddleware和django.contrib.auth.middleware.AuthenticationMiddleware这两个中间件。</p><ol start="2"><li><p>添加drf自带的Token认证类 <code>rest_framework.authentication.TokenAuthentication</code>，使用该类时，需要在 INSTALLED_APPS 中进行注册<code>'rest_framework.authtoken'</code>，因为需要使用数据表，生成<code>authtoken_token</code>表（所以在INSTALLED_APPS注册完之后，还需要使用 migrate 命令生成数据表），该表还用三个字段（key、created、user_id），通过 <code>user_id</code> 自动和用户表进行关联，保证一个用户对应着一个token值。<br>在创建用户的时候，不会自动生成token的key值，需要手动调用方法进行生成，手动生成的方式有几种：</p><ul><li><p>调用提供的 Token 类生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authtoken.models <span class="keyword">import</span> Token</span><br><span class="line"></span><br><span class="line">token = Token.objects.create(user=...)</span><br><span class="line">print(token.key)</span><br></pre></td></tr></table></figure></li><li><p>使用官方提供的url，<code>url(r'^api-token-auth/', views.obtain_auth_token)</code>，发送post请求，会返回相应的token，若没有则生成后返回，并自动和相应的用户进行关联（需要注意的该url请求是post请求，需要传递用户名和密码进行验证）。</p></li></ul></li><li><p>认证<br>需要手动在header中传递 <code>Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b</code> 。通过<code>DEFAULT_AUTHENTICATION_CLASSES</code> 的作用之后，就会获取到用户，然后将用户存储在request中的user属性中，token值存储在auth属性中。</p></li></ol><h2 id="token的实际应用"><a class="header-anchor" href="#token的实际应用">¶</a>token的实际应用</h2><p>问题：有这样的使用场景，若访问一个公共数据页面，一般的，这种公共页面即使是在用户未登录（没有传递token），或者用户传递的token产生错误的情况下也是可以访问的，该如何解决呢？</p><p>可以通过前端，也可以在后端解决。</p><p>后端的方式：<br>其实可以不需要采用在 <a href="http://settings.py" target="_blank" rel="noopener">settings.py</a> 中设置全局的 <code>DEFAULT_AUTHENTICATION_CLASSES</code> 的方式，而是在需要进行token验证的view中使用 <code>authentication_classes</code> 属性指定是否需要使用token验证（该属性在基础类APIView中设置了，authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES）。</p><blockquote><p>drf的配置，多数都可以选择是在settings.py中配置还是在view中进行配置。settings.py中的是全局的配置，view中的设置是局部的，同时设置时，view中的设置优先于全局的设置。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> TokenAuthentication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsListViewSet</span><span class="params">(mixins.ListModelMixin, viewsets.GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    商品列表页， 分页， 搜索， 过滤， 排序</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 注意是classes，可接受多个值，所以采用元组的数据格式，另外，当元组只有一个数据的时候，需要使用逗号</span></span><br><span class="line">    <span class="comment"># view中的局部设置会覆盖全局的设置</span></span><br><span class="line">    authentication_classes = (TokenAuthentication, ) </span><br><span class="line">    permission_classes = (IsAuthenticated,)  <span class="comment"># 只有设置了IsAuthenticated，才会进行身份验证</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h2><ol><li>目前，使用的token验证方式，token值是存储在生成的 <code>authtoken_token</code> 表中，是放在一台服务器上的，若采用分布式的话，还需要做数据的同步操作。</li><li>相比于 django_session 的设置，没有expire_date属性（过期时间），将是永久有效的，这样的话，一旦泄露将造成很大的安全问题。</li><li>和 django_session 存储同样的问题，随着用户的增多，token值会占用服务器大量空间，同时也会加大数据库的查询压力，导致性能下降。</li></ol><p>解决措施：使用JWT用户认证</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 开发问题 </category>
          
          <category> Django REST framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端跨域 </tag>
            
            <tag> Django REST framework </tag>
            
            <tag> token原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django自定义用户认证系统</title>
      <link href="2020/03/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/03/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>参考文档：<a href="https://docs.djangoproject.com/en/3.0/topics/auth/customizing/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.0/topics/auth/customizing/</a></p><h2 id="Django认证系统实现原理"><a class="header-anchor" href="#Django认证系统实现原理">¶</a>Django认证系统实现原理</h2><p>Django自带的认证系统通过调用 <code>django.contrib.auth.authenticate()</code> 方法实现，该方法是对外提供的可调用的统一接口，Django内部维护了一个认证列表，通过 settings.AUTHENTICATION_BACKENDS 配置进行设置，默认调用的是 <code>django.contrib.auth.backends.ModelBackend</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码位于 django/contrib/auth/__init__.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(request=None, **credentials)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    If the given credentials are valid, return a User object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 通过 _get_backends 读取settings.AUTHENTICATION_BACKENDS中配置的认证类</span></span><br><span class="line">    <span class="keyword">for</span> backend, backend_path <span class="keyword">in</span> _get_backends(return_tuples=<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            inspect.getcallargs(backend.authenticate, request, **credentials)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="comment"># This backend doesn't accept these credentials as arguments. Try the next one.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 调用获取到的认证类的 authenticate()方法进行验证</span></span><br><span class="line">            user = backend.authenticate(request, **credentials)</span><br><span class="line">        <span class="keyword">except</span> PermissionDenied:</span><br><span class="line">            <span class="comment"># This backend says to stop in our tracks - this user should not be allowed in at all.</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果返回的值是None（认证函数没有返回值时，得到的是None，或者有的认证函数就是返回的None）的话，说明当前调用的认证类认证失败，继续尝试下一个</span></span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 会为用户对象添加backend参数，用来记录认证时使用的认证类</span></span><br><span class="line">        <span class="comment"># 该参数会在login()方法中，放到session中保存</span></span><br><span class="line">        user.backend = backend_path</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The credentials supplied are invalid to all backends, fire signal</span></span><br><span class="line">    user_login_failed.send(sender=__name__, credentials=_clean_credentials(credentials), request=request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认调用的认证类 ModelBackend</span></span><br><span class="line"><span class="comment"># 源码位于 django/contrib/auth/backends.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelBackend</span>:</span></span><br><span class="line">    <span class="comment"># 提供认证方法authenticate()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request, username=None, password=None, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 内部主要通过传递过来的用户名和密码完成身份的验证</span></span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            username = kwargs.get(UserModel.USERNAME_FIELD)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user = UserModel._default_manager.get_by_natural_key(username)</span><br><span class="line">        <span class="keyword">except</span> UserModel.DoesNotExist:</span><br><span class="line">            <span class="comment"># Run the default password hasher once to reduce the timing</span></span><br><span class="line">            <span class="comment"># difference between an existing and a nonexistent user (#20760).</span></span><br><span class="line">            UserModel().set_password(password)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> user.check_password(password) <span class="keyword">and</span> self.user_can_authenticate(user):</span><br><span class="line">                <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过源码可以发现， 当调用 <code>django.contrib.auth.authenticate()</code> 时，会依次尝试调用设置中提供的认证方法，直到有认证方法成功，否则会一直尝试直到所有认证都失败，且一旦引发 PermissionDenied 异常，认证将立即失败。Django不会检查再后面的认证，此外AUTHENTICATION_BACKENDS中认证类的顺序很重要，当有一个认证成功则立即返回，同样不再进行后面的认证。</p><blockquote><p>一旦用户被认证过，Django会在用户的session中存储他使用的认证后端，然后在session有效期中一直会为该用户提供此后端认证（通过登录方法login()进行该操作）。 所以如果你改变 AUTHENTICATION_BACKENDS, 迫使用户重新认证，需要清除掉 session 数据.一个简单的方式是使用这个方法： Session.objects.all().delete()。</p></blockquote><h2 id="自定义用户认证类"><a class="header-anchor" href="#自定义用户认证类">¶</a>自定义用户认证类</h2><p>用户认证是Django中一切权限操作的基础，例如之前的djangorestframework-jwt在返回token时，也是调用了Django自带的auth认证完成了用户信息（username和password）的核对，但是Django默认使用的认证类ModelBackend是通过用户名和密码进行认证的，而我们在使用的过程中可能有其他的需求，如通过手机号码进行认证，此时就需要自定义我们自己的认证类了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># users/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.backends <span class="keyword">import</span> ModelBackend</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> get_user_model</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line">User = get_user_model()  <span class="comment"># 获得当前使用的User类的实例对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomBackend</span><span class="params">(ModelBackend)</span>:</span></span><br><span class="line">    <span class="comment"># 重写ModelBackend的authenticate方法，添加用户手机验证</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request, username=None, password=None, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user = User.objects.get(Q(username=username) | Q(mobile=username))</span><br><span class="line">            <span class="comment"># 传递过来的password是明文，Django数据库中保存的是密文，check_password()会先加密再进行比对</span></span><br><span class="line">            <span class="keyword">if</span> user.check_password(password):</span><br><span class="line">                <span class="keyword">return</span> user</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>此外还需要在settings.py中进行配置，覆盖掉默认类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义auth验证函数</span></span><br><span class="line">AUTHENTICATION_BACKENDS = (</span><br><span class="line">    <span class="string">'users.views.CustomBackend'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="django的整套认证流程"><a class="header-anchor" href="#django的整套认证流程">¶</a>django的整套认证流程</h2><p>在web应用中，我们需要对一些页面使用用户认证，但是不可能每次验证都要通过传递用户名和密码使用 <code>authenticate()</code> 进行认证，Django为web请求提供了一套登录认证系统，方便使用者做用户的验证。</p><p>Django使用会话（session）和中间件将认证系统放到了request对象中。它们在每个请求上提供一个 request.user 属性（通过<code>django.contrib.auth.middleware.AuthenticationMiddleware</code>中间件实现），存储当前的用户。如果当前的用户没有登入，该属性将设置成 AnonymousUser 的一个实例，否则它将是 User 的实例。<br>你可以通过 <code>is_authenticated</code> 区分它们，像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.user.is_authenticated:</span><br><span class="line">    <span class="comment"># Do something for authenticated users.</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Do something for anonymous users.</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>注意：在Django1.10+之后，is_authenticated被设计为属性，通过 @property 实现，用户表的基类AbstractBaseUser中的该属性的返回值为True，匿名用户AnonymousUser中也实现了该属性，返回值为False。所以该属性可以用来判断request.user中的对象是否认证过（认证过的用户是用户表中的user实例，所以调用is_authenticated返回的值为True）。</p></blockquote><h3 id="如何保存认证信息"><a class="header-anchor" href="#如何保存认证信息">¶</a>如何保存认证信息</h3><p>通过Django提供的 <code>login()</code> 函数，该函数会利用Django的session框架将用户（注意这里的用户一定是通过了 authenticate() 认证后的用户）的id存储到session中，之后在访问的时候通过中间件 <code>django.contrib.sessions.middleware.SessionMiddleware</code> 和 <code>django.contrib.auth.middleware.AuthenticationMiddleware</code> 完成认证信息的提取。</p><p>源码分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码位置 django/contrib/auth/__init__.py </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request, user, backend=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Persist a user id and a backend in the request. This way a user doesn't</span></span><br><span class="line"><span class="string">    have to reauthenticate on every request. Note that data set during</span></span><br><span class="line"><span class="string">    the anonymous session is retained when the user logs in.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    session_auth_hash = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果传递的user参数是None的话，会自动赋值当前request.user中的值，可能是匿名用户AnonymousUser的实例对象</span></span><br><span class="line">        user = request.user  <span class="comment"># 由中间件AuthenticationMiddleware赋予，可能是存在的用户，也可能是匿名用户AnonymousUser</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(user, <span class="string">'get_session_auth_hash'</span>):</span><br><span class="line">        <span class="comment"># get_session_auth_hash()是AbstractBaseUser类特有的方法，该类是django中用户表的最上层基础类，所以若是用户表中的对象就一定可以调用该方法</span></span><br><span class="line">        session_auth_hash = user.get_session_auth_hash()  <span class="comment"># 返回密码字段的HMAC值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> SESSION_KEY <span class="keyword">in</span> request.session:  <span class="comment"># _auth_user_id，request.session由中间件SessionMiddleware赋予</span></span><br><span class="line">        <span class="keyword">if</span> _get_user_session_key(request) != user.pk <span class="keyword">or</span> (</span><br><span class="line">                session_auth_hash <span class="keyword">and</span></span><br><span class="line">                <span class="keyword">not</span> constant_time_compare(request.session.get(HASH_SESSION_KEY, <span class="string">''</span>), session_auth_hash)):</span><br><span class="line">            <span class="comment"># To avoid reusing another user's session, create a new, empty</span></span><br><span class="line">            <span class="comment"># session if the existing session corresponds to a different</span></span><br><span class="line">            <span class="comment"># authenticated user.</span></span><br><span class="line">            request.session.flush()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        request.session.cycle_key()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># or 运算符，a or b, 如果a为真，表达式为a，反之，为b</span></span><br><span class="line">        <span class="comment"># 所以在未传递该参数的情况下，当前表达式的值为user.backend</span></span><br><span class="line">        backend = backend <span class="keyword">or</span> user.backend</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="comment"># 异常只有一种情况，就是使用user.backend时，user没有backend属性，该属性是在使用authenticate()认证之后赋予的,为 backend_path 的值</span></span><br><span class="line">        <span class="comment"># 此时用户可能是AnonymousUser（AnonymousUser对象没有该属性），也可能是直接从数据库取的未认证的对象（认证过的对象会添加backend参数）</span></span><br><span class="line">        <span class="comment"># 此时就手动调用获得设置的 认证类，但是此时需要配置中只能有一个认证的类，否则报异常（理所当然，如果允许多个认证类，登录认证就没有意义了）</span></span><br><span class="line">        backends = _get_backends(return_tuples=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> len(backends) == <span class="number">1</span>:</span><br><span class="line">            _, backend = backends[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">'You have multiple authentication backends configured and '</span></span><br><span class="line">                <span class="string">'therefore must provide the `backend` argument or set the '</span></span><br><span class="line">                <span class="string">'`backend` attribute on the user.'</span></span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(backend, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'backend must be a dotted import path string (got %r).'</span> % backend)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行到此处，两种情况：认证过的带有backend属性的用户，未认证过的用户</span></span><br><span class="line">    request.session[SESSION_KEY] = user._meta.pk.value_to_string(user)</span><br><span class="line">    request.session[BACKEND_SESSION_KEY] = backend</span><br><span class="line">    request.session[HASH_SESSION_KEY] = session_auth_hash</span><br><span class="line">    <span class="keyword">if</span> hasattr(request, <span class="string">'user'</span>):</span><br><span class="line">        request.user = user  <span class="comment"># 如果当前request对象没有user属性，则使用当前传递的对象创建</span></span><br><span class="line">    rotate_token(request)  <span class="comment"># 更改csrftoken</span></span><br><span class="line">    user_logged_in.send(sender=user.__class__, request=request, user=user)</span><br></pre></td></tr></table></figure><p>根据代码的分析，在使用login()登录的时候，需要优先使用authenticate()进行认证，因为authenticate()在User上设置一个属性backend名，标识哪种认证后台成功认证了该用户，且该信息在后面登录的过程中是需要的，所以必须有authenticate()认证的过程，所以正确的login()使用方式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginView</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        完成登录 验证的逻辑</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># Django提供的表单验证：只是根据定义的要求，对数据格式方法进行验证，对于正确性，用户名和密码是否对应这个验证还是需要交给authenticate</span></span><br><span class="line">        login_form = LoginForm(request.POST)  <span class="comment"># django自带的表单功能除了有验证功能，还可以对数据进行一定的处理</span></span><br><span class="line">        <span class="keyword">if</span> login_form.is_valid():  <span class="comment"># 会对字段进行LoginForm中设置的类型进行基本的验证，即是否有值，长度是否符合进行验证，错误信息显示在error属性中</span></span><br><span class="line">            user_name = login_form.cleaned_data[<span class="string">"username"</span>]</span><br><span class="line">            password = login_form.cleaned_data[<span class="string">"password"</span>]</span><br><span class="line">            user = authenticate(username=user_name, password=password)  <span class="comment"># 自带的用户名和密码验证功能，用于通过用户名和密码查询用户是否存在，不存在时为None</span></span><br><span class="line">            <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 查询到用户</span></span><br><span class="line">                login(request, user)  <span class="comment"># 自动完成session的设置，如何取到user对应的sessionid，以及如何将sessionid传递到cookie中都自动完成</span></span><br><span class="line">                <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">"index"</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 未查询到用户</span></span><br><span class="line">                <span class="keyword">return</span> render(request, <span class="string">"login.html"</span>, &#123;<span class="string">"msg"</span>: <span class="string">"用户名或 密码错误"</span>, <span class="string">"login_form"</span>: login_form)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">"login.html"</span>, &#123;<span class="string">"login_form"</span>: login_form)</span><br></pre></td></tr></table></figure><p>此时就完成了用户登录的操作，在后续的认证中，系统将直接通过中间件 <code>django.contrib.sessions.middleware.SessionMiddleware</code> 和 <code>django.contrib.auth.middleware.AuthenticationMiddleware</code> 完成认证信息的提取，在系统中直接使用request.user获得存储的用户。</p><p>AuthenticationMiddleware中间件赋值user的时候，会通过session的判断，赋值认证过的user，或者是 AnyAnonymousUser， 调用的函数是 <code>django/contrib/auth/__init__.py</code> 下的get_user(request)方法，该方法下又是通过session来验证用户的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 开发问题 </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlAlchemy 使用</title>
      <link href="2020/02/15/SqlAlchemy-%E4%BD%BF%E7%94%A8/"/>
      <url>2020/02/15/SqlAlchemy-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><p>使用 <code>pip install sqlalchemy</code> 进行安装<br>默认情况下，SqlAlchemy 是直接支持 SQLite3 的，不需要安装额外的驱动程序，但是想要支持其他的数据库需要安装相应的驱动程序</p><ul><li>若想要支持 mysql，需要安装 pymysql 驱动</li></ul><h2 id="使用（以使用-MySql-为例）"><a class="header-anchor" href="#使用（以使用-MySql-为例）">¶</a>使用（以使用 MySql 为例）</h2><h3 id="连接数据库"><a class="header-anchor" href="#连接数据库">¶</a>连接数据库</h3><p>要连接数据库，首先需要建立一个 SqlAlchemy 引擎，为数据库创建一个公共接口来执行 SQL 语句<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引擎</span></span><br><span class="line">engine = create_engine(</span><br><span class="line">    <span class="string">'mysql+pymysql://root:739230854@localhost:3306/test'</span>, pool_recycle=<span class="number">3600</span></span><br><span class="line">)</span><br><span class="line">connection = engine.connect()  <span class="comment"># &lt;sqlalchemy.engine.base.Connection object at 0x7f9028117510&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>create_engine</code> 函数会返回一个引擎的实例。但是，在调用需要使用连接的操作（比如查询）之前，它实际上并不会打开连接。</p></blockquote><h3 id="选择-SQLAlchemy-Core-还是-SQLAlchemy-ORM"><a class="header-anchor" href="#选择-SQLAlchemy-Core-还是-SQLAlchemy-ORM">¶</a>选择 SQLAlchemy Core 还是 SQLAlchemy ORM</h3><p>在使用 SQLAlchemy 构建应用程序之前，你要决定主要使用 ORM 还是 Core，这通常取决于多个因素和个人偏好。两者语法略有不同，最大的区别是把数据看作模式还是业务对象。<br>Core 的视图以模式为中心，与传统的 SQL 一样，关注的是表、键和索引结构。ORM 把元数据和业务对象中的底层模式和结构封装起来，这种封装使得和数据库的交互变得更加容易，就像在使用普通的 Python 代码一样。</p><h3 id="使用-SQLAlchemy-Core-为应用程序提供数据库服务"><a class="header-anchor" href="#使用-SQLAlchemy-Core-为应用程序提供数据库服务">¶</a>使用 SQLAlchemy Core 为应用程序提供数据库服务</h3><h4 id="模式和类型"><a class="header-anchor" href="#模式和类型">¶</a>模式和类型</h4><p>SqlAlchemy 提供了四种类型：</p><ul><li>通用类型</li><li>SQL类型</li><li>厂商自定义类型</li><li>用户定义类型</li></ul><p>SQLAlchemy 定义了大量的通用类型，可以从 sqlalchemy.type 模块中导入，为了方便起见，在 sqlalchemy 中也可以直接使用。</p><p><em><strong>通用类型及对应关系表：</strong></em></p><table><thead><tr><th style="text-align:left">SQLAlchemy</th><th style="text-align:left">Python</th><th style="text-align:left">SQL</th></tr></thead><tbody><tr><td style="text-align:left">BigInteger</td><td style="text-align:left">int</td><td style="text-align:left">BIGINT</td></tr><tr><td style="text-align:left">Boolean</td><td style="text-align:left">bool</td><td style="text-align:left">BOOLEAN或SMALLINT</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">datetime.date</td><td style="text-align:left">DATE（SQLite:STRING）</td></tr><tr><td style="text-align:left">DateTime</td><td style="text-align:left">datetime.datetime</td><td style="text-align:left">DATETIME（SQLite:STRING）</td></tr><tr><td style="text-align:left">Enum</td><td style="text-align:left">str</td><td style="text-align:left">ENUM或VARCHAR</td></tr><tr><td style="text-align:left">Float</td><td style="text-align:left">float或Decimal</td><td style="text-align:left">FLOAT或REAL</td></tr><tr><td style="text-align:left">Integer</td><td style="text-align:left">int</td><td style="text-align:left">INTEGER</td></tr><tr><td style="text-align:left">Interval</td><td style="text-align:left">datetime.timedelta</td><td style="text-align:left">INTERVAL或DATE（从纪元开始）</td></tr><tr><td style="text-align:left">LargeBinary</td><td style="text-align:left">byte</td><td style="text-align:left">BLOB或BYTEA</td></tr><tr><td style="text-align:left">Numeric</td><td style="text-align:left">decimal.Decimal</td><td style="text-align:left">NUMERIC或DECIMAL</td></tr><tr><td style="text-align:left">Unicode</td><td style="text-align:left">unicode</td><td style="text-align:left">UNICODE或VARCHAR</td></tr><tr><td style="text-align:left">Text</td><td style="text-align:left">str</td><td style="text-align:left">CLOB或TEXT</td></tr><tr><td style="text-align:left">Tiem</td><td style="text-align:left">datetime.time</td><td style="text-align:left">DATETIME</td></tr></tbody></table><p>除了通用类型，还可以使用SQL标准类型和厂商自定义类型，是为了方便在通用类型无法满足时调用的。</p><p>区别：</p><ul><li>SQL标准类型在 sqlalchemy.type 中可用，且为了和通用类型区分，都要大写</li><li>厂商自定义类型只使用于特定的后端数据库类型，可以通过所选方言文档以及 Sqlalchemy 站点确定可用的类型，都在sqlalchemy.dialects 模块中，且每个数据库方言都有若干子模块，如使用 postgresql 数据库中的json格式，可以使用 <code>from sqlalchemy.dialects.postgresql import json</code> 进行调用。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> MetaData</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, Column, Integer, Numeric, String, ForeignKey, Boolean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引擎</span></span><br><span class="line">engine = create_engine(</span><br><span class="line">    <span class="string">'mysql+pymysql://root:739230854@localhost:3306/test'</span>, pool_recycle=<span class="number">3600</span></span><br><span class="line">)</span><br><span class="line">connection = engine.connect()  <span class="comment"># 打开数据库的链接，创建表的时候并不需要</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元数据</span></span><br><span class="line">metadata = MetaData()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表</span></span><br><span class="line">cookies = Table(<span class="string">'cookies'</span>, metadata,</span><br><span class="line">    Column(<span class="string">'cookie_id'</span>, Integer(), primary_key=<span class="literal">True</span>),  <span class="comment"># 作为主键</span></span><br><span class="line">    Column(<span class="string">'cookie_name'</span>, String(<span class="number">50</span>), index=<span class="literal">True</span>),  <span class="comment"># 创建索引，加快查找的速度</span></span><br><span class="line">    Column(<span class="string">'cookie_recipe_url'</span>, String(<span class="number">50</span>)),  </span><br><span class="line">    Column(<span class="string">'cookie_sku'</span>, String(<span class="number">55</span>)),</span><br><span class="line">    Column(<span class="string">'quantity'</span>, Integer()),</span><br><span class="line">    Column(<span class="string">'unit_cost'</span>, Numeric(<span class="number">12</span>, <span class="number">2</span>))  <span class="comment"># 长度以及精度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带有更多选项的表</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> DateTime</span><br><span class="line"></span><br><span class="line">user = Table(<span class="string">'users'</span>, metadata,</span><br><span class="line">    Column(<span class="string">'user_id'</span>, Integer(), primary_key=<span class="literal">True</span>),</span><br><span class="line">    Column(<span class="string">'username'</span>, String(<span class="number">15</span>), nullable=<span class="literal">False</span>, unique=<span class="literal">True</span>),  <span class="comment"># 必须有，且不能为空</span></span><br><span class="line">    Column(<span class="string">'email_address'</span>, String(<span class="number">255</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    Column(<span class="string">'phone'</span>, String(<span class="number">20</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    Column(<span class="string">'password'</span>, String(<span class="number">25</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    Column(<span class="string">'created_on'</span>, DateTime(), default=datetime.now),</span><br><span class="line">    Column(<span class="string">'updated_on'</span>, DateTime(), default=datetime.now, onupdate=datetime.now)  <span class="comment"># 设置onupdate使得每次更新的时候将当前时间设置给列</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> ForeignKey</span><br><span class="line"></span><br><span class="line">orders = Table(<span class="string">'orders'</span>, metadata,</span><br><span class="line">    Column(<span class="string">'order_id'</span>, Integer(), primary_key=<span class="literal">True</span>),</span><br><span class="line">    Column(<span class="string">'user_id'</span>, ForeignKey(<span class="string">'users.user_id'</span>)),  <span class="comment"># 使用的是字符串，而不是对列的实际引用</span></span><br><span class="line">    Column(<span class="string">'shipped'</span>, Boolean(), default=<span class="literal">False</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">line_items = Table(<span class="string">'line_items'</span>, metadata,</span><br><span class="line">    Column(<span class="string">'line_items)id'</span>, Integer(), primary_key=<span class="literal">True</span>),</span><br><span class="line">    Column(<span class="string">'order_id'</span>, ForeignKey(<span class="string">'orders.order_id'</span>)),</span><br><span class="line">    Column(<span class="string">'cookie_id'</span>, ForeignKey(<span class="string">'cookies.cookie_id'</span>)),</span><br><span class="line">    Column(<span class="string">'quantity'</span>, Integer()),</span><br><span class="line">    Column(<span class="string">'extended_cost'</span>, Numeric(<span class="number">12</span>, <span class="number">2</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表的持久化-即在数据库中创建表</span></span><br><span class="line">metadata.create_all(engine)</span><br></pre></td></tr></table></figure><h4 id="插入数据"><a class="header-anchor" href="#插入数据">¶</a>插入数据</h4><p>使用 <code>insetr()</code> 作为表实例cookies的方法进行数据插入<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line">ins = cookies.insert().values(</span><br><span class="line">    cookie_name = <span class="string">'chocolate chip'</span>,</span><br><span class="line">    cookie_recipe_url = <span class="string">"http://xxx"</span>,</span><br><span class="line">    cookie_sku = <span class="string">'CC01'</span>,</span><br><span class="line">    quantity = <span class="string">'12'</span>,</span><br><span class="line">    unit_cost = <span class="string">'0.50'</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># print(str(ins))</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">INSERT INTO cookies </span></span><br><span class="line"><span class="string">    (cookie_name, cookie_recipe_url, cookie_sku, quantity, unit_cost) </span></span><br><span class="line"><span class="string">VALUES </span></span><br><span class="line"><span class="string">    (:cookie_name, :cookie_recipe_url, :cookie_sku, :quantity, :unit_cost)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># print(ins.compile().params)  # 可以查询随查询一起发送的实际参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'cookie_name': 'chocolate chip', 'cookie_recipe_url': 'http://xxx', </span></span><br><span class="line"><span class="string">'cookie_sku': 'CC01', 'quantity': '12', 'unit_cost': '0.50'&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>在SQL语句中，我们提供的值被替换为 <code>:column_name</code> 的形式，这就是 SQLAlchemy 通过 str() 函数表示参数的方式，参数用来帮助确保数据被正确的转义，从而减少 SQL 注入攻击等安全问题。<br>ins 对象的 compile() 方法返回一个 SQLCompiler 对象，该对象允许我们通过 params 属性访问隋查询一起发送的实际参数。</p></blockquote><p><code>insert</code>除了可以作为表实例cookies的方法来使用外，还可以作为单独的函数来使用，此时表实例cookies作为函数的参数，事实上，这种方法更加贴近于数据库的 insert 写法，因此更加推荐这种用法<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> insert</span><br><span class="line"></span><br><span class="line">ins = insert(cookies).values(</span><br><span class="line">    cookie_name = <span class="string">'chocolate chip'</span>,</span><br><span class="line">    cookie_recipe_url = <span class="string">"http://xxx"</span>,</span><br><span class="line">    cookie_sku = <span class="string">'CC01'</span>,</span><br><span class="line">    quantity = <span class="string">'12'</span>,</span><br><span class="line">    unit_cost = <span class="string">'0.50'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="执行插入数据"><a class="header-anchor" href="#执行插入数据">¶</a>执行插入数据</h5><p>执行插入语句，执行前需要先添加引擎并连接<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy_test <span class="keyword">import</span> cookies</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引擎</span></span><br><span class="line">engine = create_engine(</span><br><span class="line">    <span class="string">'mysql+pymysql://root:739230854@localhost:3306/test'</span>, pool_recycle=<span class="number">3600</span></span><br><span class="line">)</span><br><span class="line">connection = engine.connect()  <span class="comment"># 打开数据库的链接</span></span><br><span class="line"></span><br><span class="line">result = connection.execute(ins) <span class="comment"># 使用链接执行</span></span><br><span class="line"></span><br><span class="line">print(result)  <span class="comment"># &lt;sqlalchemy.engine.result.ResultProxy object at 0x7f1d30fe5f10&gt;</span></span><br><span class="line">print(result.inserted_primary_key)  <span class="comment"># 产看刚刚添加的数据的ID</span></span><br></pre></td></tr></table></figure><p>连接对象的<code>execute</code>方法不仅可以接受语句，还可以在语句之后接受关键字参数值，在编译语句时，它会向列列表添加每个关键字参数键，并将它们的每个值添加到 SQL 语句的 VALUES 部分，但是这种用法不常用，但是他很好的说明了语句在发送到数据库服务器之前是如何编译和组装的。可以通过使用一个字典列表一次插入很多条记录，字典里面包含我们要提交的数据。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ins = cookies.insert()  <span class="comment"># 此处的ins也可以这么写 ins = insert(cookies)</span></span><br><span class="line">result = connection.execute(</span><br><span class="line">    ins,  <span class="comment"># 插入语句仍然是execute方法的第一个参数</span></span><br><span class="line">    cookie_name = <span class="string">'dack chocolate chip'</span>,</span><br><span class="line">    cookie_recipe_url = <span class="string">"http://xxx/qqq"</span>,</span><br><span class="line">    cookie_sku = <span class="string">'CC02'</span>,</span><br><span class="line">    quantity = <span class="string">'1'</span>,</span><br><span class="line">    unit_cost = <span class="string">'0.75'</span></span><br><span class="line">)  <span class="comment"># 这样在连接的同时，添加了数据</span></span><br></pre></td></tr></table></figure><p>进阶版，通过使用一个字典列表一次插入很多条记录，字典里面包含我们要提交的数据<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">inventory_list = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'cookie_name'</span>: <span class="string">'peanut butter'</span>,</span><br><span class="line">        <span class="string">'cookie_recipe_url'</span>: <span class="string">'http://xxx/1'</span>,</span><br><span class="line">        <span class="string">'cookie_sku'</span>: <span class="string">'PB01'</span>,</span><br><span class="line">        <span class="string">'quantity'</span>: <span class="string">'24'</span>,</span><br><span class="line">        <span class="string">'unit_cost'</span>: <span class="string">'0.25'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'cookie_name'</span>: <span class="string">'oatmeal raisin'</span>,</span><br><span class="line">        <span class="string">'cookie_recipe_url'</span>: <span class="string">'http://xxx/2'</span>,</span><br><span class="line">        <span class="string">'cookie_sku'</span>: <span class="string">'EWW01'</span>,</span><br><span class="line">        <span class="string">'quantity'</span>: <span class="string">'100'</span>,</span><br><span class="line">        <span class="string">'unit_cost'</span>: <span class="string">'1.00'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">result = connection.execute(ins, inventory_list)</span><br></pre></td></tr></table></figure><blockquote><p><font color="red">注意</font>：创建字典列表的时候，字典必须拥有完全相同的键，sqlalchemy 会根据列表中的第一个字典编译语句，如果后续的字典不同会出错</p></blockquote><h4 id="查找数据"><a class="header-anchor" href="#查找数据">¶</a>查找数据</h4><p>使用 <code>select()</code> 作为表实例 cookies 的方法进行数据查询，select() 方法需要一个列的<em>列表</em>来选择，为了方便，还可以直接接受一个 Table 实例（这里的cookies表），则此时选中该表中的所有的内容。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">s = select([cookies])  </span><br><span class="line"><span class="comment"># print(str(s))  # 仍然可以使用str(s)查看数据库看到的SQL语句，或者直接打印也行</span></span><br><span class="line">rp = connection.execute(s)  <span class="comment"># rp是ResultProxy的缩写</span></span><br><span class="line"><span class="comment"># print('rp:',type(rp))  # &lt;sqlalchemy.engine.result.ResultProxy object at 0x7f2dc9f608d0&gt;</span></span><br><span class="line">result = rp.fetchall()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">print(result)</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    (5, 'chocolate chip', 'http://xxx', 'CC01', 12, Decimal('0.50')), </span></span><br><span class="line"><span class="string">    (6, 'dack chocolate chip', 'http://xxx/qqq', 'CC02', 1, Decimal('0.75')), </span></span><br><span class="line"><span class="string">    (7, 'peanut butter', 'http://xxx/1', 'PB01', 24, Decimal('0.25')), </span></span><br><span class="line"><span class="string">    (8, 'oatmeal raisin', 'http://xxx/2', 'EWW01', 100, Decimal('1.00'))</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><p>与 <code>insert()</code> 方法的调用方式一致，Table 实例对象也提供了 select() 方法<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = cookies.select()  <span class="comment"># 直接使用cookies的select方法</span></span><br><span class="line">rp = connection.execute(s)</span><br></pre></td></tr></table></figure><h5 id="ResultProxy"><a class="header-anchor" href="#ResultProxy">¶</a>ResultProxy</h5><p>ResultProxy 是 DBAPI 游标对象的包装器，主要目的是让语句返回的结果更容易使用和操作，比如，ResultProxy 允许通过索引，名称或 column对象 进行访问，从而简化了对查询结果的处理。<br>通过上面的例子中可以发现，调用 <code>connection.execute(s)</code> 执行数据库操作之后返回的实例对象就是 ResultProxy 类型。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">first_row = result[<span class="number">0</span>]  <span class="comment"># 获取ResultProxy的第一行</span></span><br><span class="line">print(first_row)</span><br><span class="line">print(first_row[<span class="number">1</span>])  <span class="comment"># 通过索引访问列</span></span><br><span class="line">print(first_row.cookie_name)  <span class="comment"># 通过名称访问列</span></span><br><span class="line">print(first_row[cookies.c.cookie_name])  <span class="comment"># 通过column对象访问列</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(5, 'chocolate chip', 'http://xxx', 'CC01', 12, Decimal('0.50'))</span></span><br><span class="line"><span class="string">chocolate chip</span></span><br><span class="line"><span class="string">chocolate chip</span></span><br><span class="line"><span class="string">chocolate chip</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：例子中的result是调用 ResultProxy 提供的 fetchall() 方法得到的</p></blockquote><p>通过迭代的方式获得 ResultProxy 的项<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = select([cookies])</span><br><span class="line">rp = connection.execute(s)</span><br><span class="line">print(rp.keys())   <span class="comment"># 通过 ResultProxy 的keys()方法，得到表列名</span></span><br><span class="line"><span class="comment"># ['cookie_id', 'cookie_name', 'cookie_recipe_url', 'cookie_sku', 'quantity', 'unit_cost']</span></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> rp:  <span class="comment"># 通过迭代的方式获得 ResultProxy 的项</span></span><br><span class="line">    print(record)  <span class="comment"># (9, 'chocolate chip', 'http://xxx', 'CC01', 12, Decimal('0.50'))</span></span><br><span class="line">    print(type(record))  <span class="comment"># &lt;class 'sqlalchemy.engine.result.RowProxy'&gt;  注意是 RowProxy</span></span><br><span class="line">    print(record.cookie_name)  <span class="comment"># chocolate chip</span></span><br></pre></td></tr></table></figure><p>ResultProxy 提供的可调用方法和属性包括：</p><ul><li>使用 <code>rowcount</code> 属性获得本次操作的数据条数，如在查询操作中，就是获得本次查询获得数据条数</li><li>使用 <code>inserted_primary_key</code> 属性获得数据插入操作中，插入的数据的主键值</li><li><code>first()</code> 方法，若有记录，则返回第一个记录并关闭连接，此时想再操作会报异常 <code>sqlalchemy.exc.ResourceClosedError: This result object is closed.</code></li><li><code>fetchone()</code> 方法，返回一条数据，并保持光标为打开的状态，以便你做更多的获取调用，光标会记录位置。</li><li><code>fetchall()</code> 方法，以列表的形式返回所有的记录，光标会记录位置。</li><li>使用 for 循环得到数据，光标会记录位置。</li><li><code>scalar()</code> 方法，只返回查询到的第一个数据的最左边的列，且只返回第一行的数据。</li><li>如果想产看结果集中的多个列，可以使用 <code>keys()</code> 方法来获得列名列表。</li></ul><blockquote><p>具体方法的调用，可以遵循以下方针：</p><ol><li>获取单条记录时，要多用 first() 方法，尽量不要使用 fetchone() 和 scalar() 方法，因为对程序员来说，first() 方法更加清晰，需要注意，使用 first() 返回第一条记录后将自动关闭连接。</li><li>尽量使用可迭代对象 ResultProxy，而不要用 fetchall() 和 fetchone() 方法，因为前者的内存效率更高，而且我们往往一次只对一条记录进行操作。</li><li>避免使用 fetchone() 方法，因为如果不小心，他会一直让连接处在打开状态，因为使用 fetchone() 会返回一行，并保持光标为打开的状态，以便你做更多的获取调用。</li><li>谨慎使用 scalar() 方法，因为如果查询返回多行多列，就会引发错误，多行多列在测试过程中会经常丢失。</li></ol></blockquote><p>以上的查询方式得到各条记录的所有列，通常我们只需要使用这些列中的一部分。如果额外的列中的数据量很大，就会到导致应用程序运行变慢，消耗的内存远超预期，下面我们可以对查询返回的列数进行限制。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了限制返回的列数，需要以列表的形式将查询的列传递给 select() 方法</span></span><br><span class="line">s = select([cookies.c.cookie_name, cookies.c.quantity])</span><br><span class="line">rp = connection.execute(s)</span><br><span class="line">print(rp.keys())</span><br><span class="line">print(rp.first())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">['cookie_name', 'quantity']</span></span><br><span class="line"><span class="string">('chocolate chip', 12)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>[*] <code>cookies.c.cookie_name</code> 表示cookies表的Column对象（列对象）cookie_name</strong></p><h5 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h5><p>需要将查找返回的数据按照特性的顺序排列，可以使用 <code>order_by()</code> 语句，默认是升序的方式排序。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = select([cookies.c.cookie_name, cookies.c.quantity]).order_by(cookies.c.quantity)</span><br><span class="line"><span class="comment"># 在查询后，调用 order_by() 方法，通过表的列明来指定排列标准</span></span><br><span class="line">rp = connection.execute(s)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> rp:</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;cookie.quantity&#125;</span> - <span class="subst">&#123;cookie.cookie_name&#125;</span>"</span>)   <span class="comment"># 通过数据名称进行访问</span></span><br></pre></td></tr></table></figure><p>想要降序或者倒序排列，可以使用<code>desc()</code>语句，但是，这需要额外的导包 <code>from sqlalchemy import desc</code><br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> desc</span><br><span class="line"></span><br><span class="line">s = select([cookies.c.cookie_name, cookies.c.quantity])</span><br><span class="line">s = s.order_by(desc(cookies.c.quantity))  <span class="comment"># 使用desc()对cookies.c.quantity列进行了包装</span></span><br><span class="line"><span class="comment"># 使用print(s)直接打印，或者使用print(str(s))可以看到对应的sql语句为 SELECT cookies.cookie_name, cookies.quantity FROM cookies ORDER BY cookies.cookie_name DESC</span></span><br><span class="line">rp = connection.execute(s)</span><br></pre></td></tr></table></figure><p>除了调用 <code>desc()</code> 函数，<code>desc()</code> 还可以作为Column对象的方法进行调用，像这样<code>cookies.c.quantity.desc()</code>，但是如果在长语句中这样使用，可能会造成阅读困难，所以建议将<code>desc()</code>作为函数进行使用。</p><blockquote><p>提示：所有的操作语句在都可以通过直接打印的方式查看到对应的 SQL 语句。</p></blockquote><h5 id="对返回数据的结果条数进行限制"><a class="header-anchor" href="#对返回数据的结果条数进行限制">¶</a>对返回数据的结果条数进行限制</h5><p>虽然可以对 ResultProxy 使用 <code>first()</code> 和 <code>fetchone()</code> 获得一行数据，但是实际查询了所有的记录，使用 <code>limit()</code> 方法让 limit语句 成为查询的一部分，对查询的记录的条数进行限制。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询两种库存量最少的cookies</span></span><br><span class="line">s = select([cookies.c.cookie_name, cookies.c.quantity])</span><br><span class="line">s = s.order_by(cookies.c.quantity)</span><br><span class="line">s = s.limit(<span class="number">2</span>)  <span class="comment"># 和 order_by 一样，都是Select自带的，不需要导包</span></span><br><span class="line">rp = connection.execute(s)</span><br><span class="line">print(rp.fetchall())  <span class="comment"># [('dack chocolate chip', 1), ('chocolate chip', 12)]</span></span><br><span class="line">print([result.cookie_name <span class="keyword">for</span> result <span class="keyword">in</span> rp])  <span class="comment"># [] 此时为空，是查不到数据的，因为之前使用 fetchall() 已经返回了所有的数据了</span></span><br></pre></td></tr></table></figure><blockquote><p>注意最后一行，想再次从 ResultProxy 对象中获得数据的时候，发现获取不到了，这是因为 <a href="#ResultProxy">ResultProxy</a> 对象是DBAPI游标对象的包装器，游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。游标充当指针的作用，ResultProxy 对象在被使用一次后，会记录位置。</p></blockquote><h5 id="内置SQL函数和标签"><a class="header-anchor" href="#内置SQL函数和标签">¶</a>内置SQL函数和标签</h5><p>许多数据库设计都包含了 SQL 函数，这些函数的设计目的是为了让某些操作可以直接在数据库服务器上使用，如 SUM 函数，SqlAlchemy可以利用后端数据库中的 SQL 函数，常见的函数为 SUM 以及 COUNT，想使用这两个函数，需要导入 <code>sqlalchemy.sql.func</code> 模块，这些函数包装在他们要操作的列上。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算cookie的总数</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.sql <span class="keyword">import</span> func</span><br><span class="line"></span><br><span class="line">s = select([func.sum(cookies.c.quantity)]) </span><br><span class="line">print(s)  <span class="comment"># SELECT sum(cookies.quantity) AS sum_1 FROM cookies</span></span><br><span class="line">rp = connection.execute(s)</span><br><span class="line">print(rp.scalar())  <span class="comment"># scalar只返回查询到的第一个数据的最左边的列，且只返回第一行的数据</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>建议使用导入 func 模块的方式，因为直接导入 sum 可以会引起问题，而且还容易和Python内置的sum函数混淆</strong></p></blockquote><p>count 计数<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = select([func.count(cookies.c.cookie_name)])</span><br><span class="line">print(s)  <span class="comment"># SELECT count(cookies.cookie_name) AS count_1 FROM cookies</span></span><br><span class="line">rp = connection.execute(s)</span><br><span class="line">recode = rp.first()  <span class="comment"># 数据类型为RowProxy，代表查询到的一行数据，若直接打印</span></span><br><span class="line">print(type(recode))  <span class="comment"># &lt;class 'sqlalchemy.engine.result.RowProxy'&gt;，但是直接打印的话就是一行数据，以元组的形式打印的</span></span><br><span class="line">print(recode.keys())  <span class="comment"># 以列表的形式返回查找的数据的各列名组成的列表</span></span><br><span class="line">print(recode.count_1)  <span class="comment"># 使用 count_1 是调用count默认的列名</span></span><br></pre></td></tr></table></figure><p>RequestProxy 和 RowProxy 类型都可以调用keys()方法，用来返回列名<br>print(recode.count_1)是以列名的形式打印内容的，因为使用使用COUNT和SUM方法都会以<code>&lt;func_name&gt;_&lt;position&gt;</code>的形式起别名，position是调用COUNT和SUM方法的次数，如第二个调用的count()函数得到的别名将是count_2。但是这样的命名方式实在不够明确，SQLAlchemy提供了 <code>label()</code> 函数来解决这个问题，可以使用 <code>label()</code> 函数来为列取个别名。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = select([func.count(cookies.c.cookie_name).label(<span class="string">'inventory_count'</span>)])</span><br><span class="line">print(s)  <span class="comment"># SELECT count(cookies.cookie_name) AS inventory_count FROM cookies</span></span><br><span class="line">rp = connection.execute(s)</span><br><span class="line">print(rp.first().keys())  <span class="comment"># ['inventory_count']</span></span><br></pre></td></tr></table></figure><p>只需要在更改的列对象上调用 <code>label()</code> 函数即可，这意味着，我们在查找原有列名时，也可以对返回的列取别名，像这样 <code>s = select([cookies.c.cookie_name.label('cookie_name_count')])</code>。</p><blockquote><p><strong>除了 fitchall 得到的是 list 类型，其他的方法得到的行数据都是 RowProxy 类型的单个数据，当然 fitchall()得到的是行数据的集合，所以列表中的每一项都是 RowProxy 类型的数据。</strong></p></blockquote><h5 id="过滤"><a class="header-anchor" href="#过滤">¶</a>过滤</h5><p>对查询进行过滤是通过 <code>where()</code> 语句来完成，可以把多个 where()子句 接在一起使用，功能就像传统的 SQL 语句中的 AND 一样。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = select([cookies]).where(cookies.c.cookie_name == <span class="string">"chocolate chip"</span>)</span><br><span class="line">print(s)  <span class="comment"># SELECT cookies.cookie_id, cookies.cookie_name, cookies.cookie_recipe_url, cookies.cookie_sku, cookies.quantity, cookies.unit_cost FROM cookies WHERE cookies.cookie_name = :cookie_name_1</span></span><br><span class="line">print(s.compile().params)  <span class="comment"># 查询发送的实际参数</span></span><br><span class="line">rp = connection.execute(s)  </span><br><span class="line">recode = rp.first()</span><br><span class="line">print(type(recode))</span><br><span class="line">print(recode.items())  <span class="comment"># [('cookie_id', 5), ('cookie_name', 'chocolate chip'), ('cookie_recipe_url', 'http://xxx'), ('cookie_sku', 'CC01'), ('quantity', 12), ('unit_cost', Decimal('0.50'))]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：RowProxy 对象的 items() 方法返回得到由列名和值组成的元组列表，注意是记录对象 RowProxy 含有该方法，而不是 RequestProxy。</p></blockquote><p>使用 <code>like</code> 方法进行模糊查询<br>示例：查询包含 chocolate 的 cookie 名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = select([cookies]).where(cookies.c.cookie_name.like(<span class="string">'%chocolate%'</span>))</span><br><span class="line">print(s)  <span class="comment"># SELECT cookies.cookie_id, cookies.cookie_name, cookies.cookie_recipe_url, cookies.cookie_sku, cookies.quantity, cookies.unit_cost FROM cookies WHERE cookies.cookie_name LIKE :cookie_name_1</span></span><br></pre></td></tr></table></figure><h6 id="ClauseElement"><a class="header-anchor" href="#ClauseElement">¶</a>ClauseElement</h6><p><code>ClauseElement</code> 是在子句中使用的实体，一般是表中的列。不过，与列不同的是ClauseElement拥有许多额外的功能，如之前我们调用的like()方法，此外还有许多额外的方法。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">between(cleft, cright)</td><td style="text-align:left">查找cleft和cright之间的内容</td></tr><tr><td style="text-align:left">concat(column_two)</td><td style="text-align:left">连接列</td></tr><tr><td style="text-align:left">destinct()</td><td style="text-align:left">查找列的唯一值</td></tr><tr><td style="text-align:left">in_([list])</td><td style="text-align:left">查找列在列表中的位置</td></tr><tr><td style="text-align:left">is_(None)</td><td style="text-align:left">查找列None的位置（通常用于检查Null和None）</td></tr><tr><td style="text-align:left">contains(string)</td><td style="text-align:left">查找包含string的列（区分大小写）</td></tr><tr><td style="text-align:left">endswith(string)</td><td style="text-align:left">查找以string结尾的列（区分大小写）</td></tr><tr><td style="text-align:left">like(string)</td><td style="text-align:left">查找与string匹配的列（区分大小写）</td></tr><tr><td style="text-align:left">startwith(string)</td><td style="text-align:left">查找以string开头的列（区分大小写）</td></tr><tr><td style="text-align:left">ilike(string)</td><td style="text-align:left">查找与string匹配的列（不区分大小写）</td></tr></tbody></table><blockquote><p>以上这些方法都有相反的方法，例如 notlike() 和 notin_()。not&lt;方法&gt; 这种命名方式约定的唯一例外是不带下划线的 isnot() 方法。</p></blockquote><h6 id="运算符"><a class="header-anchor" href="#运算符">¶</a>运算符</h6><p>除了 ClauseElement 中的这些方法之外，还可以在 where() 语句中使用运算符，SQLAlchemy 针对大多数的Python运算符都做了重载，包括标准的比较运算符<code>（==、！=、&lt;、&gt;、&lt;=、=&gt;）</code>，他们的功能和在Python中一样。在与None比较时，==被重载为IS NULL语句。算数运算符<code>（+、-、*、/和%）</code>还可以用来独立于数据库的字符串做连接处理。</p><p>使用+连接字符串<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s = select([cookies.c.cookie_name, <span class="string">'SKU-'</span> + cookies.c.cookie_sku])</span><br><span class="line">print(s)  <span class="comment"># SELECT cookies.cookie_name, :cookie_sku_1 || cookies.cookie_sku AS anon_1 FROM cookies</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> connection.execute(s):</span><br><span class="line">    print(row)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">('chocolate chip', 'SKU-CC01')</span></span><br><span class="line"><span class="string">('dack chocolate chip', 'SKU-CC02')</span></span><br><span class="line"><span class="string">('peanut butter', 'SKU-PB01')</span></span><br><span class="line"><span class="string">('oatmeal raisin', 'SKU-EWW01')</span></span><br><span class="line"><span class="string">('chocolate chip', 'SKU-CC01')</span></span><br><span class="line"><span class="string">('peanut butter', 'SKU-PB01')</span></span><br><span class="line"><span class="string">('oatmeal raisin', 'SKU-EWW01')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">rp =  connection.execute(s)</span><br><span class="line">print(rp.keys())  <span class="comment"># ['cookie_name', 'anon_1']</span></span><br></pre></td></tr></table></figure><p>运算符的另外一种用法是根据多个列来计算值<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算各种cookie的库存价值</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> cast, Numeric</span><br><span class="line">s = select([cookies.c.cookie_name,</span><br><span class="line">        cast((cookies.c.quantity * cookies.c.unit_cost),</span><br><span class="line">        Numeric(<span class="number">12</span>,<span class="number">1</span>)).label(<span class="string">'inv_cost'</span>)])</span><br><span class="line">print(s)  <span class="comment"># SELECT cookies.cookie_name, CAST(cookies.quantity * cookies.unit_cost AS NUMERIC(12,1)) AS inv_cost FROM cookies</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> connection.execute(s):</span><br><span class="line">    print(<span class="string">"&#123;&#125; - &#123;&#125;"</span>.format(row.cookie_name, row.inv_cost))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">chocolate chip - 6.0</span></span><br><span class="line"><span class="string">dack chocolate chip - 0.8</span></span><br><span class="line"><span class="string">peanut butter - 6.0</span></span><br><span class="line"><span class="string">oatmeal raisin - 100.0</span></span><br><span class="line"><span class="string">chocolate chip - 6.0</span></span><br><span class="line"><span class="string">peanut butter - 6.0</span></span><br><span class="line"><span class="string">oatmeal raisin - 100.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>cast() 是另一个允许做类型转换的函数，使用方式是 cast(数据,转换类型)，这里如果不使用 cast，也是可以获得相应的数据的，此时我们可以在 python 语句中对数据类型进行强制转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"&#123;&#125; - &#123;:.2f&#125;"</span>.format(row.cookie_name, row.inv_cost))</span><br></pre></td></tr></table></figure><p>区别是前者直接在查询返回结果时就进行了格式化，而后者需要打印时手动完成转换。</p><h6 id="布尔运算符"><a class="header-anchor" href="#布尔运算符">¶</a>布尔运算符</h6><p>SQLAlchemy 还支持布尔运算符 AND、OR 和 NOT，他们用位运算符（&amp;、|和~）来表示。受Python运算符优先级规则的影响，应当尽量使用下面的连接词，而不要使用这些重载的运算符。</p><h6 id="连接词"><a class="header-anchor" href="#连接词">¶</a>连接词</h6><p><code>and_()</code>、<code>or_()</code>、<code>not_()</code>。为了实现某种期望的效果，我们既可以把多个where()子句连接在一起，也可以使用连接词来实现，而且使用连接词的可读性更好，功能性更强。<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_,or_,not_</span><br><span class="line"></span><br><span class="line">s = select([cookies]).where(</span><br><span class="line">    and_(cookies.c.quantity &gt; <span class="number">23</span>,</span><br><span class="line">        cookies.c.unit_cost &lt; <span class="number">0.40</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># 等价的版本（使用布尔运算符--注意优先级，因为优先级的关系，内部的单个条件需要加上括号以白表明优先级）</span></span><br><span class="line"><span class="string">s = select([cookies]).where(</span></span><br><span class="line"><span class="string">    (cookies.c.quantity &gt; 23) &amp;</span></span><br><span class="line"><span class="string">        (cookies.c.unit_cost &lt; 0.40)</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(s)  <span class="comment"># SELECT cookies.cookie_id, cookies.cookie_name, cookies.cookie_recipe_url, cookies.cookie_sku, cookies.quantity, cookies.unit_cost FROM cookies WHERE cookies.quantity &gt; :quantity_1 AND cookies.unit_cost &lt; :unit_cost_1 </span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> connection.execute(s):</span><br><span class="line">    print(row.cookie_name)</span><br></pre></td></tr></table></figure><h6 id="复杂过滤"><a class="header-anchor" href="#复杂过滤">¶</a>复杂过滤</h6><p>连接词 配合 ClauseElement 使用，实现复杂查询<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = select([cookies]).where(</span><br><span class="line">    or_(</span><br><span class="line">        cookies.c.quantity.between(<span class="number">10</span>,<span class="number">50</span>),</span><br><span class="line">        cookies.c.cookie_name.contains(<span class="string">'chip'</span>)  <span class="comment"># 查询包含'chip'的项</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>未完待续 …</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> SqlAlchemy </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> SqlAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 回顾</title>
      <link href="2020/02/10/MySQL-%E5%9B%9E%E9%A1%BE/"/>
      <url>2020/02/10/MySQL-%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a class="header-anchor" href="#创建数据库">¶</a>创建数据库</h2><p><code>CREATE DATABASE 数据库名</code>即可创建相应的数据库，命令不限定大小写，注意在创建含有特殊字符的数据库名的数据库的时候，需要使用反标记字符 (`) 用于引用标识符，数据表名同理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database `my.contacts`</span><br></pre></td></tr></table></figure><p>可以在连接数据库的同时就指定要连接的数据库，如 <code>mysql -uroot -p 数据库名</code>，这样一连接上就进入了该数据库。</p><p>进入mysql后，使用 <code>use 数据库名</code>，进入和切换相应的数据库，使用 <code>SELECT DATABASE();</code> 可以查看当前进入的数据库是哪个，注意需要添加分号。</p><p>数据库被创建为数据目录中的一个目录，使用 <code>SHOW VARIABLES LIKE 'datadir';</code> ，可以查看到该目录所在的文件夹位置。</p><h2 id="创建表"><a class="header-anchor" href="#创建表">¶</a>创建表</h2><p>在表定义的时候，应该指定列的名称、数据类型（整型、浮点型、字符串等）和默认值（如果有的话）。</p><p>mysql支持的类型:</p><ul><li>数字：tinyint、smallint、mediumint、int、bigint 和 big</li><li>浮点型： decimal、float和double</li><li>字符串： char、varchar、binary、varbinary、blob、text、enum 和 set</li><li>spatial数据类型</li><li>json数据类型</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;company&#96;.&#96;customers&#96; (</span><br><span class="line">    &#96;id&#96; int unsigned AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    &#96;first_name&#96; varchar(20),</span><br><span class="line">    &#96;last_name&#96; varchar(20),</span><br><span class="line">    &#96;country&#96; varchar(20)    </span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>解释：<br>句点符号：表可以使用 database.table 的形式来引用，如果使用use进入到了该database下，则可以直接使用table。<br><code>IF NOT EXISTS</code>: 若在创建表的时候已经存在了一个同名的数据表，则指定了IF NOT EXISTS的情况下，只会抛出一个警告，否则若不指定，则报异常。<br><code>ENGINE</code>：用于指定创建表的数据引擎。InnoDB是唯一的事务引擎，也是默认引擎。<br><font color="red">注意： 最后一个value后不能有逗号</font></p><h3 id="可以在同一的数据库中创建多个表"><a class="header-anchor" href="#可以在同一的数据库中创建多个表">¶</a>可以在同一的数据库中创建多个表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE payments (</span><br><span class="line">    &#96;customer_name&#96; varchar(20) PRIMARY KEY,</span><br><span class="line">    &#96;payment&#96; float</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="列出所有的表"><a class="header-anchor" href="#列出所有的表">¶</a>列出所有的表</h3><p>使用 <code>SHOW TABLES</code></p><h3 id="查看表结构"><a class="header-anchor" href="#查看表结构">¶</a>查看表结构</h3><p><code>SHOW CREATE TABLE 表名\G</code></p><p><code>DESC 表名</code></p><p>创建表后，MySQL会在数据库目录内创建相应的<code>.ibd文件</code>，使用<code>SHOW VARIABLES LIKE 'datadir'</code>，可以查看到该目录所在的文件夹位置。</p><p>克隆表结构（创建一个和已有的表具有相同结构的表）：<code>CREATE TABLE 新表名 LIKE 已存在的表的表名</code></p><h2 id="操作数据库"><a class="header-anchor" href="#操作数据库">¶</a>操作数据库</h2><h3 id="插入"><a class="header-anchor" href="#插入">¶</a>插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO &#96;company&#96;.&#96;customers&#96; (first_name, last_name, country) </span><br><span class="line">VALUES</span><br><span class="line">(&#39;Mike&#39;, &#39;Christensen&#39;, &#39;USA&#39;),</span><br><span class="line">(&#39;Andy&#39;, &#39;Hollands&#39;, &#39;Australia&#39;),</span><br><span class="line">(&#39;Ravi&#39;, &#39;Vedantam&#39;, &#39;India&#39;),</span><br><span class="line">(&#39;Rajiv&#39;, &#39;Perera&#39;, &#39;Sri Lanka&#39;);</span><br></pre></td></tr></table></figure><p>解释：<br>IGNORE： 如果该行已经存在，此时加入了IGNORE,新添加的数据将被忽略，且INSERT操作被显示为成功，同时生成一个警告和重复数据的数目，否则报错。<br>若插入的是完整的数据内容，即不使用自增的值和默认值的话，可以不写(first_name, last_name, country)</p><h3 id="更新"><a class="header-anchor" href="#更新">¶</a>更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers SET first_name&#x3D;&#39;Rajiv&#39;, country&#x3D;&#39;UK&#39; WHERE id&#x3D;4;</span><br></pre></td></tr></table></figure><p>解释：<br>WHERE:这是用于过滤的字句。用于筛选出特定的数据。若不添加，则默认更改所有的数据。<br><strong>WHERE字句是强制性的。建议在事务中修改数据，以便在发现任何错误的时候轻松的回滚这些更改</strong></p><h3 id="删除"><a class="header-anchor" href="#删除">¶</a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM customers WHERE id&#x3D;4 AND first_name&#x3D;&#39;Rajiv&#39;;</span><br></pre></td></tr></table></figure><p>解释：<br><strong>WHERE字句是强制性的，若没有WHERE，则会删除表中所有的数据，建议在事务中修改数据，以便在发现任何错误的时候轻松的回滚这些更改</strong></p><h3 id="REPLACE、INSERT和ON-DUPLICATE-KEY-UPDATE"><a class="header-anchor" href="#REPLACE、INSERT和ON-DUPLICATE-KEY-UPDATE">¶</a>REPLACE、INSERT和ON DUPLICATE KEY UPDATE</h3><ul><li><p>在很多情况下，我们需要处理重复项。行的唯一性有主键标识。如果行已经存在，则REPLACE会简单地删除行并重新插入新行；如果该行不存在，则此时的REPLACE等同于INSERT。<br>使用REPLACE在插入重复项（主键是不能重复的）的时候，会显示更新了两行，这是因为，先删除了原先的记录，又添加了新的记录，所以显示改变了两行。</p></li><li><p>如果想在行已经存在的情况下处理重复项，则需要使用ON DUPLICATE KEY UPDATE。如果指定了ON DUPLICATE KEY UPDATE选项，并且INSERT语句在PRIMARY KEY中引发了重复值，则MySQL会用新值更新已有行。<br>使用场景（类似于update操作，但是是以插入数据的形式进行的）</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO payments VALUES ('Mike Christensen', 200) ON DUPLICATE KEY UPDATE payment=payment+VALUES(payment);</span><br><span class="line">INSERT INTO payments VALUES ('Mike Christensen', 300) ON DUPLICATE KEY UPDATE payment=payment+VALUES(payment);</span><br></pre></td></tr></table></figure><p>解释：<br>第一条语句直接在表中创建了一条新的数据，执行第二条语句时会发现customer_name这一项的值重复了，此时ON DUPLICATE KEY UPDATE就会生效，会覆盖原有的值，相当于对数据进行了更新，此时值应该是500。同时，我们发现显示修改了两条数据，这是因为，先删除了原先的记录，又添加了新的记录，所以显示改变了两行。<br>VALUES(payment)代表的是INSERT语句给的值，而payment是表中的列的值。</p><h3 id="TRUNCATE-TABLE"><a class="header-anchor" href="#TRUNCATE-TABLE">¶</a>TRUNCATE TABLE</h3><pre><code>* 删除整个表需要很长时间，因为MySQL需要逐行执行操作。删除表中的所有行（保留表结构）的最快方法是使用TRUNCATING TABLE语句。`TRUNCATE TABLE 表名`，是DDL操作，一旦数据被清楚，不能回滚。</code></pre><h3 id="查询"><a class="header-anchor" href="#查询">¶</a>查询</h3><h4 id="操作符"><a class="header-anchor" href="#操作符">¶</a>操作符</h4><p>mysql支持许多操作符来筛选结果。</p><ul><li>equality:</li><li>IN:检查一个值是否再一组值内：找出姓氏为Christ和Lamba的所有员工数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select COUNT(*) from employees where last_name in ('christ','Lamba');</span><br></pre></td></tr></table></figure><ul><li>BETWEEN AND: 找出1986年12月入职的员工数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select COUNT(*) FROM employees WHERE hire_date BETWEEN '1986-12-01' AND '1976-12-31';</span><br></pre></td></tr></table></figure><ul><li>NOT：否定结果，找出不是在1986年12月入职的员工数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select COUNT(*) FROM employees WHERE hire_date NOT BETWEEN '1986-12-01' AND '1976-12-31';</span><br></pre></td></tr></table></figure><h4 id="简单模式匹配"><a class="header-anchor" href="#简单模式匹配">¶</a>简单模式匹配</h4><p>可以使用LIKE运算符来是实现简单的模式匹配。使用下划线 <code>_</code> 来精准匹配一个字符，使用 <code>%</code> 来匹配任意数量的字符。</p><ul><li>找出名字以Christ开头的所有员工总数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from employees where first_name like 'christ%';</span><br></pre></td></tr></table></figure><ul><li>找出名字以Christ开头并以ed结尾的所有员工总数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from employees where first_name like 'christ%ed';</span><br></pre></td></tr></table></figure><ul><li>找出名字中包含str的所有员工的数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from employees where first_name like '%str%'</span><br></pre></td></tr></table></figure><ul><li>找出名字中以ser的所有员工的数: <code>%er</code></li><li>以任意两个字符开头、后面跟随ka、再后面跟随任意数字符的所有员工数：<code>like '__ka%'</code></li></ul><h4 id="正则表达式"><a class="header-anchor" href="#正则表达式">¶</a>正则表达式</h4><p>可以利用 RLIKE 或 REGEXP 运算符在 WHERE 子句中使用正则表达式。（RLIKE和REGEXP使用方法一样，即可以相互替代）</p><ul><li>查找出姓氏以ba结尾的所有员工数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from employees where last_name rlike 'ba$';</span><br></pre></td></tr></table></figure><ul><li>查找姓氏不包含元音（a、e、i、o和u）的所有员工的人数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from employees where last_name not regexp '[aeiou]';</span><br></pre></td></tr></table></figure><h4 id="限定结果"><a class="header-anchor" href="#限定结果">¶</a>限定结果</h4><p>使用limit来进行设置</p><ul><li>查询hire_data在1986年之前的任何10名员工的姓名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name, last_name from employees where hire_data &lt; '1996-01-01' limit 10;</span><br></pre></td></tr></table></figure><h4 id="使用表别名"><a class="header-anchor" href="#使用表别名">¶</a>使用表别名</h4><p>使用AS来设置别名</p><ul><li>对COUNT(*)使用AS来设置别名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) AS count from employees;</span><br></pre></td></tr></table></figure><h4 id="对结果进行排序"><a class="header-anchor" href="#对结果进行排序">¶</a>对结果进行排序</h4><p>对结果进行排序（order by），可以根据列或者别名对结果进行排序，也可以用DESC指定按降序或用ASC指定升序来排序。默认情况下，按照升序排序。可以将 limit 子句与 ordery by 结合使用以限定结果集。</p><ul><li>查找薪水最高的前5名员工的编号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary from salaries order by salary limit 6;</span><br></pre></td></tr></table></figure><ul><li>若想降序，则使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary from salaries order by salary desc limit 6;</span><br></pre></td></tr></table></figure><ul><li>也可以通过指定要进行排序的列所有表中的位置进行指定，如本次排序的salary列在表中的位置为2</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary from salaries order by 2 limit 6;</span><br></pre></td></tr></table></figure><h4 id="对结果进行分组（聚合函数）"><a class="header-anchor" href="#对结果进行分组（聚合函数）">¶</a>对结果进行分组（聚合函数）</h4><p>可以使用 group by 子句对结果进行分组，然后使用 AGGREGATE（聚合函数），如 COUNT、MAX、MIN 和 AVERAGE。还可以在 group by 子句的列上使用函数。</p><ul><li>分别找出男性和女性员工的人数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select gender, count(gender) as count from employees group by gender;</span><br></pre></td></tr></table></figure><ul><li>找出员工名字（first_name）中最常见的10个名字</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name, count(*) as count  from employees group by first_name order by count  desc limit 10;</span><br></pre></td></tr></table></figure><ul><li>查找每年给予员工的薪水总额</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select year(from_date), sum(salary) as sum from salaries group by year(from_date) order by sum desc;</span><br></pre></td></tr></table></figure><p>分析，这句查询实际上是按照from_date字段进行查询的，只是使用了year()函数，将每个全日期显示为年份。</p><ul><li>查找平均工资最高的10名员工</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, avg(salary) as avg from salaries group by emp_no order by avg desc limit 10;</span><br></pre></td></tr></table></figure><ul><li>可以使用 DISTINCT 过滤掉相同的数据，如过滤掉不同的书籍</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct title from titles;</span><br></pre></td></tr></table></figure><p>相同效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from titles group by title;</span><br></pre></td></tr></table></figure><ul><li>使用 HAVING 过滤，可以通过添加 HAVING 子句来过滤 GROUP BY 子句的结果，如找到平均工资超过140000美元的员工</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, avg(salary) as avg from salaries group by emp_no having avg &gt;140000 order by avg desc;</span><br></pre></td></tr></table></figure><p>可以发现 having 和 where 的区别在于：where是对select的范围进行过滤，过滤的是查询的范围，而 having 是对查询到的结果进行过滤，过滤的是查询到的结果。</p><h2 id="权限管理"><a class="header-anchor" href="#权限管理">¶</a>权限管理</h2><h3 id="创建用户"><a class="header-anchor" href="#创建用户">¶</a>创建用户</h3><p>事实上不应该使用 root 用户连接到 mysql 并执行语句，除非是 localhost 的管理任务。我们应该创建用户，限制访问，限制资源使用等等。创建用户需要拥有 CREATE USER 权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 root 连接到 mysql 并执行 create user 命令来创建新用户</span></span><br><span class="line">CREATE USER IF NOT EXISTS <span class="string">'company_read_only'</span>@<span class="string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'company_pass'</span> WITH MAX_QUERIES_PER_HOUR 500 MAX_UPDATES_FER_HOUR 100;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>用户名：company_read_only</li><li>仅从localhost访问，可以限制对IP范围的访问，例如10.148.%.%。通过给出%，用户可以从任何主机访问。</li><li>密码：company_pass</li><li>使用mysql_native_password（默认）身份验证，还可以指定任何可选的身份验证，例如sha256_password、LDAP 或 Kerberos。</li><li>用户可以在一小时内执行的最大查询数为500。</li><li>用户可以在一小时内执行的最大更新次数为100次。</li></ul><h4 id="密码策略修改"><a class="header-anchor" href="#密码策略修改">¶</a>密码策略修改</h4><p>由于mysql8密码策略的问题，导致简单的密码是不能通过验证的，下面我们通过修改密码验证的策略，使其能够使用简单的密码进行登录验证。</p><ol><li>查看密码的验证策略：<code>show variables like 'validate_password%'</code>进行查看。<br><img src="https://i.loli.net/2019/12/10/n9UYL5kAVdH7ozS.png" alt="select_valiables_new.png"></li><li>首先设置密码的验证强度等级，设置 validate_password_policy 的全局参数为LOW即可，设置语句为 <code>set global validate_password_policy=LOW;</code> 进行设置。</li><li>使用类似的方法还可以设置密码的长度，但是默认最短不能低于4，所以一旦低于4，也是会默认为4的。<br><img src="https://i.loli.net/2019/12/10/hw8V2rkCyapLAjK.png" alt="shezhinew.png"></li><li>设置好后的效果，修改了密码验证的等级为 LOW，修改了要求的特殊字符数为0。<br><br><img src="https://i.loli.net/2019/12/10/43uKkIWXbBcZd8R.png" alt="select_variables.png"></li></ol><p>关于 mysql 密码策略相关参数：</p><ol><li>validate_password.length  固定密码的总长度；</li><li>validate_password.dictionary_file 指定密码验证的文件路径；</li><li>validate_password.mixed_case_count  整个密码中至少要包含大/小写字母的总个数；</li><li>validate_password.number_count  整个密码中至少要包含阿拉伯数字的个数；</li><li>validate_password.policy 指定密码的强度验证等级，默认为 MEDIUM；<br>关于 validate_password_policy 的取值：<ul><li>LOW：只验证长度；</li><li>MEDIUM：验证长度、数字、大小写、特殊字符；</li><li>STRONG：验证长度、数字、大小写、特殊字符、字典文件；</li></ul></li><li>validate_password.special_char_count 整个密码中至少要包含特殊字符的个数；</li></ol><h3 id="授予和撤销用户的访问权限"><a class="header-anchor" href="#授予和撤销用户的访问权限">¶</a>授予和撤销用户的访问权限</h3><p>可以限制用户的访问特定数据库或表，或限制特定操作，如 SELECT、 INSERT 和 UPDATE。需要拥有 GRANT 权限，才能为其他用户授予权限。<br>如何做： 可以通过root用户来授予权限，同时还可以创建管理员账户来管理用户。</p><ul><li>将 READ ONLY（只读权限SELECT）权限授予刚刚创建的company_read_only用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on company.* to <span class="string">'company_read_only'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><p>该语句表示将对数据库 company 及其所有的表对本地访问的名为 <code>company_read_only</code>的用户授予查询的权限</p><ul><li>将INSERT权限授予新的company_insert_only用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grent insert on company.* to <span class="string">'company_insert_only'</span>@<span class="string">'localhost'</span> indentified by <span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure><p>该语句在授予权限的时候同时创建新的用户。普通的创建用户的语句格式为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user <span class="string">"username"</span>@<span class="string">"host"</span> identified by <span class="string">"password"</span>;</span><br></pre></td></tr></table></figure><ul><li>将WRITE（即写权限，INSERT、UPDATE和DELETE）权限授予新建的 company_write 用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant insert, delete, update on company.* to <span class="string">'company_write'</span>@<span class="string">'%'</span> identified with mysql_native_password by <span class="string">'xxxx'</span>;</span><br></pre></td></tr></table></figure><ul><li>限制查询指定的表。将 employees_read_only 用户限制为仅能查询employees表</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on employees.employees to <span class="string">'employees_read_only'</span>@<span class="string">'%'</span> identified with mysql_native_password by <span class="string">'xxxx'</span>;</span><br></pre></td></tr></table></figure><ul><li>可以进一步将访问权限设置为仅能查询指定列。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select(first_name, last_name) on employees.employees to <span class="string">'employees_read_only'</span>@<span class="string">'%'</span> identified with mysql_native_password by <span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在以上的语句在授予权限的同时都是创建新的用户，但是这是不被推荐的，在8.0.18版本已经不能这样使用了，推荐用法是先创建用户，再赋予权限。</p></blockquote><ul><li>扩展授权。可以通过执行新授权来扩展授权。将权限扩展到employees_col_ro用户，以访问薪资（salaries）表中的薪水</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select(salary) on employees.salaries to <span class="string">'employees_ro'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><ul><li>创建SUPER用户。需要一个管理员账户来管理该服务器。ALL表示出了GRANT权限之外的所有权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user <span class="string">'dbadmin'</span>@<span class="string">'%'</span> identified with mysql_native_password by <span class="string">'DB@adln'</span>;</span><br></pre></td></tr></table></figure><p>赋予权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on *.* to <span class="string">'dbadmin'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><ul><li>授予 GRENT 权限，用户拥有 GRANT OPTION 权限才能授予其他用户权限。可以将 GRENT 特权扩展到 dbadmin 超级用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant grant option on *.* to <span class="string">'dbadmin'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><p>注意权限的全称为<code>grant option</code>。</p><p>总结：授予权限使用的关键字是<code>grant</code>，必须指明权限能访问的数据库和表<code>on 数据库.表</code>，必须指明授权的对象<code>to 用户</code>。</p><h4 id="检查权限"><a class="header-anchor" href="#检查权限">¶</a>检查权限</h4><p>检查所有用户的授权。检查employee_col_ro用户的授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants <span class="keyword">for</span> <span class="string">'employee_col_ro'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><h4 id="撤销权限"><a class="header-anchor" href="#撤销权限">¶</a>撤销权限</h4><p>撤销’company_write’@‘%’用户的DETELE访问权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke delete on company.* from <span class="string">'company_write'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><p>撤销employee_ro用户对薪水列的访问权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke select(salary) on employees.salaries from <span class="string">'employees_ro'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><h4 id="修改mysql-user表"><a class="header-anchor" href="#修改mysql-user表">¶</a>修改mysql.user表</h4><p>所有用户的信息以及权限都存储在mysql.user表中，如果你有权访问mysql.user表，则可以直接通过修改mysql.user表来创建用户并授予权限。<br>如果你使用GRANT、REVOKE、SET PASSWORD和RENAME USER等账户管理语句间接修改授权表，则服务器会通知这些更改，并立即再次将授权表加载到内存中。<br>如果使用的是INSERT、UPDATE或者DELETE等语句直接修改授权表，则更改不会影响权限检查，除非重新启动服务器或指示其重新加载表。如果直接更改授权表，当忘记了重新加载表，那么在重新启动服务器之前，这些更改无效。<br>可以使用查询语句进行查询mysql表，可看到某个用户的具体权限的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mysql.user <span class="built_in">where</span> user=<span class="string">'dbadmin'</span>/G;</span><br></pre></td></tr></table></figure><p>使用update即可对权限进行更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user <span class="built_in">set</span> host=<span class="string">'localhost'</span> <span class="built_in">where</span> user=<span class="string">'dbadmin'</span>;</span><br></pre></td></tr></table></figure><p>因为是对mysql表进行操作的，所以想要立即生效，必须使用 <code>flush privileges;</code> 使其立即生效。</p><h4 id="设置用户密码的有效期"><a class="header-anchor" href="#设置用户密码的有效期">¶</a>设置用户密码的有效期</h4><p>可以设置一段时间作为用户密码的有效期，当有效期过后用户需要修改密码</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之面向接口</title>
      <link href="2020/01/30/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
      <url>2020/01/30/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1>面向接口</h1><p>golang是一门面向接口的语言，没有传统的继承和多态，golang的面向对象仅支持封装（通过定义结构实现，type struct_name struct），而继承和多态是通过接口来实现的。所以golang的接口要比其他语言灵活的多。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Traversal <span class="keyword">interface</span> &#123;</span><br><span class="line">  Traverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  traversal := getTraversl()</span><br><span class="line">  traversal.Traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>duck typing</p><ul><li>描述事物的外部行为而非内部结构</li><li>严格说go属于结构化类型系统，类似duck typing</li></ul><p>Go中的duck typing</p><ul><li>同时能实现多个接口</li><li>同时具有python, c++的duck typing的灵活性 — 只要实现了某个方法，就能被调用</li><li>又具有Java的类型检查 — 不是动态语言的运行时检查，也不是静态语言的编译时才检查，而是在实现代码的过程中就知道必须要</li></ul><h3 id="接口的定义"><a class="header-anchor" href="#接口的定义">¶</a>接口的定义</h3><ul><li><p>接口由使用者定义，而非传统的为某个被调用者实现某个方法，告诉其他调用者，我实现了该方法，你们可以调用我。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(url <span class="keyword">string</span>) <span class="keyword">string</span>   <span class="comment">// 注意：interface中定义函数不需要使用func关键字，会自动识别为函数，因为interface内部本身都是函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Get(<span class="string">"www.xxx.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上为接口的定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r Retriever    <span class="comment">// 此处的Retriever是上面的接口对象</span></span><br><span class="line">r = mock.Retriever&#123;<span class="string">"this is a fack xxx.com"</span>&#125; <span class="comment">// 此处可见，接口类型变量可以接受其实现类型的变量</span></span><br><span class="line">fmt.Println(download(r))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock包中定义实现接口的方法</span></span><br><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;      <span class="comment">// 注意，结构名要大写，因为是要在本包外被调用</span></span><br><span class="line">Contents <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Contents</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上为接口的实现</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2><ul><li><p>接口的实现是隐式的</p></li><li><p>只要实现接口里的方法，不需要指明说 我是实现了某个接口，只要实现了接口的（全部）方法即可</p><p>上面的例子中，定义了含有Get方法的接口，并定义了一个使用该接口类型（Retriever类型）的函数，在该函数中调用了接口定义的Get方法</p><p>实现接口的时候，只要实现了该接口中定义的方法之后，就能够被download函数使用，虽然该函数接受的是接口类型，但是是能够接受该接口类型的实现类型的。接口类型变量可以接受其实现类型的变量。</p></li><li><p>和Python中的type typing类似的地方在于都是只要实现了某个方法，就能被调用（Python中通过魔法函数实现）。</p></li><li><p>但是要注意，因为接口本身功能的要求，实现时，必须实现接口内定义的所有的类型</p></li><li><p>可以有多个结构实现了同一个接口，一个结构也可以同时实现多个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> all <span class="keyword">struct</span> &#123;</span><br><span class="line">content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a all)</span> <span class="title">Post</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"post"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a all)</span> <span class="title">Get</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"get"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AllMethod</span><span class="params">(r Retriever, m MyTest)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Get(<span class="string">"http://www.baidu.com"</span>) + <span class="string">" "</span> + m.Post(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := all&#123;<span class="string">"aaa"</span>&#125;</span><br><span class="line">fmt.Println(AllMethod(m, m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">get post</span><br></pre></td></tr></table></figure><h2 id="接口的值类型"><a class="header-anchor" href="#接口的值类型">¶</a>接口的值类型</h2><p>因为go语言中都是值类型，所以定义变量的时候，值实际是应该有值的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r Retriever <span class="comment">// 此处的Retriever是上面的接口对象</span></span><br><span class="line">fmt.Printf(<span class="string">"%T %v\n"</span>,r,r)</span><br><span class="line">r = mock.Retriever&#123;<span class="string">"this is a fack xxx.com"</span>&#125;<span class="comment">// 此处可见，接口类型变量可以接受其实现类型的变量</span></span><br><span class="line">fmt.Printf(<span class="string">"%T %v\n"</span>,r,r)</span><br><span class="line">r = <span class="built_in">real</span>.Retriever&#123;</span><br><span class="line">UserAgent: <span class="string">"Mozilla/5.0"</span>,</span><br><span class="line">Timeout: time.Minute,    <span class="comment">// 一旦换行，每个k/v值后需要添加逗号</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v\n"</span>,r,r)</span><br><span class="line">fmt.Println(reflect.TypeOf(r))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">mock.Retriever &#123;this is a fack xxx.com&#125;</span><br><span class="line"><span class="built_in">real</span>.Retriever &#123;Mozilla/<span class="number">5.0</span> <span class="number">1</span>m0s&#125;</span><br><span class="line"><span class="built_in">real</span>.Retriever</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = &amp;<span class="built_in">real</span>.Retriever&#123;</span><br><span class="line">UserAgent: <span class="string">"Mozilla/5.0"</span>,</span><br><span class="line">Timeout: time.Minute,    <span class="comment">// 一旦换行，每个k/v值后需要添加逗号</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v\n"</span>,r,r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">*<span class="built_in">real</span>.Retriever &amp;&#123;Mozilla/<span class="number">5.0</span> <span class="number">1</span>m0s&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础</title>
      <link href="2019/12/10/Vue%E5%9F%BA%E7%A1%80/"/>
      <url>2019/12/10/Vue%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基本案例"><a class="header-anchor" href="#基本案例">¶</a>基本案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,  <span class="comment">// 创建实例和对应的Dom进行绑定</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            msg: <span class="string">"hello vue!"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue不同于直接使用js，js操作的对象是dom对象，而Vue则操作的是数据对象，因为都是将数据和dom进行绑定的，而我们想要改变值，直接通过改变数据即可。</p><h2 id="挂载点，模板，实例之间的关系"><a class="header-anchor" href="#挂载点，模板，实例之间的关系">¶</a>挂载点，模板，实例之间的关系</h2><p>id为app的div标签就是vue实例的挂载点，vue只会处理对应挂载点下的内容。在挂载点内部的内容都叫做模板，像上面的ID为app的div内的h1标签就是模板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--除了在挂载点内手写模板之外，还可以采用在vue实例内部定义模板的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 在vue实例内部使用template定义模板</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello </span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>',</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            msg: <span class="string">"vue!"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以模板可以写在挂载点内部，也可以写在vue实例内，使用template定义</p><blockquote><p>注意使用template时，会将挂载点内的内容进行覆盖</p></blockquote><h2 id="指令"><a class="header-anchor" href="#指令">¶</a>指令</h2><p>均采用 <code>v-</code> 开头</p><ul><li>v-text=‘data中的数据’：将标签内的显示内容同实例中的data中的值联系</li><li>v-html=‘data中的数据’：作用和v-text一致，但是若data中的内容为html代码，则会渲染到页面，即不会对html代码进行转义</li><li>v-on：绑定事件监听器，简写形式：@<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--绑定点击事件，绑定函数名，无参数的函数可以直接写函数名即可，两者的效果是一样的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">"handleClick"</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            msg: <span class="string">"vue!"</span>,</span></span><br><span class="line"><span class="actionscript">            content: <span class="string">'hello'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        methods: &#123; <span class="comment">// 需要调用的方法在methods中进行定义，但是要注意函数不能使用箭头函数</span></span></span><br><span class="line"><span class="actionscript">            handleClick: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 函数中的this指定的当前的vue实例对象</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.content = <span class="keyword">this</span>.msg</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</p></blockquote><h2 id="属性绑定和双向绑定"><a class="header-anchor" href="#属性绑定和双向绑定">¶</a>属性绑定和双向绑定</h2><p>使用v-bind将某个标签属性和vue实例的data属性绑定，v-bind可以直接简写成 <code>：</code>，使用冒号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:title</span>=<span class="string">" 'woshi:'+ title"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">:title</span>=<span class="string">" 'woshi:'+ title"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            title: <span class="string">"this is hello vue"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;div v-bind:title=&quot; 'woshi:'+ title&quot;&gt;hello&lt;/div&gt;</code> 绑定之后，是可以直接写js表达式的。</p><p>双向数据绑定：使用v-model模板指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:title</span>=<span class="string">"'woshi '+ title"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--使用v-model进行双向的数据绑定--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"content"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            title: <span class="string">"this is hello vue"</span>,</span></span><br><span class="line"><span class="actionscript">            content: <span class="string">"hello"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性和侦听器"><a class="header-anchor" href="#计算属性和侦听器">¶</a>计算属性和侦听器</h2><p>计算属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>/&gt;</span></span><br><span class="line">        名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="comment">&lt;!--计算属性也是属性，调用方式是一样的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            firstName: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            lastName:<span class="string">''</span>,</span></span><br><span class="line">            count: 0,</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        computed: &#123; <span class="comment">// 定义计算属性，根据其他的数据项计算出的结果，其他数据未发生变化的时候不去调用，会使用缓存</span></span></span><br><span class="line"><span class="actionscript">            fullName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        watch:&#123; <span class="comment">// 定义侦听器，当侦听的属性发生变化的时候调用</span></span></span><br><span class="line"><span class="actionscript">            firstName:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.count++</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            lastName: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.count++</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用computed创建一个计算属性（注意：使用计算属性的时候，函数一定要return返回语句），绑定一个函数，计算属性也是属性，调用方式和插值操作一致。使用计算属性的好处是，计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算，所以性能较高。</p><p>侦听器：<br>当侦听的属性发生变化的时候调用，Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个属性。上面的侦听器还可以侦听计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123; <span class="comment">// 定义侦听器，当侦听的属性发生变化的时候调用</span></span><br><span class="line">            funName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="v-if、v-for、v-show"><a class="header-anchor" href="#v-if、v-for、v-show">¶</a>v-if、v-for、v-show</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-if和v-show的区别在于使用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            show: <span class="literal">true</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            handleClick: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.show = !<span class="keyword">this</span>.show</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-if和v-show的区别：</p><ul><li>使用v-if时，当判断为false时，是将当前dom移除，而使用v-for则是该当前dom添加<code>sytle='display:none'</code>属性来控制显示和隐藏。</li><li>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</li></ul><p>小结：</p><p>v-if控制dom的存在与否，v-show控制dom的显示与否（内部实现是通过添加<code>sytle='display:none'</code>属性来控制）</p><p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</p><h2 id="案例"><a class="header-anchor" href="#案例">¶</a>案例</h2><p>TodoList功能开发</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"inputValue"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            inputValue: <span class="string">''</span>,</span></span><br><span class="line">            list: [ ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            handleSubmit: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (<span class="keyword">this</span>.inputValue !=<span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.inputValue)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.inputValue = <span class="string">''</span> <span class="comment">// 做了双向绑定</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件"><a class="header-anchor" href="#组件">¶</a>组件</h3><p>组件是可复用的 Vue 实例，且带有一个名字</p><p>全局组件： 可以在任何挂载点内的任何位置使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Vue.component()定义全局组件，可以在挂载的dom内的任何位置通过组件名进行使用</span></span><br><span class="line">Vue.component(<span class="string">'todo-list'</span>,&#123;</span><br><span class="line">  template: <span class="string">'&lt;li&gt;item&lt;/li&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部组件：绑定好后可以在当前挂载点内使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部组件，需要在Vue实例内通过components属性进行绑定</span></span><br><span class="line"><span class="keyword">var</span> TodoItem = &#123;</span><br><span class="line">    template: <span class="string">'&lt;li&gt;item&lt;/li&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line">vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">      <span class="string">'todo-list'</span>:TodoItem</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用全局组件重新实现Todolist案例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"inputValue"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">todo-list</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">:content</span>=<span class="string">"item"</span>  // 组件中的<span class="attr">props</span>的值在这里进行赋值，此处想通过数据绑定的方式和根组件进行绑定，也可以不是用绑定，此时<span class="attr">content</span>的值就是由给的值决定</span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 使用Vue.component()定义全局组件，可以在挂载的dom内的任何位置通过组件名进行使用</span></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">'todo-list'</span>,&#123;</span></span><br><span class="line"><span class="actionscript">        props: [<span class="string">'content'</span>],  <span class="comment">// 定义从外部接受的属性</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123;content&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>'</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            inputValue: <span class="string">''</span>,</span></span><br><span class="line">            list: [ ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            handleSubmit: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (<span class="keyword">this</span>.inputValue !=<span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.inputValue)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.inputValue = <span class="string">''</span> <span class="comment">// 做了双向绑定</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在组件内，想要给template中的代码添加插值，需要在组件的props属性中添加对应的插值变量，在使用组件的时候，对插值变量进行赋值，赋值的方式有两种，第一是可以直接赋值，使用<code>变量=</code>的方式，如<code>content='hello'</code>,则所有的插值都是hello，也可以使用对象绑定<code>v-bind:content='vue实例的data中的值'</code>进行数据绑定。</p><p>注意：props接受的类型是插值变量的列表形式，只有在进行组件校验的时候才使用字典类型，如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">  props:&#123;</span><br><span class="line">    content: &#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      required: <span class="literal">true</span>,  <span class="comment">// 表示是否必须传递</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default value'</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 设置相关校验</span></span><br><span class="line">        <span class="keyword">return</span> (value.length &gt; <span class="number">5</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其余时刻都是使用的插值列表的形式。</p><h3 id="实现Tolist的删除功能"><a class="header-anchor" href="#实现Tolist的删除功能">¶</a>实现Tolist的删除功能</h3><p>父组件通过绑定属性的方式向子组件传值，而子组件想改变父组件的值的时候可以通过发布事件的方式。</p><p>组件模板内使用的值以及方法都是在组件内定义的，模板值在props值中，使用的方法在methods中定义，props只是定义了可以使用的变量，对应的值在使用组件的使用通过数据绑定v-bind进行绑定，在组件中定义的方法是根实例进行监听的，组件自己的监听方法需要放在template中。</p><p>若要在组件中使用data，请使用以下的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'magic-eight-ball'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 一定要通过函数返回值的形式</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      possibleAdvice: [<span class="string">'Yes'</span>, <span class="string">'No'</span>, <span class="string">'Maybe'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义事件、监听"><a class="header-anchor" href="#自定义事件、监听">¶</a>自定义事件、监听</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"inputValue"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">todo-list</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">:content</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">:index</span>=<span class="string">"index"</span></span></span><br><span class="line">@delete_list="handleDelete"   &lt;!--自定义事件，并绑定处理--&gt;</span><br><span class="line">            &gt;<span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 使用Vue.component()定义全局组件，可以在挂载的dom内的任何位置通过组件名进行使用</span></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">'todo-list'</span>,&#123;</span></span><br><span class="line"><span class="actionscript">        props: [<span class="string">'content'</span>, <span class="string">'index'</span>],  <span class="comment">// 定义从外部接受的属性</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span></span><span class="template-variable">&#123;&#123;content&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>',</span></span></span><br><span class="line">methods:&#123;</span><br><span class="line"><span class="actionscript">handleClick: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$emit(<span class="string">'delete_list'</span>, <span class="keyword">this</span>.index) <span class="comment">// 触发自定义事件，提供回调函数的参数</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            inputValue: <span class="string">''</span>,</span></span><br><span class="line">            list: [ ],</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            handleSubmit: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (<span class="keyword">this</span>.inputValue !=<span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.inputValue)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.inputValue = <span class="string">''</span> <span class="comment">// 做了双向绑定</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">handleDelete:<span class="function"><span class="keyword">function</span> <span class="params">(index)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.list.splice(index,<span class="number">1</span>)</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件用到的属性以及方法都在组件内定义，在template中使用，组件的dom一定要定义在template属性中。组件若想用到根组件的内容的时候在调用组件中使用，通过数据绑定获取根vue的data值，通过事件监听，调用根vue的方法。</p><p>注意： HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99-camelCase-vs-kebab-case" target="_blank" rel="noopener">Prop 的大小写 (camelCase vs kebab-case)</a></p><h3 id="组件与实例的关系"><a class="header-anchor" href="#组件与实例的关系">¶</a>组件与实例的关系</h3><p>每个组件都是一个vue实例，都有vue实例的各种方法。</p><p>每个项目包含多个vue实例，但是只有一个根实例，根实例可以没有template属性，没有template属性的时候，会自动找挂载点dom，将挂载点下的dom作为template的内容。若使用了template属性，挂载元素的内容都将被忽略，除非模板的内容有分发<a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">插槽</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go踩坑</title>
      <link href="2019/11/30/%E5%9D%91%E7%82%B9/"/>
      <url>2019/11/30/%E5%9D%91%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>在go 1.13中使用了全新的包导入机制</p><p>在设置了go env -w GO111MODULE=on 之后，所有的报名导入的时候都要保证是以域名开头的包，所以暂时不进行设置，</p><p>导入包的时候在设置</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之包和封装</title>
      <link href="2019/11/30/%E5%8C%85%E5%92%8C%E5%B0%81%E8%A3%85/"/>
      <url>2019/11/30/%E5%8C%85%E5%92%8C%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1>封装</h1><p>通过命名来实现封装</p><ul><li>名字一般使用CamelCase</li><li>首字母大写：public</li><li>首字母小写：private</li></ul><p>相对于 包 而言，若一个外部的包想要访问本包内定义的结构，和  结构的方法（不仅仅是结构，定义的一般方法若想被其他包使用，也是要大写首字母的），这些命名，包括结构内变量的命名都要采用大写。</p><p>但是在同一个包下的内容可以随便调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">Value       <span class="keyword">int</span></span><br><span class="line">Left, Right *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node Node)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(node.Value, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">SetValue</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Setting Value to nil "</span> +</span><br><span class="line"><span class="string">"node. Ignored."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">node.Value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(value <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Node&#123;Value: value&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>包</h1><ul><li>每个目录一个包，只能是同一种包</li><li>main包包含可执行入口-- main函数，只有main包才能有main函数</li><li>为结构定义的方法必须放在同一个包内</li><li>可以是同一个包内的不同文件，对包外来说，只要知道包名，都可以使用，不需要知道文件名</li></ul><p>使用时，import导入的是存放包的目录名，同一个目录下只能有一种包名，用来表示包内文件的关系，以及被其他包使用时的开头 <code>包名.方法或变量</code>。但是为了不产生歧义，最好使用的时候，包名和目录名设置成一致的即可。</p><h2 id="如何扩充系统类型或者别人的类型"><a class="header-anchor" href="#如何扩充系统类型或者别人的类型">¶</a>如何扩充系统类型或者别人的类型</h2><p>在含有继承的语言中，可以通过继承的方式来扩充原有的功能，但是在go中是没有继承的概念的。Go采用以下两种方式来扩充：</p><ul><li>定义别名</li><li>使用组合</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用组合的方式来完成    扩充自定义的treeNode结构，增加后序遍历的功能</span></span><br><span class="line"><span class="keyword">type</span> myTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">node *tree.Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *myTreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> myNode == <span class="literal">nil</span> || myNode.node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">left := myTreeNode&#123;myNode.node.Left&#125;</span><br><span class="line">right := myTreeNode&#123;myNode.node.Right&#125;</span><br><span class="line"></span><br><span class="line">left.postOrder()</span><br><span class="line">right.postOrder()</span><br><span class="line">myNode.node.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用别名的方式来完成  扩充[]int切片类型，提供Push、Pop、IsEmpty的功能</span></span><br><span class="line"><span class="keyword">package</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment">// A FIFO queue.</span></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span>    <span class="comment">// 使用type 定义了[]int类型的别名 Queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pushes the element into the queue.</span></span><br><span class="line"><span class="comment">// e.g. q.Push(123)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*q = <span class="built_in">append</span>(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pops element from head.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">head := (*q)[<span class="number">0</span>]</span><br><span class="line">*q = (*q)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if the queue is empty or not.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>GOPATH环境变量</h1><ul><li>默认在~/go（Unix，Linux）</li><li>官方推荐：所有项目和第三方库都放在同一个GOPATH下</li><li>也可以将每个项目放在不同的GOPATH</li><li>GO在 编译 的时候会自动到每个GOPATN下找到自己所依赖的包</li></ul><p>正常情况下  go get <a href="http://golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">golang.org/x/tools/cmd/goimports</a></p><p>使用gopm来获取无法下载的包</p><p>go get -v <a href="http://github.com/gpmgo/gopm" target="_blank" rel="noopener">github.com/gpmgo/gopm</a></p><ul><li>go build 来编译</li><li>go install 产生pkg文件和可执行文件</li><li>go run 直接编译运行</li></ul><p>gopath下三个文件夹，bin 放go install的可执行文件， pkg 存放包文件，src  为项目源代码，也是可以使被掉</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 使用之操作篇</title>
      <link href="2019/11/25/redis-%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AF%87/"/>
      <url>2019/11/25/redis-%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>redis的几种数据类型：STRING SET HASH LIST<br>redis的命令行操作模式会显示他的语法提示，基本使用采用的是k/v值的形式，即通过key设置value的方式。<br>对redis数据库的操作可分为两种方式，第一种采用redis-cli进行访问，第二种采用编程语言，如 Python、Java等。本文中使用 redis-cli 的方式进行数据的访问，首先需要启动redis，连接上 redis-server，这在上节已经进行了详细的讲解，此处不再赘述。</p><p>redis-cli 在使用时提供了命令提示，方便我们操作。<br><a href="http://doc.redisfans.com/index.html" target="_blank" rel="noopener">Redis 命令参考</a></p><h2 id="使用redis-cli对redis进行字符串string操作"><a class="header-anchor" href="#使用redis-cli对redis进行字符串string操作">¶</a>使用redis-cli对redis进行字符串string操作</h2><h3 id="添加"><a class="header-anchor" href="#添加">¶</a>添加</h3><p><code>set key value</code> ，value 为string类型，可以不使用引号<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; <span class="built_in">set</span> username tmj</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>将字符串值 value 关联到 key ，如果 key 已经持有其他值，set 命令就覆写旧值，无视其类型。并且默认的过期时间是永久（即使之前的 key 快过期了），即永久不会过期。</p><h4 id="批量添加"><a class="header-anchor" href="#批量添加">¶</a>批量添加</h4><p><code>mset key1 value1 key2 value2 ... ...</code></p><h3 id="删除"><a class="header-anchor" href="#删除">¶</a>删除</h3><p><code>del key</code><br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; del username</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="设置过期时间"><a class="header-anchor" href="#设置过期时间">¶</a>设置过期时间</h3><p><code>expire key timeout</code> 时间单位为秒<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; expire username 60</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>可以对已经设置过过期时间的 key 重新设置过期时间,将覆盖原值。也可以在设置 key 时，同时指定过期时间，使用 <code>EX</code> 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; <span class="built_in">set</span> age 18 EX 800</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>等价方式，使用 <code>setex key timeout value</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; setex age 800 18</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>expire key timeout</code> 指令是通用的，适用于各种类型的key,下面的两中方式只适用于string类型。</p></blockquote><h3 id="查看过期时间"><a class="header-anchor" href="#查看过期时间">¶</a>查看过期时间</h3><p><code>ttl key</code><br>过期时间的查询结果有一下几种：</p><ul><li>大于0的正整数：此key存在，且还剩下正整数的时间过期</li><li>-1 ： 此key存在，且没有设置过期时间，即永久不会过期</li><li>-2 ： 此key不存在，或存在但是过期了，总之就是现在不存在了。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; ttl username</span><br><span class="line">(<span class="built_in">integer</span>) 796</span><br></pre></td></tr></table></figure><h3 id="查看某个string类型key的值"><a class="header-anchor" href="#查看某个string类型key的值">¶</a>查看某个string类型key的值</h3><p><code>get key</code></p><h4 id="批量查看多个string类型key的值"><a class="header-anchor" href="#批量查看多个string类型key的值">¶</a>批量查看多个string类型key的值</h4><p><code>mget key1 key2 key3 ...</code></p><h3 id="查看当前redis中所有类型的key"><a class="header-anchor" href="#查看当前redis中所有类型的key">¶</a>查看当前redis中所有类型的key</h3><p><code>keys *</code></p><h3 id="查看key的类型"><a class="header-anchor" href="#查看key的类型">¶</a>查看key的类型</h3><p>因为redis中所有类型的key是存在一起的，但是每中类型的key的查看的方式都是不同的，一旦使用的查询命令不对就会报错，此时可以使用 <code>type key</code> 查看key的类型<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; <span class="built_in">type</span> username</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h2 id="使用redis-cli对redis进行列表list操作"><a class="header-anchor" href="#使用redis-cli对redis进行列表list操作">¶</a>使用redis-cli对redis进行列表list操作</h2><p>Redis列表 是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><h3 id="添加-v2"><a class="header-anchor" href="#添加-v2">¶</a>添加</h3><p>添加到头部（左边）使用 <code>lpush key value</code>，添加到尾部（右边）使用 <code>rpush key value</code>。如果key不存在，一个空的列表会被创建并执行lpush（rpush）操作，当key存在，但不是列表类型时，返回错误。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; lpush language python</span><br><span class="line">(<span class="built_in">integer</span>) 1    <span class="comment"># 返回值为当前列表中值的个数</span></span><br></pre></td></tr></table></figure><p>列表中可以添加多个值，且可以是重复值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; lpush language python python</span><br><span class="line">(<span class="built_in">integer</span>) 3    <span class="comment"># 添加了两个重复的值，目前一共三个值</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：当一次添加多个 value 的时候，最后一个 value 是第一个被添加的，如上面的例子中，最后一个 python 是第一被添加的。</p></blockquote><h3 id="查看列表中的的元素（是一个区间中的元素）"><a class="header-anchor" href="#查看列表中的的元素（是一个区间中的元素）">¶</a>查看列表中的的元素（是一个区间中的元素）</h3><p><code>lrange key start stop</code>，指令中的 l 代表的是列表list的意思，返回列表key中指定区间内的元素，区间以偏移量start和stop指定，如果要左边的第一个到最后的一个 <code>lrange key 0 -1</code>（列表的第一项下标是 0，左后一项为 -1）。若只想查看某个值，则start 和 stop 指定一样的下标即可。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; lrange language 0 -1</span><br><span class="line">1) <span class="string">"python"</span></span><br><span class="line">2) <span class="string">"python"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br></pre></td></tr></table></figure><h4 id="返回指定下标的元素"><a class="header-anchor" href="#返回指定下标的元素">¶</a>返回指定下标的元素</h4><p>使用 <code>lindex key index</code>，指令中的 l 代表的是列表list的意思，将返回key这个列表中，索引为index的这个元素，若是请求的索引不存在，返回 (nil)。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; lindex language 0</span><br><span class="line"><span class="string">"python"</span></span><br></pre></td></tr></table></figure><h3 id="修改指定下标的元素"><a class="header-anchor" href="#修改指定下标的元素">¶</a>修改指定下标的元素</h3><p>使用 <code>lset key index value</code>，将列表 key 下标为 index 的元素的值设置为 value 。当 index 参数超出范围，或对一个空列表(key不存在)进行 LSET 时，返回一个错误。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; lset language 0 Golang</span><br><span class="line">OK   <span class="comment"># 修改成功，返回OK</span></span><br></pre></td></tr></table></figure><h3 id="移除列表中的元素"><a class="header-anchor" href="#移除列表中的元素">¶</a>移除列表中的元素</h3><p>同理增加值的方式，使用<code>lpop key</code> 和 <code>rpop key</code> 移除列表头部或者尾部的元素，使用这两条命令移除列表元素的同时还会返回移除的值。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; lpop language</span><br><span class="line"><span class="string">"python"</span>  <span class="comment"># 返回了被移除的头部元素</span></span><br></pre></td></tr></table></figure><h4 id="移除指定个数的单个元素"><a class="header-anchor" href="#移除指定个数的单个元素">¶</a>移除指定个数的单个元素</h4><p>使用 <code>lrem key count value</code>，指令中的 l 代表的是列表list的意思，删除列表key中count个值为value的元素。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; lrem language 4 python</span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment"># 返回的值为 实际 删除的个数，若为0表示不存在该元素</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：返回的是实际删除掉的 values 的个数，使用的时候 count 的大小是可以超过实际个数大小的，但是删除时的返回值是实际删除掉的个数。</p></blockquote><h4 id="移除指定位置index的元素"><a class="header-anchor" href="#移除指定位置index的元素">¶</a>移除指定位置index的元素</h4><p>命令里没有根据 index 删除元素的命令，如果想要删除指定index的值，可以采用组合命令的方式，即通过 <code>lset key index value</code> 来修改要删除的位置的元素为某个标志，然后使用 <code>lrem key 0 value</code> 删除所有值为标记的元素（也即是需要删除的位置）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; lset language 1 del  <span class="comment"># 将要删除的下表的元素设置为 "del"</span></span><br><span class="line">OK</span><br><span class="line">$ 127.0.0.1:6379&gt; lrem language 0 del  <span class="comment"># 删除值为 "del" 的所有的元素，就相当于删除了指定index上的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>同理删除多个位置上的值，就可以通过 <code>lset key index value</code> 修改多个需要删除的位置上的值为标志值，然后使用 <code>lrem key 0 value</code> 统一删除。</p><h4 id="移除区间之外的元素"><a class="header-anchor" href="#移除区间之外的元素">¶</a>移除区间之外的元素</h4><p>使用 <code>ltrim key start stop</code> 对列表进行修剪(trim)，即让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; ltrim language 0 1</span><br><span class="line">OK   <span class="comment"># 保留了前两个元素</span></span><br></pre></td></tr></table></figure><p>注意，作用的范围是闭区间。</p><h3 id="获取列表中的元素的个数"><a class="header-anchor" href="#获取列表中的元素的个数">¶</a>获取列表中的元素的个数</h3><p><code>llen key</code></p><h3 id="只有单条的指令可以通过正负值来指定操作的方向"><a class="header-anchor" href="#只有单条的指令可以通过正负值来指定操作的方向">¶</a>只有单条的指令可以通过正负值来指定操作的方向</h3><p>命令中的 l 代表list的指令（即不使用通过l和r来区分操作方向的指令），都可以通过负值来表示反向操作。<br>如移除指定个数的元素 <code>lrem key count value</code> 命令根据参数count的值，移除列表中与参数value相等的元素。count的值可以是一下几种：</p><ul><li>count &gt; 0 ：从表头开始向表尾搜索，移除与value相等的元素，数量为count。</li><li>count &lt; 0 ：从表尾开始向表头搜索，移除与value相等的元素，数量为count的绝对值。</li><li>count = 0 : 移除表中所有与value相等的值。</li></ul><h2 id="使用redis-cli对redis进行集合set操作"><a class="header-anchor" href="#使用redis-cli对redis进行集合set操作">¶</a>使用redis-cli对redis进行集合set操作</h2><p>集合和列表相似，是用来存储元素的，不同在于，集合是无序的，且元素同一元素只能保存一份，集合中的元素是唯一的。</p><h3 id="添加-v3"><a class="header-anchor" href="#添加-v3">¶</a>添加</h3><p>使用 <code>sadd key member1 member2 ...</code> ，因为元素是无序且唯一的，所以不存在左右添加的区别。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; sadd team xiaoming xiaowang</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">$ 127.0.0.1:6379&gt; sadd team xiaoming  </span><br><span class="line">(<span class="built_in">integer</span>) 0   <span class="comment"># 添加了重复值返回0，表示没有本次没有添加的内容</span></span><br><span class="line">$ 127.0.0.1:6379&gt; sadd team xiaotang</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>与列表的添加不同，返回的结果不会显示目前集合中元素个数，只会显示本次添加操作中成功添加的个数，重复添加相同的值，则返回0。一次性添加的多个成员中含有集合中已经存在的成员直接无视，添加未存在的。</p><blockquote><p>注意：集合中存储的成员的顺序于添加顺序无关</p></blockquote><h3 id="查看集合中的成员"><a class="header-anchor" href="#查看集合中的成员">¶</a>查看集合中的成员</h3><p><code>smembers key</code></p><h3 id="移除集合中的成员"><a class="header-anchor" href="#移除集合中的成员">¶</a>移除集合中的成员</h3><p>使用 <code>srem key member1 member2 ...</code> 进行删除，因为集合是没有下标，且集合中的值唯一，所以直接指定需要删除的成员即可。</p><h4 id="移除并返回一个随机成员"><a class="header-anchor" href="#移除并返回一个随机成员">¶</a>移除并返回一个随机成员</h4><p>使用 <code>spop key</code> ，会随机删除并返回一个元素<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; sadd team xiaoming xiaowang</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">$ 127.0.0.1:6379&gt; spop team</span><br><span class="line"><span class="string">"xiaowang"</span></span><br><span class="line">$ 127.0.0.1:6379&gt; smembers team</span><br><span class="line">1) <span class="string">"xiaoming"</span></span><br></pre></td></tr></table></figure><h4 id="随机获取一个元素不移除"><a class="header-anchor" href="#随机获取一个元素不移除">¶</a>随机获取一个元素不移除</h4><p>使用 <code>srandmember key [count]</code>，从 Redis2.6 版本开始， srandmember 命令接受可选的 count 参数：</p><ul><li>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。</li><li>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</li></ul><h3 id="查看集合中的成员的个数"><a class="header-anchor" href="#查看集合中的成员的个数">¶</a>查看集合中的成员的个数</h3><p>使用 <code>scard key</code> 进行查看<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; scard team</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h3 id="集合之间的操作"><a class="header-anchor" href="#集合之间的操作">¶</a>集合之间的操作</h3><h4 id="获取集合的交集"><a class="header-anchor" href="#获取集合的交集">¶</a>获取集合的交集</h4><p><code>sinter key1 key2</code></p><h4 id="获取集合的并集"><a class="header-anchor" href="#获取集合的并集">¶</a>获取集合的并集</h4><p><code>sunion key1 key2</code></p><h4 id="获取集合的差集"><a class="header-anchor" href="#获取集合的差集">¶</a>获取集合的差集</h4><p><code>sdiff key1 key2</code></p><h2 id="使用redis-cli对redis进哈希表hash操作"><a class="header-anchor" href="#使用redis-cli对redis进哈希表hash操作">¶</a>使用redis-cli对redis进哈希表hash操作</h2><p>哈希表类似python中的字典，采用k/v值的形式。</p><h3 id="添加-v4"><a class="header-anchor" href="#添加-v4">¶</a>添加</h3><p>使用 <code>hset key field value</code> 进行创建，将哈希表 key 中的域 field 的值设为 value。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; hset website baidu www.baidu.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">$ 127.0.0.1:6379&gt; hset website google www.google.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><blockquote><p>返回的内容和string操作时类似，用来显示成功与否，不显示添加的数量</p></blockquote><p>数据的存储样式是：<br><img src="/2019/11/25/redis-%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AF%87/redis_hash.png" alt="redis_hash"><br>如果域 field 已经存在于哈希表中，旧值将被覆盖。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; hset website google google.com</span><br><span class="line">(<span class="built_in">integer</span>) 0   <span class="comment"># 注意返回值的形式，是0而不是1</span></span><br><span class="line">$ 127.0.0.1:6379&gt; hget website google</span><br><span class="line"><span class="string">"google.com"</span>   <span class="comment"># 查看后发现域field的值被修改了</span></span><br></pre></td></tr></table></figure><h4 id="批量添加-v2"><a class="header-anchor" href="#批量添加-v2">¶</a>批量添加</h4><p>使用<code>hmset key field1 value1 field2 value2 ... ...</code><br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 39.106.84.56:6379&gt; hmset website apple www.apple.com huawei www.hauwei.com</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="获取哈希表中的field对应的值"><a class="header-anchor" href="#获取哈希表中的field对应的值">¶</a>获取哈希表中的field对应的值</h3><p><code>hget key field</code></p><h4 id="批量查看哈希表中的某些field对应的值"><a class="header-anchor" href="#批量查看哈希表中的某些field对应的值">¶</a>批量查看哈希表中的某些field对应的值</h4><p><code>hmget key field1 field2 ...</code></p><h3 id="删除field中的某个field"><a class="header-anchor" href="#删除field中的某个field">¶</a>删除field中的某个field</h3><p><code>hdel key field</code></p><h3 id="获取哈希中的所有的field和value"><a class="header-anchor" href="#获取哈希中的所有的field和value">¶</a>获取哈希中的所有的field和value</h3><p>使用 <code>hgetall key</code> 进行获取，打印的样式是 field value 这样一个间隔一个的样式<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; hgetall website</span><br><span class="line">1) <span class="string">"baidu"</span></span><br><span class="line">2) <span class="string">"www.baidu.com"</span></span><br><span class="line">3) <span class="string">"google"</span></span><br><span class="line">4) <span class="string">"www.google.com"</span></span><br></pre></td></tr></table></figure><h3 id="获取某个哈希中所有的field"><a class="header-anchor" href="#获取某个哈希中所有的field">¶</a>获取某个哈希中所有的field</h3><p><code>hkeys key</code></p><h3 id="获取某个哈希中所有的值"><a class="header-anchor" href="#获取某个哈希中所有的值">¶</a>获取某个哈希中所有的值</h3><p><code>hvals key</code></p><h3 id="判断哈希中是否存在某个field"><a class="header-anchor" href="#判断哈希中是否存在某个field">¶</a>判断哈希中是否存在某个field</h3><p>使用 <code>hexists key field</code><br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; hexists website google</span><br><span class="line">(<span class="built_in">integer</span>) 1   <span class="comment"># 存在返回1</span></span><br><span class="line">$ 127.0.0.1:6379&gt; hexists website googl</span><br><span class="line">(<span class="built_in">integer</span>) 0   <span class="comment"># 不存在返回0</span></span><br></pre></td></tr></table></figure><h3 id="获取哈希表中的键值对个数"><a class="header-anchor" href="#获取哈希表中的键值对个数">¶</a>获取哈希表中的键值对个数</h3><p>使用 <code>hlen key</code><br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; hlen website</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="为哈希表中的-字段值-加上指定增量值"><a class="header-anchor" href="#为哈希表中的-字段值-加上指定增量值">¶</a>为哈希表中的 字段值 加上指定增量值</h3><p>通过 <code>hincrby key field num</code> 的方式，给hash表中field对应的value增加或者减少相应的数量，注意此操作只能用来对value是数值形式的field进行。</p><h2 id="事务"><a class="header-anchor" href="#事务">¶</a>事务</h2><p>Redis事务可以一次执行多个命令，事务具有以下特征：</p><ul><li>隔离操作：事务中的所有命令都会序列化、按顺序的执行，不会被其他命令打扰。</li><li>原子操作：事务中的命令要么全部被执行，要么全部不执行。</li></ul><h3 id="开启一个事务"><a class="header-anchor" href="#开启一个事务">¶</a>开启一个事务</h3><p><code>multi</code><br>以后执行的所有的命令，都在这个事务中执行。</p><h3 id="执行事务"><a class="header-anchor" href="#执行事务">¶</a>执行事务</h3><p><code>exec</code><br>会将在multi和exec中的操作一并提交。</p><h3 id="取消事务"><a class="header-anchor" href="#取消事务">¶</a>取消事务</h3><p><code>discard</code><br>会将multi后的所有命令取消。</p><h3 id="监视一个或者多个key"><a class="header-anchor" href="#监视一个或者多个key">¶</a>监视一个或者多个key</h3><p><code>watch key [key ...]</code><br>监视一个（或者多个）key，如果在事务执行之前这个（或这些）key被其他命令所改动，那么事务将被打断。</p><h3 id="取消所有key的监视"><a class="header-anchor" href="#取消所有key的监视">¶</a>取消所有key的监视</h3><p><code>unwatch</code></p><h2 id="发布-订阅操作"><a class="header-anchor" href="#发布-订阅操作">¶</a>发布/订阅操作</h2><h3 id="给某个频道发布消息"><a class="header-anchor" href="#给某个频道发布消息">¶</a>给某个频道发布消息</h3><p><code>publish channel message</code></p><h3 id="订阅某个频道的消息"><a class="header-anchor" href="#订阅某个频道的消息">¶</a>订阅某个频道的消息</h3><p><code>subscribe channel</code></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 使用之安装篇</title>
      <link href="2019/11/20/redis-%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%AE%89%E8%A3%85%E7%AF%87/"/>
      <url>2019/11/20/redis-%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%AE%89%E8%A3%85%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>Redis是一种支持分布式（不使用分布式的功能也可以）的nosql数据库，他的数据是保存在内存中的，同时Redis可以定时吧内存中的数据同步到磁盘，即可以将数据持久化，并且他比memcached支持更多的数据结构，包括 string，list列表[队列和栈] ，set[集合]，sorted set[有序集合]，hash(hash表)。</p><p>Redis的使用场景：一般都是在web后台，或者在服务器后台</p><ol><li>登录会话存储：存储在 Redis 中，与 memcached 相比，数据不会丢失。</li><li>排行版/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名，还有一些文章阅读量的技术，或者新浪微博的点赞数等。</li><li>作为消息队列：比如 celery 就是使用 Redis 作为中间人。</li><li>当前在线人数：会显示系统当前在线人数。</li><li>一些常用的数据缓存：比如我们的 BBS 论坛，板块不会经常变化的，但是每次访问首页都要从 mysql 中获取，可以在Redis中缓存起来，不用每次请求数据库。</li><li>把前200篇玩文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。</li><li>好友关系：文博好友关系使用 Redis 实现。</li><li>发布和订阅的功能：可以用来做聊天软件。</li></ol><p><img src="/2019/11/20/redis-%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%AE%89%E8%A3%85%E7%AF%87/redis%E5%92%8Cmemecached%E6%AF%94%E8%BE%83.png" alt="redis和memecached比较"></p><h2 id="redis的安装"><a class="header-anchor" href="#redis的安装">¶</a>redis的安装</h2><h3 id="ubuntu-16-04-01下安装"><a class="header-anchor" href="#ubuntu-16-04-01下安装">¶</a>ubuntu 16.04.01下安装</h3><p>使用 <code>apt-get install redis-server</code> 进行安装（16版本以下可以直接使用 <code>apt install redis-server</code> 安装）</p><blockquote><p>如果遇到提示：<br>E: Unable to locate package redis-server<br>则使用sudo apt-get update 进行更新后再使用命令进行安装</p></blockquote><p>卸载 <code>apt-get purge –auto-remove redis-server</code></p><p>启动：通过 <code>ps aux|grep redis</code> 进行查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root     16373  1286  0 11:27 pts/0    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><p>就是没打开，此时使用 <code>service redis-server start</code> 进行开启。<br><img src="/2019/11/20/redis-%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%AE%89%E8%A3%85%E7%AF%87/start.png" alt="服务开启"><br>停止服务：<code>service redis-server stop</code><br>重启服务：<code>service redis-server restart</code></p><h3 id="centos7系统下安装"><a class="header-anchor" href="#centos7系统下安装">¶</a>centos7系统下安装</h3><p>安装： <code>yum install redis</code><br>启动： <code>systemctl start redis</code></p><blockquote><p>启动服务时，使用的时默认的 redis 配置（/etc/redis.conf中的内容），此时就不需要在命令后添加具体的配置文件，如需使用特定的配置文件来启动 redis，则需要在使用 <code>redis-server 配置文件路径</code> 手动开启。</p></blockquote><p>重启： <code>systemctl restart redis</code><br>停止： <code>systemctl stop redis</code><br>除了通过 <code>systemctl stop redis</code> 命令的方式终止 redis 服务，还可以在客户端（redis-cli）中通过 shutdown 指令关闭redis服务。<br>查看状态： <code>systemctl status redis</code><br>centos7下的 redis 配置文件所在位置默认是 <code>/etc/redis.conf</code> ，具体可以使用 <code>whereis redis</code> 查看到。</p><p>可以参考该内容：<a href="https://www.cnblogs.com/chengxs/p/9833911.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxs/p/9833911.html</a></p><h3 id="windows系统下的安装及使用"><a class="header-anchor" href="#windows系统下的安装及使用">¶</a>windows系统下的安装及使用</h3><p>下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a><br>运行：进入到redis安装的所在路径，然后执行 <code>redis-server.exe redis.windows.conf</code> 就可以运行了。</p><blockquote><p>注意：第一次执行 <code>redis-server.exe redis.windows.conf</code> 可能会报错，<br><code>[12672] 21 Apr 16:52:01.018 # Creating Server TCP listening socket *:6379: bind: No error</code><br>解决方法：在命令行中运行以下命令断开连接<br>redis-cli.exe<br>127.0.0.1:6379&gt;shutdown<br>not connected&gt;exit<br>之后再次重新执行 <code>redis-server.exe redis.windows.conf</code> 启动即可。</p></blockquote><p>服务启动完成之后，执行 <code>redis-cli.exe</code> ，即可连接 redis 数据库了。</p><blockquote><p>注意：启动服务的时候是要指定配置文件的，即 windows 系统下的 redis.windows.conf 文件，linux 下是 redis.conf 文件，才算是完整的启动，否则就会出现启动了服务器，但是连接后没有数据的情况，远程连接也没有用。<br>没有添加配置文件的启动都会在第一行显示 <code>[19668] 16 Apr 10:14:31.228 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server.exe /path/to/redis.conf</code> ，但是连接操作 redis-cli 的启动不受影响，只会影响到查数据，远程连接别的redis 数据库也不会受到影响（别的redis数据库服务正确启动了—使用了配置文件启动）。</p></blockquote><h2 id="连接"><a class="header-anchor" href="#连接">¶</a>连接</h2><p>redis 和 mysql 以及 mongdb 是一样的，都提供客户端进行连接，输入命令 redis-cli（前提是redis安装路径已经加入环境变量了）就可以链接到 redis 服务器了。</p><h3 id="其他机器访问本机redis服务器"><a class="header-anchor" href="#其他机器访问本机redis服务器">¶</a>其他机器访问本机redis服务器</h3><p>需要修改配置，默认情况下不能访问。<br>想要让其他机器访问本机的 redis 服务器，那么要修改 redis.conf 的配置文件，修改 <code>bind [自己的ip地址或者0.0.0.0]</code>，其他机器才能访问。</p><blockquote><p><font color="red">注意</font>：bind绑定的本机网卡的 ip 地址，而不是想让其他机器连接的 ip 地址。如果有多块网卡，那么可以绑定多个网卡的 ip 地址。如果绑定到的是 0.0.0.0 ，那么意味着其他机器可以通过本机所有的 ip 地址进行访问，绑定的是 127.0.0.1 则只有本机可以访问，外界无法进行访问（ 127.0.0.1 是本地回环地址）。通过 ifconfig 查看本机网卡配置。<br>所以，如果我们想限制只有指定的主机可以连接到 redis 中，我们只能通过防火墙来控制，而不能通过 redis 中的 bind 参数来限制。如使用阿里云的安全组，来限制指定的主机连接6379端口。</p></blockquote><h4 id="若想被其他机器访问的时候，具体做法"><a class="header-anchor" href="#若想被其他机器访问的时候，具体做法">¶</a>若想被其他机器访问的时候，具体做法</h4><h5 id="bind-IP"><a class="header-anchor" href="#bind-IP">¶</a>bind IP</h5><p>找到 <code>bind 127.0.0.1</code> 将其注释，或者修改为 <code>bind [自己的ip地址或者0.0.0.0]</code>，使用云服务器的时候，ip使用的是私有IP。</p><blockquote><p>注意：对 redis.conf 文件修改之后，最好重启一下，配置文件才能生效，centos7下使用  <code>systemctl restart redis</code> 命令进行重启。</p></blockquote><h5 id="设置密码"><a class="header-anchor" href="#设置密码">¶</a>设置密码</h5><p>为了系统安全（因为设置了所有的外部及其都可以通过设置的IP访问到该数据库）最好设置一下访问密码，在配置文件中修改 <code>requiredpass 设置的密码</code>，此时就给 redis 设置了密码。设置密码之后，使用 redis-cli 访问数据库的时候，需要添加 <code>-a 密码</code> 参数进行访问（不添加或者输入的密码错误都可以进入，但是当进行的时候就会提示 <code>(error) NOAUTH Authentication required.</code> ），两种方式可以解决：</p><ul><li>访问的时候，添加 -a 参数进行访问，如 <code>redis-cli -a 设置的密码</code>。</li><li>未使用密码进入 redis-cli 后，使用 <code>auth 密码</code> 进行验证，通过之后提示 OK，即可正常使用。</li></ul><p>除了修改配置文件 redis.conf 的方式外，还可以在 redis-cli 中使用 config 指令的方式进行密码的修改和设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ 127.0.0.1:6379&gt; config get requirepass   <span class="comment"># 获得 requirepass 设置的密码</span></span><br><span class="line">1) <span class="string">"requirepass"</span></span><br><span class="line">2) <span class="string">"123"</span></span><br><span class="line">$ 127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass 321   <span class="comment"># 修改密码</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>*<em>只是使用这种方式设置的密码只对本次启动的redis服务有效，一旦redis服务重启，设置就会消失</em></p><h3 id="关于如何在外部链接阿里云主机centos7中的redis"><a class="header-anchor" href="#关于如何在外部链接阿里云主机centos7中的redis">¶</a>关于如何在外部链接阿里云主机centos7中的redis</h3><ol><li>修改配置文件<br>执行 <code>vim /etc/redis.conf</code> 修改配置文件，安装的位置可能不同，可使用 <code>whereis redis</code> 进行查看<br>redis 默认只能本机访问，需要修改一些配置<br>注释掉 bind 127.0.0.1 或者是改为 bind 0.0.0.0<br>配置密码 requirepass<br>取消注释并改为自己需要的密码，如 <code>requirepass 密码</code></li><li>开放 6379 端口<br>端口开放之后最好重新启动阿里云服务器或者使用 <code>systemctl stop redis</code> 停止 redis 的服务（推荐最好还是重启服务器的好），使用 <code>ps aux|grep redis</code> 查看 redis-server 服务是否关闭，确认关闭后，使用 <code>systemctl start redis</code> 重新启动 redis-server 服务。</li><li>访问<br>在外部访问的时候，通过 <code>redis-cli –h 公有ip地址 -p 6379</code> 进行访问（当然，本地需要安装 redis-cli 服务），记住一定是公有ip地址，此外若是设置了访问密码的话，需要使用 -a 参数传递密码，如果 redis 设置了密码，而登录的时候没有传递密码的话，会报错 <code>(error) NOAUTH Authentication required.</code> 。<br><font color="red"><strong>使用服务器的话，建议还是添加密码，否则容易被黑，因为开放了所有 ip 都可以访问</strong></font>。</li></ol><h2 id="redis的权限设置"><a class="header-anchor" href="#redis的权限设置">¶</a>redis的权限设置</h2><p>redis 可以通过设置密码来增强安全强度。除了设置密码，我们还可以通过修改 redis 的默认端口、对端口做防火墙等。</p><blockquote><p>注意：redis 密码的设置采用的是明文的方式，设置在配置文件 redis.conf 中的 requirepass 字段，所以我们要保证 redis.conf 文件的<strong>访问权限</strong>以保证数据库安全。</p></blockquote><p>redis3.2版本后新增 protected-mode 配置，默认是yes，即开启。设置外部网络连接redis服务，设置方式如下：</p><ul><li><p>关闭 protected-mode 模式，此时外部网络可以直接访问（相当于设置了 bind 0.0.0.0 ），配置密码时，密码有效，需要设置密码进行验证。</p></li><li><p>开启 protected-mode 保护模式，只能本地访问，若要在外部进行访问，需要配置 <code>bind ip</code> 或者设置访问密码（不设置bind，只设置密码，外部输入密码可以访问，此时bind 相当于设置了 bind 0.0.0.0）。</p></li></ul><p>protected-mode 的配置是 redis 的安全保护措施，不建议设置为no，且为了安全使用，最好再同时设置bind和访问密码。私有云配置bind时，绑定的应该是私有IP地址。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 基本使用以及命令</title>
      <link href="2019/11/14/Docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
      <url>2019/11/14/Docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><hr><h3 id="是什么"><a class="header-anchor" href="#是什么">¶</a>是什么</h3><p>Docker是基于Go实现的云开源项目。<br>Docker的主要目标是“Build, Ship and Run Any App,Anywhere”，也就是通过对用用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB项目或者数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。将应用运行在Docker容器上面，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<font color="red">只需要一次配置文件，换到别的机器上就可以一键部署，大大简化了操作。</font><br>Docker解决了运行环境和配置问题软件容器，方便做持续继承并有助于整体发布的容器虚拟化技术。</p><h4 id="发展"><a class="header-anchor" href="#发展">¶</a>发展</h4><ul><li>虚拟机<br>缺点：1.占用资源多 2.冗余步骤多 3.启动慢</li><li>容器虚拟化技术<br>Linux容器（Linux Containers，简称LXC），不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器就可以将软件运行所需要的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套完整的操作系统，只需要软件工作所欲的库资源和设置。系统因此而变的高效轻量并保证部署在任何的环境中的软件始终如一的运行。</li><li>Docker与传统的虚拟化方式的不同<ul><li>传统虚拟技术是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该操作系统上在运行所需应用进程</li><li>Docker容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟，因此容器与传统虚拟器更为轻便。</li><li>每个容器之间相互间隔，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。</li></ul></li></ul><ul><li>优势<ul><li>DevOps开发自运维，一次构建、随处运行（提供全部的资源以及环境，避免冲突）<ul><li>更快速的应用交付和部署</li><li>更便捷的升级和扩缩容</li><li>更简单的系统运维</li><li>更高效的计算资源利用</li></ul></li></ul></li><li>仓库，Docker Hub官网： <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></li></ul><h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><hr><h3 id="前提"><a class="header-anchor" href="#前提">¶</a>前提</h3><ul><li><p>CentOS仅发行版本中的内核支持Docker</p></li><li><p>运行在CentOS7上，要求系统为64位，系统内核版本在3.10以上。</p></li><li><p>运行在CENTOS6.5或者更高版本的CentOS上，要求系统为64位、系统内核版本为2.6.32-431或者更高版本。</p></li><li><p>查看系统的内核</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure></li></ul><ul><li>Docker架构图<br><img src="https://i.loli.net/2019/11/29/Oxyms6T5DVv3XJH.jpg" alt="docker架构.png"></li></ul><h3 id="基本组成（三要素）"><a class="header-anchor" href="#基本组成（三要素）">¶</a>基本组成（三要素）</h3><ul><li>镜像（image)<br>一个只读的模板。可以用来创建Docker容器，一个镜像可以创建很多容器。</li><li>容器（container)<br>是用镜像创建的运行实例，Docker利用容器独立运行一个或一组应用。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</li><li>仓库（repository)<br>仓库是集中存放镜像文件的场所。仓库（Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。仓库分为公开仓库（Public）和私有仓库（Private)两种形式。最大的公开仓库是Docker Hub（<a href="https://hub.docker/com/%EF%BC%89%EF%BC%8C%E5%AD%98%E6%94%BE%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E9%95%9C%E5%83%8F%E4%BE%9B%E7%94%A8%E6%88%B7%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%9B%BD%E5%86%85%E7%9A%84%E5%85%AC%E5%BC%80%E4%BB%93%E5%BA%93%E5%8C%85%E6%8B%AC%E9%98%BF%E9%87%8C%E4%BA%91%E3%80%81%E7%BD%91%E6%98%93%E4%BA%91%E7%AD%89%E3%80%82" target="_blank" rel="noopener">https://hub.docker/com/），存放了大量的镜像供用户下载，国内的公开仓库包括阿里云、网易云等。</a></li></ul><h3 id="小结，正确理解仓库-镜像-容器这几个概念"><a class="header-anchor" href="#小结，正确理解仓库-镜像-容器这几个概念">¶</a>小结，正确理解仓库/镜像/容器这几个概念</h3><p>Docker本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是一个image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</p><h3 id="安装-v2"><a class="header-anchor" href="#安装-v2">¶</a>安装</h3><pre><code>见官方文档：https://docs.docker.com/install/linux/docker-ce/centos/</code></pre><h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2><hr><ul><li><p>安装完成后使用<code>sudo systemctl start docker</code>启动docker服务，一定要先启动docker服务，尤其是在重启宿主机后，docker服务没有启动。</p></li><li><p>推荐使用阿里云镜像加速：注册阿里云，搜索容器镜像服务，按照提示进行申请</p></li><li><p>配置完阿里云镜像后，使用<code>docker info</code>命令查看<code>Registry Mirrors</code>项是否是阿里云镜像的地址</p></li><li><p>通过运行hello-world镜像来验证是否正确安装了Docker Engine-Community 。运行<code>docker run hello-world</code>命令。</p><ul><li>docker run 镜像，运行相应的镜像，运行时首先会在本地寻找此镜像，若没有，会自动从设置的仓库中进行拉取，然后在容器中运行</li><li>第一次运行时，会得到提示：<code>Unable to find image 'hello-world:latest' locally</code>，意思是本地没有该镜像，然后从仓库拉取，并在容器中运行</li><li><code>hello-world:latest</code>后面的<code>:latest</code>为版本号，不写，则默认为latest</li><li>run的过程<ol><li>在Docker本机中寻找该镜像，看本机是否有该镜像，若有，则以该镜像为模板生产容器实例运行</li><li>若本地没有则去Docker Hub上查找该镜像（若设置了阿里云镜像，则在阿里云镜像进行查找），能找到则下载该镜像到本地，以该镜像为模板生产容器实例运行</li><li>若未能找到，则返回失败，找不到该镜像</li></ol></li></ul></li><li><p>底层原理</p><ul><li><p>Docker是怎么工作的<br>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器，容器，是一个运行环境，就是所谓的集装箱。</p></li><li><p>Docker为什么快</p><ul><li><p>docker有着比虚拟机更少的抽象层。不需要Hypervisor实现硬件资源虚拟化，运行在docker上的程序直接使用的都是实际物理机硬件资源。因此在CPU、内存利用率上都有着更为明显的优势<br><img src="https://i.loli.net/2019/11/29/K9tEiTJuX5lnRdO.jpg" alt="docker.png"></p></li><li><p>docker利用的是宿主机的内核，而不是Guest OS。docker直接利用宿主机的操作系统，新建一个docker容器只需要几秒钟。</p></li></ul></li><li><p>Docker和虚拟机的区别</p></li></ul><p><img src="https://i.loli.net/2019/11/29/LsfpxybV6eXDHO5.jpg" alt="docker与虚拟机的区别.jpg"></p></li></ul><h3 id="Docker常用命令"><a class="header-anchor" href="#Docker常用命令">¶</a>Docker常用命令</h3><ul><li><p><code>docker info</code>，对Docker信息的概括</p></li><li><p><code>docker version</code>，查看Docker的版本</p></li><li><p><code>docker --help</code>，Docker命令的帮助</p></li><li><p>docker镜像命令</p><ul><li><p>docker images：列出<font color="red">本地</font>主机上所有的镜像，通过在最后指定镜像的名字，可以查看相应镜像的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY       TAG           IMAGE ID         CREATED           SIZE</span><br><span class="line">hello-world      latest        fce289e99eb9     11 months ago     1.84kB</span><br></pre></td></tr></table></figure><p>各项的说明：</p><ul><li>REPOSITORY：镜像的仓库源</li><li>TAG：镜像的标签</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建的时间</li><li>SIZE：镜像大小</li></ul><p>同一个仓库源下可以有多个TAG，代表这个仓库源的不同版本，我们可以使用<code>REPOSITORY:TAG</code>来定义不同的镜像。如果不指定一个镜像的版本标签，例如你只使用ubuntu，docker将默认使用ubuntu:latest镜像。<br></p><p>OPTIONS说明：</p><ul><li><code>-a</code>：列出本地所有的镜像（含中间映像层）</li><li><code>-q</code>：只显示镜像ID</li><li><code>--digests</code>：显示镜像的摘要信息</li><li><code>--no-trunc</code>：显示完整的镜像信息</li><li><code>-qa</code>：组合命令，显示所有的本地镜像的ID</li></ul></li><li><p>docker search 镜像名： 从<a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>中查找某个镜像（尽管之前配置了阿里云镜像，但是这里查找镜像还是从Docker Hub上查找，拉取的时候从阿里云上拉）<br></p><p>OPTIONS说明：</p><ul><li><code>-s</code>：指定显示STARTS数不小于某个值的镜像，如<code>docker search -s 30 tomcat</code>指定STARTS超过30的Tomcat镜像</li><li><code>--no-trunc</code>：显示完整的信息，不要省略，<code>docker search -s 30 --no-trunc tomcat</code></li><li><code>--automated</code>：只列出automated build（自动构建）类型的镜像，即列出AUTOMATED为ok的镜像</li></ul></li><li><p>docker pull 镜像名：下载镜像，可以在镜像名后添加 <code>:版本号</code> 来下载指定版本的镜像，默认不添加的时候下载latest的版本</p></li><li><p>docker rmi 镜像名[镜像ID]：删除镜像，多个镜像时，默认不添加时版本是删除latest版本的。docker rmi -f 镜像名强制删除，如果有某个镜像被多个镜像调用，则必须使用-f强制删除所有相关的镜像。</p><ul><li>删除多个：docker rmi 镜像名1[镜像ID] 镜像名2[镜像ID]</li><li>删除全部：docker rmi -f $(docker images -qa)，docker images -qa为组合命令，显示所有的镜像的ID</li></ul></li></ul></li><li><p>docker容器命令（以centos镜像为例）</p><ul><li><p>新建并启动容器：docker run [OPTIONS] IMAGES [COMMAND]</p><p>OPTIONS说明：</p><ul><li><p><code>--name</code>=‘容器新名字’：为容器指定一个新的名字</p></li><li><p><code>-d</code>：后台运行容器，并返回容器ID，也即启动守护式容器</p></li><li><p><code>-i</code>：以交互模式运行容器，通常与-t同时使用；</p></li><li><p><code>-t</code>：为容器重新分配一个伪输入终端，通常与-i同时使用； docker run -it 镜像 实际是得到一个容器的终端进行交互</p></li><li><p><code>-P</code>：随机端口映射</p></li><li><p><code>-p</code>：指定端口映射，有以下四种格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip:hostPort:containerPort</span><br><span class="line">ip::containerPort</span><br><span class="line">hostPort:containerPort</span><br><span class="line">containerPort</span><br></pre></td></tr></table></figure><p><strong>注意，<code>run 镜像：版本号</code>，如果未添加版本，则默认是latest版本的，所以若下载的不是latest版本，你不添加对应的版本号，则会去下载latest版本并运行。</strong></p></li></ul><p>COMMAND说明：</p><ul><li>该项目是可选项，可以指定运行容器时附加运行的指令，使用<code>docker run -it 镜像</code>创建实例的时候，即使不指定COMMAND为<code>/bin/bash</code>，默认不写该项时也是使用的这个。不使用-it参数，或者创建时没有指定一个前台运行的进程，创建的容器都会在创建之后由于没有前台进程而被自动kill掉。</li><li><strong>每个镜像都设置了其容器默认执行的相应的COMMAND，使得容器在被创建的时候，如果没有手动执行COMMAND，则会自动调用相应的默认的COMMAND指令，如tomcat镜像设置了其容器的默认COMMAND为&quot;<a href="http://catalina.sh" target="_blank" rel="noopener">catalina.sh</a> run&quot;，这样tomcat容器一创建完成就会调用这个命令，开始执行tomcat服务器。</strong></li></ul><p><strong>使用docker run [OPTIONS] IMAGES [COMMAND]时的 [OPTIONS] 很重要，像对于centos这种，由于其没有默认的前台进程，如果使用-d作为守护式进程启动的话，由于docker本身的问题，这个容器一被创建就会由于没有前台进程而会被自动kill，且使用docker start也无法启动该容器，所以除非有特殊需要，以后台运行时要指定一个前台进程，或者就使用-it以交互式的方式运行</strong></p><p>疑问：为什么使用<code>docker run -d centos</code>创建的容器，没有添加COMMAD时，会被kill，但是使用docker ps查看时显示COMMADN为<code>/bin/bash</code>，自带的？，那为什么又会被kill呢？<br><em>这是docker本身的问题，Docker容器需要运行一个使其保持活动状态的进程。只要命令继续运行，容器将继续运行。而centos自带的/bin/bash会一执行玩就结束了，所以没有前台进程，该容器就被终止了，所以需要能使容器长时间挂起的方法，即所以可以：</em></p><ol><li>执行一个死循环</li><li>使用<code>docker run -dit centos</code>即使用-d启动守护式容器的同时，使用-it为其分配一个交互式伪终端即可</li></ol></li><li><p>查看docker内运行的进程：<code>docker ps</code> 默认显示当前正在运行的容器</p><p>OPTIONS说明：</p><ul><li><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的</li><li><code>-l</code>：显示最近创建的容器</li><li><code>-n</code>：显示最近n个创建的容器</li><li><code>-q</code>：静默模式，只显示容器编号</li><li><code>--no-trunc</code>：不截断输出</li></ul></li><li><p>退出容器：</p><ul><li>exit：容器停止退出</li><li>ctrl+P+Q：容器不停止退出</li></ul></li><li><p>启动容器：<code>docker start 容器ID或者容器名</code>（若没有使用docker run --name 设置别名，则使用的的是默认的容器名）</p><ul><li>启动成功后会返回对应的容器ID，启动的容器执行的COMMAND为使用docker run命令创建容器时执行的COMMAND。</li><li><font color="red">可以通过<code>docker exec -it 容器ID bashShell</code>命令以命令行形式进入容器进行交互，如/bin/bash就会打开一个终端。</font></li></ul></li><li><p>重启容器：<code>docker restart 容器ID或者容器名</code>，重启成功后会返回对应的容器ID</p></li><li><p>停止容器：<code>docker stop 容器ID或者容器名</code>，关闭成功后会返回对应的容器ID</p></li><li><p>强制停止：<code>docker kill 容器ID或者容器名</code></p></li><li><p>删除已停止的容器：<code>docker rm 容器ID或者容器名</code>，一定要是停止的，否则会报冲突</p></li><li><p>删除没有停止的容器：<code>docker rm -f 容器ID或者容器名</code>，先关闭容器然后再删除</p></li><li><p>一次性删除多个容器</p><ul><li>docker rm -f $(docker ps -a -q)</li><li>docker ps -a -q | xargs docker rm</li></ul></li><li><p>灵活运用组合命令，如启动最近刚创建的容器，使用<code>docker start $(docker ps -lq)</code></p><ul><li>解释：docker start需要容器ID，docker ps -lq添加了-q，使其只返回容器ID.</li></ul></li></ul></li><li><p>重要</p><ul><li><p>启动守护式容器：<code>docker run -d 镜像名</code></p><ul><li>注意该命令没有指定创建容器要执行的命令COMMAND（且该镜像创建的容器默认的COMMAND不是一个长久的前台进程，如centos镜像的默认COMMAND为<code>&quot;/bin/bash&quot;</code>会在一执行完成就结束了，但是tomcat的COMMADN为<code>&quot;catalina.sh run&quot;</code>这个前台进程会一直执行并等待）<br><br>此时使用docker ps发现没有正在运行的容器，因为Docker容器后台运行<font color="red">必须</font>有一个前台进程，容器如果运行的不是那些一直挂起的命令（如运行top，tail），就会自动退出。<font color="red">所以最佳的解决方案是，将你要运行的程序以前台的形式运行。</font></li></ul></li><li><p>查看容器日志：<code>docker logs -f -t --tail 容器ID</code></p><ul><li><code>-t</code>：加入时间戳</li><li><code>-f</code>：跟随最新的日志打印</li><li><code>--tail 数字</code>：显示最后的多少条</li></ul><p>所谓日志，就是docker容器终端的操作以及输出，直接使用<code>docker run 镜像</code>或者<code>docker run -d 镜像的</code>方式创建的容器会直接停止（即使用docker ps是无法查看的，即没有再运行），原因是因为docker在后台启动后，没有前台交互，无事可做，所以自动kill了，但是在创建时添加参数如<code>docker run -d centos /bin/sh -c &quot;while true;do echo hello skylor;sleep 2;done&quot;</code>这条命令的作用是创建centos的容器并且在容器中不断输出hello skylor，这样docker容器就一直有一个运行的前台进程，就不会自动kill了。<br><br>或者使用-d启动的容器，会后台打印日志，如tomcat容器，这种容器使用-d以后台启动的方式启动后就不会直接被kill掉。<br><br>另外，在使用<code>docker start 容器ID</code>方式启动后容器会继续运行这个命令。</p></li><li><p>查看容器内运行的进程：<code>docker top 容器ID</code></p><ul><li>docker容器本质是就是运行的一个精简版的linux系统，所以大部分的linux命令和docker是通用的，有一些命令不行，另外由于是精简版，比如centos就没有vim，只有自带的vi，想使用vim，需要手动下载。</li></ul></li><li><p>查看容器内部的细节：<code>docker inspect 容器ID</code></p><ul><li>能够查看所有存在的容器的内部信息，不仅是正在运行的容器。以键值对的形式展示内部细节。</li></ul></li><li><p>进入<font color="red">正在运行的</font>容器并以命令行交互，注意是正在运行的容器，所以容器若是关闭的，需先使用<code>docker start 容器ID</code>命令进行启动容器。</p><ul><li>docker exec -it 容器ID bashShell， bashShell可以直接是操作命令，这样执行后，会直接返回命令的执行结果，而如果是/bon/bash，则会新开一个容器的终端并进入。</li><li>docker attach 容器ID，此时重新进入容器执行的默认的COMMAND。</li><li>以上两种方式的区别： attach直接进入容器启动命令的终端，不会启动新的进程，exec是在容器中打开新的终端，并且可以启动新的进程。<br><br><strong>推荐使用docker exec -it 容器ID bashShell的方式，因为这样会再新打开一个shell进行交互，使用exit退出时仅仅退出了新开启的shell，而不会由于退出原始的shell而导致容器被关闭</strong></li></ul></li><li><p>将容器内的文件拷贝到主机上，<code>docker cp 容器ID：容器的内路径 目的主机路径</code></p></li></ul></li></ul><h3 id="Docker镜像"><a class="header-anchor" href="#Docker镜像">¶</a>Docker镜像</h3><ul><li><p>是什么，镜像时一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的内容，包括代码、运行时、库、环境变量和配置文件。</p><ul><li><p>UnionFS联合文件系统：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统实Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><ul><li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各种文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li></ul></li><li><p>Docker镜像加载原理</p></li><li><p>分层的镜像，一个镜像是由好几层各种的其他的镜像叠加而成，当多个镜像都有相同的镜像层时只需保存一个。</p></li><li><p>为什么Docker镜像要采用这种分层结构呢：共享资源，比如说，有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一个base镜像，同时内存中也只需要加载一份base镜像，就可以为所有的容器服务了。而且镜像的每一层都可以被共享。</p></li></ul></li><li><p>特点：镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下都叫“镜像层”。</p></li><li><p>Docker镜像commit操作补充</p><ul><li><p>docker commit 提交<font color="red">容器</font>副本使之成为一个新的镜像</p></li><li><p>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名：[标签名]</p></li></ul></li></ul><h3 id="Docker容器数据卷"><a class="header-anchor" href="#Docker容器数据卷">¶</a>Docker容器数据卷</h3><ul><li><p>创建的容器对象只是关闭，没有删除的情况下，容器内的内容是不会丢失的，但是一旦容器被删除，则保存的内容就会丢失（当然也可以是使用docker commit生成一个新的镜像，使得数据成为镜像的一一部分保存下来），此时就需要使用Docker容器数据卷。</p></li><li><p>能干什么：容器间继承和共享数据，做数据的持久化，类似redis中的rdb和aof文件</p></li><li><p>是什么：卷就是目录或者文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性，卷的设计目的就是数据的持久化，完全能独立于容器的生存周期，因此Docker不会在容器删除时，删除其挂载的数据卷（类似于外置的活动存储器）<br>特点：</p><ol><li>数据卷可在容器之间共享或重用数据----使用同一个本地目录，实现了两个容器之间的数据共享</li><li>数据卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol></li><li><p>数据卷：容器内添加</p><ul><li><p>直接命令添加</p><ul><li>命令：<code>docker run -it -v /宿主机绝对路径目录:/容器内目录  镜像名</code>，/宿主机绝对路径目录和容器内目录都可以不存在，此时docker会自动创建，如果 <code>-v</code> 之后只有一个路径，则此路径为容器内目录，而宿主机目录则由docker默认创建，目录为<code>/var/lib/docker/volumes/</code>下。</li><li>查看数据卷是否挂载成功：使用<code>docker inspect 容器ID</code>查看<code>Volumes</code>和<code>VolumesRW</code>可以看到卷路径</li><li>容器和宿主机之间数据共享：在容器或主机的任意一方的共享目录中的所有操作都是共享的，文件属性也是一致的，任意一方的修改，另外一方都能看到并使用。</li><li>容器停止退出后，主机修改后数据是否同步：任然同步，内容是一致的</li><li>（带权限的）命令：<code>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro  镜像名</code>，其中的<code>:ro</code>的意思为readonly只读，使用此命令后，使用<code>docker inspect 容器ID</code>查看<code>VolumesRW</code>值为false，意思不是可读可写，而是变成了只读，即容器内的目录只能读，而不能写。（类似于外置活动硬盘进行了写保护）</li></ul></li><li><p>DockerFile添加</p><ul><li><p>是什么，是Docker镜像的编译文件</p></li><li><p>使用过程：</p><ol><li><p>根目录下创建docker文件夹并进入</p></li><li><p>可在Dockerfile中使用VOLUME指令来给镜像添加一个或者多个数据卷</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME[&quot;&#x2F;dataVolumeContainer&quot;,&quot;&#x2F;dataVolumeContainer2&quot;,&quot;&#x2F;dataVolumeContainer3&quot;]</span><br></pre></td></tr></table></figure><p>说明，出于可移植和分享考虑，用<code>-v 主机目录：容器目录</code>这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样特定的目录，所以VOLUME设置的都是<font color="red">在容器上的目录</font>。</p></li><li><p>File构建<br>创建一个Dockerfile脚本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos </span><br><span class="line">VOLUME [&quot;&#x2F;dataVolumeContainer&quot;,&quot;&#x2F;dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;finished,-------success&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>类似相当于下面的命令（但是要注意的是，出于可移植性考虑，Dokcerfile并不会在本地创建文件夹）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;host1:&#x2F;dataVolumeContainer1 -v &#x2F;host2:&#x2F;dataVolumeContainer2 centos &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li><li><p>build后生成镜像，将Dockerfile文件build为一个新的镜像，命令格式为 <code>docker build [OPTIONS] &lt;上下文路径/URL/-&gt;</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f &#x2F;root&#x2F;mydocker&#x2F;Dockerfile -t skylor&#x2F;centos .</span><br></pre></td></tr></table></figure><p><code>-f</code>: 设置构建镜像的Dockerfile文件（此时Dockerfile文件可不在当前目录下）。<br><code>-t</code>: 用于设置创建的镜像的名称和版本。</p><p>理解，这里的路径（上下文的问题），要注意，在执行该条命令的时候，有两种情况：</p><ol><li>是在含有要创建的镜像的Dockerfile文件所在的目录下，此时不使用-f指定Dockerfile文件的所在路径，docker会自动识别找到Dockerfile文件（当然前提是Dockerfile文件的命名必须是Dockerfile，而不能是其他的名字，如果是其他的名字，则就需要使用-f指定Dockerfile的具体路径，包括Dockerfile文件名）</li><li>是在任意的目录下，必须使用-f参数指定要创建的镜像的Dockerfile文件的所在路径（最好写全，也可以只要大致目录，docker会自动找到，同理，对于直接命名为Dockerfile的文件可以直接找到，但是对于命名为其他的Dockerfile文件，则需要写具体的路径，包括Dockerfile文件名）</li><li>上下文参数为根据当前执行<code>docker build</code>命令的目录为准，这个目录就是所谓的上下文，而在Dockerfile文件中执行COPY等命令时，如<code>COPY ./package.json /app/</code>这里的 <code>.</code> 指的是上下文路径，这是个相对路径，以上下文为基础。<br><br><strong>一般都是新建一个文件夹，然后在其中添加Dockerfile文件，然后只要使用 <code>docker build -t 镜像名：版本号 .</code> 就完成了镜像的创建。</strong></li></ol></li><li><p>run容器</p></li><li><p>对于设置了卷的镜像，在使用run创建容器后，会有一个默认的主机的目录地址用于与容器内的目录进行共享</p></li><li><p>主机对应默认地址：使用<code>docker inspect 容器ID</code>进行查看</p></li></ol></li></ul></li><li><p>备注：在使用<code>docker run -it -v /host1:/dataVolumeContainer1 -v /host2:/dataVolumeContainer2 centos</code>的方式给容器挂载主机目录，Docker访问出现<code>cannot open directory.: Permission denied</code>时，解决办法为：添加<code>--privileged=true</code>参数，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;host1:&#x2F;dataVolumeContainer1 -v &#x2F;host2:&#x2F;dataVolumeContainer2 --privileged&#x3D;true centos</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据卷容器：命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，这个用于挂载数据卷的容器，称之为数据卷容器</p><ul><li>命令：在创建容器时添加<code>--volumes-from</code>参数即可<ul><li>首先需要先创建一个含有数据卷的容器作为初始的数据卷容器</li><li>之后使用<code>docker run -it --volumes-from 数据卷容器ID 镜像</code>来创建新的容器，则该新建的容器会在其内部创建与数据卷容器含有相同的文件目录用于数据共享。</li><li>所有的共享的容器不需要是同一种镜像创建</li><li>新创建的容器也可以作为数据卷容器去被其他的新容器使用</li><li>任何的容器之间都可以进行数据共享</li><li>首先创建的的数据卷容器的本地目的可以同时对所有的容器进行共享</li></ul></li></ul><p>容器之间配置信息的传递，数据卷生命周期一致持续到没有容器使用它为止。</p></li></ul><h3 id="Dockerfile解析"><a class="header-anchor" href="#Dockerfile解析">¶</a>Dockerfile解析</h3><ul><li><p>是什么：Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p></li><li><p>构建三步骤：</p><ul><li>编写Dockerfile文件</li><li>docker build</li><li>docker run</li></ul></li><li><p>文件结构（以centos镜像为例）</p><ul><li><p>Dokcerfile内容基础知识</p><ul><li>每条保留字指令都必须是大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像层进行提交</li><li>最终暴露出来最终的镜像文件</li></ul></li><li><p>Docker执行Dockerfile文件的大致流程</p><ul><li>docker从基础镜像运行一个容器–对应于Dockerfile文件中的<code>FROM 镜像</code></li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行Dockerfile中的下一条指令知道所有指令都执行完成</li></ul></li></ul></li><li><p>Dockerfile体系结构（保留字指令）</p><ul><li><p>FROM：基础镜像，当前新镜像是基于哪个镜像的</p></li><li><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p></li><li><p>RUN：容器构建时要运行的命令</p></li><li><p>EXPOSE：当前容器对外暴露出的端口</p></li><li><p>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，如果不设置的话，默认应该是根目录 /</p></li><li><p>ENV：用来在构建镜像的过程中设置环境变量</p><ul><li>类似键值对的形式，如<code>ENV MY_PATH /usr/mytest</code>，是创建了一个名为MY_PATH，对应的值为/usr/mytest的环境变量，这个环境变量可以在后续的任何RUN指令中使用，也可以在其他指令中直接使用这些环境变量，如：<code>WORKDIR $MY_PATH</code></li></ul></li><li><p>ADD：拷贝加解压缩。将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p></li><li><p>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</p><ul><li>COPY src dest  &lt;— shell格式</li><li>COPY [“src”, “dest”]    &lt;— json格式</li></ul></li><li><p>VOLUME：容器数据卷，用于数据保存和持久化工作，如<code>VOLUME [&quot;/dataVolumeContainer&quot;, &quot;/dataVolumeContainer2&quot;]</code></p></li><li><p>CMD：指定一个容器启动时要运行的命令</p><ul><li>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</li></ul></li><li><p>ENTRYPOINT：指定一个容器启动时要运行的命令</p><ul><li>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数</li><li>和CMD的区别在，CMD会被docker run之后的参数替换，但是使用ENTRYPOINT时，docker run之后添加的命令不会覆盖掉ENTRYPOINT，而是变为追加模式，即将原有的命令和docker run新添加的命令组成一个新的命令去执行。</li></ul></li><li><p>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子镜像继承后父镜像的onbuild被触发，是一个触发器。</p></li><li><p>.dockerignore：类似于git中的.gitignore，用于设置需要忽略的上下文中的构建镜像时不需要用到的文件，使其在使用docker build时不需要都上传至docker引擎，而造成的速度缓慢。</p></li></ul></li><li><p>Dockerfile实际操作案例：镜像就是<a href="###Docker%E9%95%9C%E5%83%8F">一堆分层的文件</a></p><ul><li><p>Base镜像（scratch）:Docker Hub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建而来的</p></li><li><p>自定义镜像 mycentos：对官方版的centos镜像重构为新的镜像mycentos，使其能够</p><ol><li>登录后的默认路径不在根目录</li><li>添加vim编辑器</li><li>支持使用ifconfig查看网络配置</li></ol><p>Dokcerfile内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER skylor&lt;tang1996mei@126.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success-------------------ok&quot;</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure><p>docker引擎将Dockerfile文件分解为10个步骤，每执行一层会得到一个中间容器，但是在执行完该步骤之后会卸载这个生成的中间容器层，除此以外还有中间层镜像（很多镜像依赖这些中间层，所以中间层镜像是不能随意删除的）<br><br>使用<code>docker history 镜像名</code>查看镜像变更历史</p></li><li><p>CMD/ENTRYPOINT 镜像案例</p><ul><li>都是指定一个容器启动时要运行的命令</li><li>CMD: Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</li><li>ENTRYPOINT: 相比CMD，使用ENTRYPOINT时，docker run之后添加的命令不会覆盖掉ENTRYPOINT，而是变为追加模式，即将原有的命令和docker run新添加的命令组成一个新的命令去执行。</li></ul></li><li><p>自定义镜像 Tomcat9</p><ul><li><p>建立本地Dockerfile文件夹，<code>mkdir -p /root/mydockerfile/tomcat9</code></p></li><li><p>在上述目录下touch c.txt</p></li><li><p>将jdk和tomcat安装的压缩包拷贝进上一步的目录中，<code>apache-tomcat-9.0.8.tar.gz</code>,<code>jdk-8u171-linux-x64.tar.gz</code></p></li><li><p>在<code>/root/mydockerfile/tomcat9</code>目录下新建Dockerfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">FROM  centos</span><br><span class="line">MAINTAINER skylor&lt;tang1996mei@126,com&gt;</span><br><span class="line"></span><br><span class="line"># 把宿主机当前上下文的copy.txt文件拷贝到容器&#x2F;usr&#x2F;local&#x2F;路径下</span><br><span class="line">COPY copy.txt &#x2F;usr&#x2F;local&#x2F;cincontainer.txt</span><br><span class="line"></span><br><span class="line"># 把java和tomcat添加到容器中</span><br><span class="line">ADD apache-tomcat-9.0.8.tar.gz &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br><span class="line"># 安装vim</span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line"># 设置工作访问时候的WORKDIR路径，登录落脚点</span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line"># 配置java和tomcat环境变量</span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_171</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">ENV CATALINA_HOME &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8</span><br><span class="line">ENV CATALINA_BASE &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME&#x2F;bin:$CATALINA_HOME&#x2F;lib:$CATALINA_HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line"># 容器运行时监听端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"># 启动时运行tomcat</span><br><span class="line"># ENTRYPOINT [&quot;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;startup.sh&quot;]</span><br><span class="line"># CMD [&quot;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;startup.sh &amp;&amp; tail -F &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;logs&#x2F;catalina.out</span><br></pre></td></tr></table></figure></li><li><p>构建： 在当前目录下<code>docker build -t centos_tomcat9 .</code></p></li><li><p>run： <code>docker run -d -p 9080:8080 -v /hostdatavolume/centos_tomcat9/test:/usr/local/atache-tomcat-9.0.8/webapps/test -v /hostdatavolume/centos_tomcat9/tomcatlogs/:/usr/local/apache-tomcat-9.0.8/logs --privileged=true --name ct9 centos_tomcat9</code></p></li></ul></li></ul></li></ul><h3 id="几个基本镜像的使用"><a class="header-anchor" href="#几个基本镜像的使用">¶</a>几个基本镜像的使用</h3><ul><li><p>mysql镜像:</p><ul><li>run命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 12345:3306 --name mysql -v /hostdatavolume/mysql5.6/conf:/etc/mysql/conf.d -v /hostdatavolume/mysql5.6/logs:/logs -v /hostdatavolume/mysql5.6/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</span><br></pre></td></tr></table></figure><code>-e MYSQL_ROOT_PASSWORD=123456</code>是对mysql的明码进行设置</li></ul></li><li><p>redis镜像：</p><ul><li>run命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -v /hostdatavolume/redis3.2/data:/data -v /hostdatavolume/redis3.2/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure><code>redis-server /usr/local/etc/redis/redis.conf --appendonly yes--appendonly yes</code>是redis用于配置数据持久化的</li></ul></li><li><p>说明： 需要使用端口的镜像，创建容器的时候都需要做端口映射，<code>-p 宿主机端口：容器使用端口</code>会将端口映射到本地的端口，使用<code>- P</code>则会随机分配一个端口。</p></li></ul><h3 id="本地镜像发布到阿里云"><a class="header-anchor" href="#本地镜像发布到阿里云">¶</a>本地镜像发布到阿里云</h3><ul><li><p>使用docker commit命令提交一个本地的修改容器为新的镜像</p><ul><li><p>docker commit 提交<font color="red">容器</font>副本使之成为一个新的镜像</p></li><li><p>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名：[标签名]</p></li></ul></li><li><p>阿里云提供了完善的提交方案</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之面向“对象”</title>
      <link href="2019/11/10/%E9%9D%A2%E5%90%91%E2%80%9C%E5%AF%B9%E8%B1%A1%E2%80%9D/"/>
      <url>2019/11/10/%E9%9D%A2%E5%90%91%E2%80%9C%E5%AF%B9%E8%B1%A1%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h1>面向对象</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">  Left, Right *TreeNode</span><br><span class="line">  Value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span> <span class="title">traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  root.Left.traverse()</span><br><span class="line">  fmt.Println(root.Value)</span><br><span class="line">  root.Right.traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>go语言仅支持封装，不支持继承和多态</li><li>继承和多态使用接口实现</li><li>go语言没有class ,只有struct</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> treeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Value  <span class="keyword">int</span></span><br><span class="line">Left, Right *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 以下分别使用了3中不同结构初始化方法</span></span><br><span class="line"><span class="keyword">var</span> root treeNode</span><br><span class="line">root = treeNode&#123;Value: <span class="number">3</span>&#125;</span><br><span class="line">  root.Left = &amp;treeNode&#123;&#125;   <span class="comment">// 此句的效果和使用new()的效果是一样的。</span></span><br><span class="line">root.Right = &amp;treeNode&#123;<span class="number">5</span>, <span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">root.Right.Left = <span class="built_in">new</span>(treeNode)    <span class="comment">// 内建函数new，将创建一个指定类型的匿名变量，返回的是类型指针</span></span><br><span class="line">nodes_slice := []treeNode &#123;</span><br><span class="line">&#123;Value: <span class="number">3</span>&#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#123;<span class="number">6</span>,<span class="literal">nil</span>,&amp;root&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(nodes_slice)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[&#123;<span class="number">3</span> &lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">0</span> &lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">6</span> &lt;<span class="literal">nil</span>&gt; <span class="number">0xc00009c020</span>&#125;]</span><br></pre></td></tr></table></figure><p><code>new (Type) *Type</code>函数为内建函数，接受值为类型，会在内部申请一块该类型的空间并进行清零，然后返回指向该地址的指针，是一个值为空的结构的地址&amp;{}，和nil不一样。</p><p>上面演示了创建结构的创建以及初始化，初始化时可以只给个别值赋值，则其余值为该类型的零值，或者都不赋初值。赋值时采用类似字典的方式k:v 的形式进行赋值。</p><p>也可以使用<code>变量名.结构体内部变量</code>的方式来赋值</p><ul><li>不论地址还是结构本身，一律使用.来访问成员</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNode</span><span class="params">(value <span class="keyword">int</span>)</span> *<span class="title">treeNode</span></span>&#123;</span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="keyword">return</span> &amp;treeNode&#123;Value:value&#125;  <span class="comment">//c++中会有局部变量的问题，在c++中此处就是返回的局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">root.Left.Right = createNode(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>使用自定义工厂函数</li><li>注意返回了局部变量地址！（局部变量在函数执行结束后会进行垃圾回收，函数内声明的局部变量会消失，局部变量地址也就没有意义了）但是这在go语言中是没有问题的</li></ul><p>Go语言的结构创建在堆上还是栈上？</p><ul><li>不需要知道</li><li>堆上分配的会参与垃圾回收，Go语言会自动根据变量是否会被使用决定分配的情况，像上面的函数中的treeNode在函数退出后并没有消失，所以放在堆中，参与垃圾回收，当不在被使用后会被回收，而不是像c++中的函数内是局部变量，一旦退出函数后，就消失。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构方法一：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为结构定义方法， 放到结构外面  func (接收者) 函数名(普通参数) &#123;&#125;</span></span><br><span class="line"><span class="comment">// 事实上接受者是结构方法的第一个参数，类似Python中类实例方法的self参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(node.Value)</span><br><span class="line">&#125;</span><br><span class="line">root.<span class="built_in">print</span>()   <span class="comment">// print()函数有一个参数，为接收者 node</span></span><br></pre></td></tr></table></figure><p><code>(node treeNode)</code>是调用的结构对象，可以理解为将原先<code>func print(node treeNode)</code>后面的参数前移动了，<code>print()</code>函数名之后依然是可以放其他参数的，总的来说就是，将调用者前移，其他的和普通的函数调用没有区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构方法二：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">setValue</span><span class="params">(value <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="comment">// 因为go语言都是值传递类型，所以此处的node都是值传递，将node复制了一份，执行修改操作并不会修改原始的数据，包括左右子树的指针类型</span></span><br><span class="line"><span class="comment">// 所以node 使用指针</span></span><br><span class="line">node.Value = value  <span class="comment">// go语言中，使用指针都可以省略*     (*node).Value = value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Go语言都是值传递，所以，若在此处使用值类型，对node的修改是不会反映到实际节点上的，因为在调用的时候是将节点重新复制了一份去操作的。所以，若设计到修改，都需传递指针。</p><p>因为结构方法node可以是值传递接受值，也可能是指针传递接受地址，所以，Go编译器对结构方法的调用相当智慧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构方法的使用</span></span><br><span class="line">root.<span class="built_in">print</span>()   <span class="comment">// print()函数有一个参数，为接收者 node</span></span><br><span class="line">root.setValue(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 结构方法调用时相当人性化，会自动进行相应的转换</span></span><br><span class="line"><span class="comment">// root.print()中的node是值类型，root是值类型，这里会直接复制一份</span></span><br><span class="line"><span class="comment">// root.setValue()中的node是指针类型，而root是值，所以go会自动将node转为root的地址</span></span><br><span class="line">pRoot := &amp;root</span><br><span class="line">pRoot.<span class="built_in">print</span>()</span><br><span class="line">pRoot.setValue(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 这里的pRoot是指针类型，存储的是地址</span></span><br><span class="line"><span class="comment">// pRoot.print()中的node是值类型，这里会将pRoot地址的值得到复制一份</span></span><br><span class="line"><span class="comment">// pRoot.setValue()中node正好需要指针</span></span><br></pre></td></tr></table></figure><h2 id="结构方法小结"><a class="header-anchor" href="#结构方法小结">¶</a>结构方法小结</h2><ul><li><p>显示定义和命名方法的接受者</p></li><li><p>只有指针才能改变结构内容</p></li><li><p>nil指针也可以调用方法！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">setValue</span><span class="params">(value <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Setting value to nill "</span> +</span><br><span class="line"><span class="string">"node. Ignore"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">node.Value = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pRoot *treeNode  <span class="comment">// 指针类型的默认初始值为nil</span></span><br><span class="line">fmt.Println(pRoot.setValue(<span class="number">200</span>))</span><br></pre></td></tr></table></figure><p>会正常执行，因为nil也是可以直接使用的，但是要注意，nil直接使用了，但是这里不能取到value，所以做一下判断，直接return结束函数。</p></li></ul><h2 id="遍历树"><a class="header-anchor" href="#遍历树">¶</a>遍历树</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">node.Left.traverse()  <span class="comment">// 相比c++ 和 java ，此处不需要先判断node.left != nil ，因为即使为nil，也是可以进行运算的</span></span><br><span class="line">node.<span class="built_in">print</span>()</span><br><span class="line">node.Right.traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Go中的nil可以进行运算，所以traverse()处不需要判断，只要进入方法后，判断一下就行。</p><h2 id="值接收者vs指针接收者"><a class="header-anchor" href="#值接收者vs指针接收者">¶</a>值接收者vs指针接收者</h2><p>接收者是在<code>结构</code>方法中的概念，在结构方法中用来代表结构对象，类似于Python类实例方法中的self</p><ul><li>要改变内容的必须使用指针接收者</li><li>结构过大也考虑使用指针就收者，因为使用值接收者的话要拷贝，结构过大，造成资源浪费</li><li>一致性：如有指针接收者，最好都是指针接收者</li><li>值接收者是Go语言特有</li><li>值/指针接收者均可接收值/指针，Go编译器会自动转换</li><li>一般较多使用的时候都是指针接受者 ，因为涉及到改变内容的操作较多</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtualenvwrapper 使用</title>
      <link href="2019/11/02/virtualenvwrapper-%E4%BD%BF%E7%94%A8/"/>
      <url>2019/11/02/virtualenvwrapper-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum install python-setuptools python-devel</span><br><span class="line"><span class="comment"># 使用pip进行安装</span></span><br><span class="line">pip3 install virtualenvwrapper</span><br></pre></td></tr></table></figure><h2 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2><p>编辑.bashrc文件，配置virtualenvwrapper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs  <span class="comment"># 设置虚拟环境存放的地址</span></span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 <span class="comment"># 指定默认的创建虚拟环境使用的python版本，不设置时在装有多个版本的python时可能会导致问题</span></span><br><span class="line"><span class="built_in">source</span> /usr/virtualenvwrapper.sh   <span class="comment"># 这里使用find / -name virtualenvwrapper.sh找到文件的正确位置</span></span><br></pre></td></tr></table></figure><p>配置完成之后，使用 <code>source .bashrc</code> ，使配置生效</p><h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2><h3 id="新建虚拟环境"><a class="header-anchor" href="#新建虚拟环境">¶</a>新建虚拟环境</h3><p><code>mkvirtualenv env_name</code></p><h4 id="使用指定的解释器版本创建虚拟环境"><a class="header-anchor" href="#使用指定的解释器版本创建虚拟环境">¶</a>使用指定的解释器版本创建虚拟环境</h4><p><code>mkvirtualenv [-p 解释器路径] env_name</code></p><blockquote><p>注意：使用的解释器需要是当前系统中已经存在的</p></blockquote><h3 id="进入虚拟环境"><a class="header-anchor" href="#进入虚拟环境">¶</a>进入虚拟环境</h3><p><code>workon env_name</code></p><h3 id="退出虚拟环境"><a class="header-anchor" href="#退出虚拟环境">¶</a>退出虚拟环境</h3><p><code>deactivate env_name</code></p><h3 id="查看已有的虚拟环境"><a class="header-anchor" href="#查看已有的虚拟环境">¶</a>查看已有的虚拟环境</h3><p><code>workon</code></p><h3 id="生效"><a class="header-anchor" href="#生效">¶</a>生效</h3><p><code>workon env_name</code></p><h3 id="退出"><a class="header-anchor" href="#退出">¶</a>退出</h3><p><code>deactivate [env_name]</code></p><h3 id="删除已有的虚拟环境"><a class="header-anchor" href="#删除已有的虚拟环境">¶</a>删除已有的虚拟环境</h3><p><code>rmvirtualenv env_name</code></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pipenv 使用</title>
      <link href="2019/11/01/pipenv%E4%BD%BF%E7%94%A8/"/>
      <url>2019/11/01/pipenv%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="优势"><a class="header-anchor" href="#优势">¶</a>优势</h3><ul><li>保存包的依赖关系，不需要requirements.txt文件，使用<code>pipenv graph</code>来查看包的依赖关系</li><li>不需要先激活虚拟环境，只需要在虚拟环境的文件夹下直接使用<code>pipenv</code>命令即可，当然也可以使用<code>pipenv shell</code>激活当前的虚拟环境<ul><li>激活虚拟环境后可以使用Python自带的<code>pip list</code>来产看安装了哪些包，当然可以直接查看Pipfile文件，以及使用<code>pipenv graph</code>来查看包的依赖关系</li></ul></li><li>实际上是将虚拟环境和包管理联系起来，包的信息保存在项目中的Pipfile和Pipfile.lock中，代替了requirements.txt的作用，创建的虚拟环境需要和项目中的Pipfile、Pipfile.lock文件配合使用。在项目下使用<code>pipenv shell</code>激活相应的虚拟环境</li><li>删除虚拟环境的时候不需要先激活虚拟环境</li></ul><h3 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h3><ul><li>使用<code>pip install pipenv</code>进行安装</li></ul><h3 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h3><ul><li>使用之前先要创建一个文件夹，存档Pipfile文件<ul><li>建议修改Pipfile中的url，修改安装包时的源，改为国内的<code>https://mirrors.aliyun.com/pypi/simple</code></li></ul></li><li><code>pipenv --three</code>会使用当前系统的Python3创建环境</li><li>也可以使用<code>pipenv --python 版本号</code>来创建环境</li><li>创建完成后，使用<code>pipenv shell</code>激活虚拟环境<ul><li>注意，在未创建虚拟环境的情况下，使用该命令，会在当前文件夹下创建以文件夹命名的虚拟环境并启用该虚拟环境</li></ul></li><li>注意以下三个命令只能在创建好的文件夹下（即含有Pipfile文件的文件夹）执行<ul><li>使用<code>pipenv --where</code>显示项目目录信息，为当前创建的文件夹的路径</li><li>使用<code>pipenv --venv</code>显示虚拟环境定义的路径</li><li>使用<code>pipenv --py</code>显示Python解释器路径</li></ul></li></ul><h3 id="虚拟环境的使用"><a class="header-anchor" href="#虚拟环境的使用">¶</a>虚拟环境的使用</h3><ul><li><p>在虚拟环境中<code>pipenv</code>基本代替<code>pip</code>的使用</p></li><li><p>安装库，并添加到Pipfile中</p><ul><li><code>pipenv install 模块</code>进行相应的库的安装<ul><li><code>pipenv install 模块==版本号</code>可以安装指定版本的库</li><li>安装时，会创建Pipfile.lock文件，用来保证包不被恶意篡改，但是这个过程是耗时的，我们可以在安装模块的时候添加参数，跳过该步骤<code>pipenv install requests --skip-lock</code></li></ul></li></ul></li><li><p>Pipfile文件的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[source]]                                                                                                            </span><br><span class="line">name = <span class="string">"pypi"</span>                                                                                                         </span><br><span class="line">url = <span class="string">"https://pypi.org/simple"</span>                                                                                       </span><br><span class="line">verify_ssl = true                                                                                                     </span><br><span class="line"></span><br><span class="line">[dev-packages]                                                                                                        </span><br><span class="line"></span><br><span class="line">[packages]                                                                                                            </span><br><span class="line"></span><br><span class="line">[requires]                                                                                                            </span><br><span class="line">python_version = <span class="string">"3.7"</span></span><br></pre></td></tr></table></figure><p>其中<code>[dev-packages]</code>为开发环境安装的包，使用<code>pipenv install --dev requests --skip-lock</code>创建在开发环境下的包</p></li><li><p><code>pipenv graph</code>查看当前安装的库以及依赖</p></li><li><p><code>pipenv update</code>会将当前安装的包全部卸载并安装最新的包</p></li><li><p><code>pipenv check</code>检查安全漏洞</p></li><li><p><code>pipenv uninstall --all</code>卸载全部包并从Pipfile中移除</p></li><li><p><code>exit</code>退出当前的虚拟环境</p></li><li><p>使用<code>pipenv --rm</code>删除当前的虚拟环境</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之字符和字符串处理</title>
      <link href="2019/11/01/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
      <url>2019/11/01/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>rune类型就相当于Go语言中的char，占4个字节，为int32别名</p><p>使用range遍历 <code>postion, rune </code>对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"Yes我爱Go语言!"</span> <span class="comment">// UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%X "</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> s &#123;     <span class="comment">// ch is a rune</span></span><br><span class="line">  fmt.Printf(<span class="string">"(%d %X) "</span>, i, ch)</span><br><span class="line">  <span class="comment">// ch这里是int32,就是rune，为4字节，但是utf-8类型在这里转成了unicode2字节型存储</span></span><br><span class="line">  <span class="comment">// 所以4字节中只占了两个字节 (3 6211)</span></span><br><span class="line">  <span class="comment">// 因为遍历的是单个字节，但是返回的是position rune对，所以跳过了中间的字符的单字节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">59</span> <span class="number">65</span> <span class="number">73</span> E6 <span class="number">88</span> <span class="number">91</span> E7 <span class="number">88</span> B1 <span class="number">47</span> <span class="number">6</span>F E8 AF AD E8 A8 <span class="number">80</span> <span class="number">21</span> </span><br><span class="line">(<span class="number">0</span> <span class="number">59</span>) (<span class="number">1</span> <span class="number">65</span>) (<span class="number">2</span> <span class="number">73</span>) (<span class="number">3</span> <span class="number">6211</span>) (<span class="number">6</span> <span class="number">7231</span>) (<span class="number">9</span> <span class="number">47</span>) (<span class="number">10</span> <span class="number">6</span>F) (<span class="number">11</span> <span class="number">8</span>BED) (<span class="number">14</span> <span class="number">8</span>A00) (<span class="number">17</span> <span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>使用<code>utf8.RuneCountInString</code>获得字符的数量，因为使用len()只能获得字节数（英文占1个字节，中文3个utf-8编码下）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"len count"</span>:<span class="built_in">len</span>(s))    <span class="comment">//18</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Rune count:"</span>, utf8.RuneCountInString(s))     <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>使用<code>[]byte</code>获得字节，使用<code>[]rune</code>会获得字符切片， 实际上是用该类型的切片进行强制转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"Yes我爱Go语言!"</span> <span class="comment">// UTF-8</span></span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%X "</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">59</span> <span class="number">65</span> <span class="number">73</span> E6 <span class="number">88</span> <span class="number">91</span> E7 <span class="number">88</span> B1 <span class="number">47</span> <span class="number">6</span>F E8 AF AD E8 A8 <span class="number">80</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>使用<code>utf8.DecodeRune</code>将utf8解码为四字节unicode，但是Unicode中文编码只用了两个字节</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s := <span class="string">"我"</span> <span class="comment">// UTF-8</span></span><br><span class="line">  a := []<span class="keyword">byte</span>(s)</span><br><span class="line">  ch, size := utf8.DecodeRune(a)</span><br><span class="line">  fmt.Printf(<span class="string">"%X, %d"</span>,ch, size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">6211</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure><p>字符串的其他操作，都在<code>strings.</code>包内</p><ul><li>Fieds Split Join</li><li>Contains, Index</li><li>ToLower ToUpper</li><li>Trim TrimRight TrimLeft</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之内建容器</title>
      <link href="2019/10/30/%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8-%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87/"/>
      <url>2019/10/30/%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8-%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1>数组</h1><p>数组的类型名是 <code>[n]elementType</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr0 []<span class="keyword">int</span>      <span class="comment">// 这种写法是不对的，该写法为数组的切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span>              <span class="comment">// 定义数组的同时指定数组的长度</span></span><br><span class="line">arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;      <span class="comment">// 使用短变量声明的同时赋初始值</span></span><br><span class="line">arr3 := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">3</span>,<span class="number">8</span>:<span class="number">3</span>&#125;    <span class="comment">// 可以在指定数组长度之后，使用 下标：内容 的方式指定特定的值。</span></span><br><span class="line">arr3 := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">3</span>,<span class="number">8</span>:<span class="number">2</span>&#125;   <span class="comment">// 若是没有指定数组长，则默认使用最大下标的值加1为长度值</span></span><br><span class="line">arr4 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;  <span class="comment">// 长度交给编译器 使用... 代替</span></span><br><span class="line"><span class="keyword">var</span> grid [<span class="number">4</span>][<span class="number">5</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>注意</p><ul><li>变量名写在数组之前</li><li>不对数组长度规定的时候，一定要使用<code>...</code>来代替长度。</li><li><font color="red">Go数组的度的长度是固定的，一旦指定，不可以变化，但是数组的值是可以改变的。并且数组的长度是数组类型的组成部分，[10]int和[20]int表示的是不同的类型</font></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a  = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">43</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, a)  <span class="comment">//[]int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b  = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">43</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, b)  <span class="comment">//[3]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：数组的声明中<code>[]</code>中一定要有长度限制，或者使用<code>...</code>代替，此时会自动设置为实际长度，如果什么都没有，则是切片的声明方式，内部的执行过程是先创建一个数组，然后再赋值给了一个切片。</p><h2 id="数组的遍历"><a class="header-anchor" href="#数组的遍历">¶</a>数组的遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr3); i++&#123;</span><br><span class="line">  fmt.Println(arr3[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在遍历<font color="red">数组</font>的时候，有一个专门的关键字<code>range</code>关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> arr3 &#123;   <span class="comment">// range关键字专门用于获取数组的下标</span></span><br><span class="line">  fmt.Println(arr3[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rang关键字也可以用来获取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> arr3 &#123;   <span class="comment">// range关键字专门用于获取数组的下标</span></span><br><span class="line">  fmt.Println(i, v )   <span class="comment">// i 是下标，v 为下标对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若只想获得值，可以使用_来接受下标</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr3&#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型-—-作为函数参数是值传递"><a class="header-anchor" href="#数组是值类型-—-作为函数参数是值传递">¶</a>数组是值类型 — 作为函数参数是值传递</h2><ul><li>调用<code>func f(arr [10]int)</code>会拷贝数组</li></ul><p>是类型意味着在作为函数参数进行传递时，传递的是拷贝值，在函数体内对传递的数组进行操作，不会修改原有的数组。</p><p>Go语言中都是值传递，意味着传递时会拷贝。</p><p>Go语言中，<code>[5]int</code>和<code>[3]int</code>是两中不同的类型，不能相互之间被使用赋值。</p><p>若想传递的时候可以对数组进行改变而不是值传递，可以使用指针的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">100</span>                   <span class="comment">// 注意此处的写法，等价于(*arr)[0]=100</span></span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printArray(&amp;arr1)   <span class="comment">// 使用时，也传递的是数组的引用&amp;数组名</span></span><br></pre></td></tr></table></figure><p>上面的例子中<code>arr[0] = 100 </code>中，使用数组指针的话，可以不使用<code>*</code>进行调用，而是直接在函数内使用数组名，这是十分灵活以及方便的，当然也可以使用<code>*</code>，但是需要使用括号<code>(*arr)[0] = 100</code>这样的赋值方式。rang后可以直接用<code>for i:= range *arr</code>效果和<code>for i:= range arr</code>一致。</p><ul><li>在Go语言中一般不直接使用数组，而是使用的切片（切片名实际上是一个指针类型，拥有指针的属性）</li></ul><h1>切片（Slice)    —   相当于可变数组</h1><p>Go语言数组的定长性和值拷贝限制了其使用场景，Go提供了另一个数据类型slice， 是一种可变长数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]                       <span class="comment">// 切片下标不能超过原先数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s 就是切片 值为[2,3,4,5]</span></span><br></pre></td></tr></table></figure><p>Slice &quot;不是&quot;值类型（当然，Go语言所有的类型都是值类型），但是Slice内部有一个数据结构，是对array的一个view视图，<font color="red" size="4">所以对Slice的操作也会影响到原array的数据内容。</font><br>slice的结构中有指向数组的指针，所以实际上是一种引用类型，切片的操作会影响到原数组内容，切片变量名可以直接作为指针使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, s1)  <span class="comment">// 可以发现，切片变量名是一个指针，指向了切片的第一个元素的地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;s1[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;arr[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">b := &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,b)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,&amp;a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">0xc000018210</span></span><br><span class="line"><span class="number">0xc000018210</span></span><br><span class="line"><span class="number">0xc000018210</span></span><br><span class="line"></span><br><span class="line"><span class="number">0xc00001e0d0</span></span><br><span class="line"><span class="number">0xc00001e0d0</span></span><br></pre></td></tr></table></figure><p>结论：切片变量名可以作为指针使用，执行切片的第一个元素。不过这里要和切片类型的指针区分，后者指的是切片的位置指针（但是这个特性好像没有用，因为只是首位的元素地址不能代表切片，而且Golang中是不支持指针运算的，知晓了第一元素地址也不能以此类推到第二个元素等等）。</p><p>切片的内部构造：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtinme/slice.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line"><span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">s1 := arr[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"s1 = "</span>, s1)</span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">100</span>   <span class="comment">// 对切片进行操作，会修改原先的数组值</span></span><br><span class="line">fmt.Println(<span class="string">"arr = "</span>,arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">s1 =  [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">arr =  [<span class="number">0</span> <span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>可见对切片的操作会反映到原数组上。<code>（ 和Python不一样，Python的slice是对数组的截断拷贝，对切片的操作不会影响到Python列表（数组））</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;     <span class="comment">// 此处使用的是切片，因为没有指定数组大小  </span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"arr[2:6] ="</span>, arr[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line">fmt.Println(<span class="string">"arr[:6] ="</span>, arr[:<span class="number">6</span>])</span><br><span class="line">s1 := arr[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"s1 ="</span>, s1)</span><br><span class="line">s2 := arr[:]</span><br><span class="line">fmt.Println(<span class="string">"s2 ="</span>, s2)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"After updateSlice(s1)"</span>)</span><br><span class="line">  updateSlice(s1)   <span class="comment">// 需要注意的是，函数updateSlices()接受的参数为切片，所以这里传递的参数也需要为切片</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了切片，之前的对数组使用指针的操作就不需要了（因为切片内部保存了数组的指针，实际操作都会注册在原先的数组上面），而是使用切片，就可以实现同样的效果。唯一需要注意的是，含有切片参数的函数接受的参数也需要为切片。</p><h2 id="Reslice"><a class="header-anchor" href="#Reslice">¶</a>Reslice</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Println(<span class="string">"s"</span>,s)</span><br><span class="line">s = s[:<span class="number">3</span>]                    <span class="comment">// 切片可以在切片的基础上继续切片</span></span><br><span class="line">fmt.Println(<span class="string">"s"</span>,s)</span><br><span class="line">s = arr[:]</span><br><span class="line">fmt.Println(<span class="string">"s"</span>,s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">s [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">s [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">s [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>时刻注意，切片是对原数组的视图，只要不对切片进行修改操作，就不会对数组进行修改。</p><h2 id="Slice的扩展"><a class="header-anchor" href="#Slice的扩展">¶</a>Slice的扩展</h2><p>切片含有一个cap()，capacity容量，会向后保存原始的数据。 使用<code>cap()</code>可以查看切片的容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>s1 的值为<code>[2 3 4 5]</code>，s2的值为<code>[5 6]</code></li><li>slice可以向后扩展，不可以向前扩展</li><li><code>s[i] </code>不可以超越<code>len(s)</code>，向后扩展不可以超越底层数组<code>cap(s)</code>。如上面若是<code>s2 = s1[5]</code>是取不到值的。</li><li>向后拓展的值可以被新的切片取到。如上面的<code>s2 := s1[3:5]</code>。</li></ul><h2 id="Slice-操作"><a class="header-anchor" href="#Slice-操作">¶</a>Slice 操作</h2><h3 id="向Slice添加元素"><a class="header-anchor" href="#向Slice添加元素">¶</a>向Slice添加元素</h3><p>使用<code>append(slice, val)</code>，注意的是，在添加的时候，若添加的内容的下标未超过原始数组的下标（但是在切片的容量之内），则添加的内容会覆盖掉原始数组相应位置的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">  </span><br><span class="line">  fmt.Println(<span class="string">"arr ="</span>, arr)</span><br><span class="line">s1 = arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">s2 = s1[<span class="number">3</span>:<span class="number">5</span>] <span class="comment">// [s1[3], s1[4]]  实际上为 [arr[5], arr[6]]</span></span><br><span class="line">fmt.Printf(<span class="string">"s1=%v, len(s1)=%d, cap(s1)=%d\n"</span>,</span><br><span class="line">s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Printf(<span class="string">"s2=%v, len(s2)=%d, cap(s2)=%d\n"</span>,</span><br><span class="line">s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line">s3 := <span class="built_in">append</span>(s2, <span class="number">10</span>)     <span class="comment">// 此处添加的10 对应着arr[7]，原先的值被覆盖</span></span><br><span class="line">s4 := <span class="built_in">append</span>(s3, <span class="number">11</span>)</span><br><span class="line">s5 := <span class="built_in">append</span>(s4, <span class="number">12</span>)</span><br><span class="line">fmt.Println(<span class="string">"s3, s4, s5 ="</span>, s3, s4, s5)</span><br><span class="line"><span class="comment">// s4 and s5 no longer view arr.</span></span><br><span class="line">fmt.Println(<span class="string">"arr ="</span>, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果arr = [0 1 2 3 4 5 6 7]</span></span><br><span class="line">s1=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="built_in">len</span>(s1)=<span class="number">4</span>, <span class="built_in">cap</span>(s1)=<span class="number">6</span></span><br><span class="line">s2=[<span class="number">5</span> <span class="number">6</span>], <span class="built_in">len</span>(s2)=<span class="number">2</span>, <span class="built_in">cap</span>(s2)=<span class="number">3</span></span><br><span class="line">s3, s4, s5 = [<span class="number">5</span> <span class="number">6</span> <span class="number">10</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">10</span> <span class="number">11</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]</span><br><span class="line">arr = [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>超出的部分，这里的11 和 12 ，此时的s2 和 s3因为有超出的原先arry的内容，所以这里的s2和s3就不再是原先数组arry的视图view了，而是在内存中重新开辟了新的arry，将原先的arry拷贝过来，并将长度设置更长。</p><p>原先的数组若没有被使用，就会被垃圾回收掉，但是这里的不会，因为调用了。</p><h4 id="切片和原先数组的关系"><a class="header-anchor" href="#切片和原先数组的关系">¶</a>切片和原先数组的关系</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;     <span class="comment">// 此处使用的是切片，因为没有指定数组大小</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [<span class="number">8</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"arr=%v, len(arr)=%d, cap(arr)=%d\n"</span>,</span><br><span class="line">arr, <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br><span class="line">fmt.Printf(<span class="string">"数组的地址： %p\n"</span>, &amp;arr)</span><br><span class="line">fmt.Printf(<span class="string">"数组的首元素的地址： %p\n"</span>, &amp;arr[<span class="number">0</span>])  <span class="comment">// 可以发现就是数组的地址</span></span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Printf(<span class="string">"切片的地址： %p\n"</span>, &amp;s1)</span><br><span class="line">fmt.Printf(<span class="string">"切片的首元素的地址： %p\n"</span>, &amp;s1[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"数组对应切片首元素的地址： %p\n"</span>, &amp;arr[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 结果发现，切片内元素的地址和原先数组对应位置的元素是一样的，但是切片的地址是不同的</span></span><br><span class="line"><span class="comment">// 说明，进行切片时，是创建新的内存空间来存储原先数组对应元素的地址。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Printf(<span class="string">"第一次切片： %p\n"</span>, &amp;s1)</span><br><span class="line">s2 := <span class="built_in">append</span>(s1, <span class="number">100</span>)  <span class="comment">// append会在操作的切片基础上生成一个新的切片</span></span><br><span class="line">fmt.Printf(<span class="string">"s2=%v, len(s2)=%d, cap(s2)=%d\n"</span>,</span><br><span class="line">s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">fmt.Printf(<span class="string">"第二次切片： %p\n"</span>, &amp;s2)</span><br><span class="line"><span class="comment">// 新的切片的地址和第一次切片的地址不一样</span></span><br><span class="line">fmt.Printf(<span class="string">"第二次切片首元素的地址： %p\n"</span>, &amp;s2[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"第二次切片切片变量的地址： %p\n"</span>, s2)  <span class="comment">// 切片名的地址是切片内首元素的地址</span></span><br><span class="line"></span><br><span class="line">s3 := <span class="built_in">append</span>(s2, <span class="number">200</span>)</span><br><span class="line">fmt.Printf(<span class="string">"第三次切片首元素的地址： %p\n"</span>, &amp;s3[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"s3=%v, len(s3)=%d, cap(s3)=%d\n"</span>,</span><br><span class="line">s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br><span class="line">s4 := <span class="built_in">append</span>(s3, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//fmt.Println(arr)</span></span><br><span class="line">fmt.Printf(<span class="string">"arr=%v, len(arr)=%d, cap(arr)=%d\n"</span>,</span><br><span class="line">arr, <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br><span class="line">fmt.Printf(<span class="string">"s4=%v, len(s4)=%d, cap(s4)=%d\n"</span>,</span><br><span class="line">s4, <span class="built_in">len</span>(s4), <span class="built_in">cap</span>(s4))</span><br><span class="line">fmt.Printf(<span class="string">"第四次切片的首元素的地址： %p\n"</span>, &amp;s4[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在切片添加操作超出原先数组后，切片映射的数组就不再是原先的数组，而是一个新的数组对象。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">arr=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>], <span class="built_in">len</span>(arr)=<span class="number">8</span>, <span class="built_in">cap</span>(arr)=<span class="number">8</span></span><br><span class="line">数组的地址： <span class="number">0xc00001a1c0</span></span><br><span class="line">数组的首元素的地址： <span class="number">0xc00001a1c0</span></span><br><span class="line">切片的地址： <span class="number">0xc00000c060</span></span><br><span class="line">切片的首元素的地址： <span class="number">0xc00001a1d0</span></span><br><span class="line">数组对应切片首元素的地址： <span class="number">0xc00001a1d0</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">第一次切片： <span class="number">0xc00000c060</span></span><br><span class="line">s2=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">100</span>], <span class="built_in">len</span>(s2)=<span class="number">5</span>, <span class="built_in">cap</span>(s2)=<span class="number">6</span></span><br><span class="line">第二次切片： <span class="number">0xc00000c0a0</span></span><br><span class="line">第二次切片首元素的地址： <span class="number">0xc00001a1d0</span></span><br><span class="line">第二次切片切片变量的地址： <span class="number">0xc00001a1d0</span></span><br><span class="line">第三次切片首元素的地址： <span class="number">0xc00001a1d0</span></span><br><span class="line">s3=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">100</span> <span class="number">200</span>], <span class="built_in">len</span>(s3)=<span class="number">6</span>, <span class="built_in">cap</span>(s3)=<span class="number">6</span></span><br><span class="line">arr=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">100</span> <span class="number">200</span>], <span class="built_in">len</span>(arr)=<span class="number">8</span>, <span class="built_in">cap</span>(arr)=<span class="number">8</span></span><br><span class="line">s4=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">100</span> <span class="number">200</span> <span class="number">300</span>], <span class="built_in">len</span>(s4)=<span class="number">7</span>, <span class="built_in">cap</span>(s4)=<span class="number">12</span></span><br><span class="line">第四次切片的首元素的地址： <span class="number">0xc000074060</span></span><br></pre></td></tr></table></figure><h2 id="Slice创建"><a class="header-anchor" href="#Slice创建">¶</a>Slice创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>   <span class="comment">// Zero value for slice is nil</span></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125; <span class="comment">// 意思是先创建爱了一个数组[2 4 6 8]，然后又赋值给了一个 []int 切片</span></span><br><span class="line"><span class="comment">// 方式三： 在需要建造一个指定长度的切片，但是还不确定内部的值的情况下</span></span><br><span class="line">s2 := <span class="built_in">make</span>(Type, size[,<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%v len=%d cap=%d"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;</span><br><span class="line">  printSlice(s1)</span><br><span class="line"></span><br><span class="line">  s2 := <span class="built_in">make</span>([]<span class="keyword">int</span> , <span class="number">4</span>)</span><br><span class="line">  printSlice(s2)</span><br><span class="line"></span><br><span class="line">  s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span> ,<span class="number">19</span>)</span><br><span class="line">  printSlice(s3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span>] <span class="built_in">len</span>=<span class="number">4</span> <span class="built_in">cap</span>=<span class="number">4</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="built_in">len</span>=<span class="number">4</span> <span class="built_in">cap</span>=<span class="number">4</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="built_in">len</span>=<span class="number">6</span> <span class="built_in">cap</span>=<span class="number">19</span></span><br></pre></td></tr></table></figure><p><code>var s []int</code> ，Go语言的特性，使用var创建变量之后没有付初值的情况下，有一个zero值，而切片的zero就是nil。直接使用<code>var s []int</code>创建的切片没有值但是可以只用，cap在装不下的时候会进行扩充，每次在原先的基础上乘以2。</p><p>数组的len以及cap的值是一致的，切片：</p><ul><li>在通过<code>make(slice_name, len[, cap])</code>创建的时候，可以使用指定的len以及cap，但是len的长度一定要小于等于cap的值，当添加数据超出cap后，新切片的cap为未扩充前的2倍。</li><li>通过数组进行切片的，len为切片长度，切片的cap为数组的cap-切片的起始索引</li></ul><p>无论通过什么方式创建的切片，在其cap长度内，都是在原先的数组基础上进行扩充的，一旦cap到达后就会进行双倍扩容，此时的就会拷贝原有数组的内容创建新的数组，新数组和之前的数组是没有关系的。</p><h2 id="Slice-的复制"><a class="header-anchor" href="#Slice-的复制">¶</a>Slice 的复制</h2><p><code>copy(dst, src []Type) int</code>，将src中的内容拷贝到dst中，覆盖原先中的内容，超出的部分抹去 。</p><ul><li>为slice特有的方法，参数为切片类型 <code>[]Type</code> 。</li><li>返回值类型为int，返回的是实际复制了的内容的长度。</li></ul><h2 id="Slice-元素的删除"><a class="header-anchor" href="#Slice-元素的删除">¶</a>Slice 元素的删除</h2><p>没有内建的函数来执行该操作，需手动执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v, len=%d, cap=%d\n"</span>,</span><br><span class="line">s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Deleting elements from slice"</span>)</span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">printSlice(s1)</span><br><span class="line"><span class="comment">// 可以使用切片从中截断，将需要的部分进行相加组合，但是slice没有加法，所以采用append</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1[:<span class="number">3</span>], s1[<span class="number">9</span>:]...)    <span class="comment">// append(slice []Type, elem ...Type)第二个参数为可变参数，即可接受若干个Type类型的参数</span></span><br><span class="line">printSlice(s1)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Popping from front"</span>)</span><br><span class="line">fornt := s1[<span class="number">0</span>]</span><br><span class="line">s1 = s1[<span class="number">1</span>:]</span><br><span class="line">fmt.Printf(<span class="string">"fornt=%d\n"</span>,fornt)</span><br><span class="line">printSlice(s1)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Popping form back"</span>)</span><br><span class="line">tail := s1[<span class="built_in">len</span>(s1)<span class="number">-1</span>]</span><br><span class="line">s1 = s1[:<span class="built_in">len</span>(s1)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"tail=%d\n"</span>, tail)</span><br><span class="line">printSlice(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">Deleting elements from slice</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] <span class="built_in">len</span>=<span class="number">12</span> <span class="built_in">cap</span>=<span class="number">12</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] <span class="built_in">len</span>=<span class="number">6</span> <span class="built_in">cap</span>=<span class="number">12</span></span><br><span class="line">Popping from front</span><br><span class="line">fornt=<span class="number">1</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] <span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">11</span></span><br><span class="line">Popping form back</span><br><span class="line">tail=<span class="number">6</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>] <span class="built_in">len</span>=<span class="number">4</span> <span class="built_in">cap</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure><p><font color="red">解释：切片没有提供原生的删除操作，删除操作需要手动实现，如使用通过<code>append</code>拼接、创建新的切片等方式实现，但是注意：这些操作都是产生一个新的切片，此时需要使用原先的切片变量来接受，此时从结果上看此时对原来的切片进行了修改（因为Golang和Python不一样，Golang变量就是内存地址，变量开辟内存存储匹配类型的数据，而Python的变量只是别名用来指向数据的内存地址）。</font></p><h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2><ul><li>Slice本身没有数据，是对底层array的一个view</li><li>添加元素时如果超越cap，系统会重新分配更大的底层数组，并将原来的arry拷贝过去。</li><li>由于值传递的关系，必须接受append的返回值 — 因为，slice 的三个指标 ptr指针，len长度， cap容量都可能发生变化，而一旦cap容量超过之后，系统就会重新分配新的更大的内存去存储该slice，所以必须要设置参数用来接受append的返回值。</li><li>S = append(s, val)</li></ul><p><font color="red">Slice底层是对array的一个view,所以对Slice的修改会影响到底层的array,以及有关联的Slice（如同一个array的切片）</font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slicea := arr[:<span class="number">2</span>]</span><br><span class="line">sliceb := arr[:<span class="number">1</span>]</span><br><span class="line">fmt.Print(slicea)</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">fmt.Print(arr)</span><br><span class="line">fmt.Print(sliceb)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span>][<span class="number">8</span> <span class="number">1</span> <span class="number">2</span>][<span class="number">8</span>]</span><br></pre></td></tr></table></figure><h1>Map</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"name"</span>:    <span class="string">"ccmouse"</span>,</span><br><span class="line"><span class="string">"course"</span>:  <span class="string">"golang"</span>,</span><br><span class="line"><span class="string">"site"</span>:    <span class="string">"imooc"</span>,</span><br><span class="line"><span class="string">"quality"</span>: <span class="string">"notbad"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// m2 == empty map</span></span><br><span class="line"><span class="comment">// 方式三：</span></span><br><span class="line"><span class="keyword">var</span> m3 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">// m3 == nil</span></span><br></pre></td></tr></table></figure><p>语法格式：<code>map[key的类型]value的类型</code>，还支持复合结构<code>map[K1]map[K2]V</code></p><p>注意区分方式二和方式三的区别，m2是一个为空的map，已经分配了内存，只是内容为空，而m3是的值为nil，是Go中的特殊类型0值，但是nil也可以参与运算。</p><h2 id="Map的遍历"><a class="header-anchor" href="#Map的遍历">¶</a>Map的遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Traversing map m"</span>)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，key 在Map中是无序的，是一个哈希Map</p><ul><li>Map不保证遍历顺序，如需顺序，需手动对key排序 – 取出所有的key 放到slice中（slice可以排序）进行排序，然后在按照key取出。</li><li>使用len获得元素个数</li></ul><p>Map的key：</p><ul><li>map使用哈希表，必须可以比较相等</li><li>除了slice、map、function的其他内建类型都可以作为key</li><li>不包含slice、map、function的Struct类型都可以作为key</li></ul><h2 id="Map操作"><a class="header-anchor" href="#Map操作">¶</a>Map操作</h2><ul><li><p>读操作：<code>courseName := m[&quot;course&quot;]</code>，当key不存在时，会打印ZeroValue值，如这里会打印空字符串’ '。读操作有两个返回值，第一个返回值为key对应的value值，第二个返回值为反映该key对应的value值是否存在的标志，若key存在，则返回true， 反之返回false。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> causeName, ok := m[<span class="string">"cause"</span>]; ok &#123;</span><br><span class="line">  fmt.Println(causeName)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"key 'cause' does not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作：<code>delete(map, key)</code>，该函数没有返回值。删除不存在的key也不会报错。</p></li></ul><h2 id="小结-v2"><a class="header-anchor" href="#小结-v2">¶</a>小结</h2><ul><li>创建： <code>make(map[string]int)</code></li><li>获取元素： <code>m[key]</code></li><li>key不存在时，获得Value类型的初始值</li><li>使用<code>value, ok := m[key]</code>来判断是否存在key</li><li>用<code>delete(map, key)</code>来删除一个key</li></ul><h2 id="案例"><a class="header-anchor" href="#案例">¶</a>案例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找最长不含有重复字符的子串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfNonRepeatingSubStr</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">lastOccurred := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">start := <span class="number">0</span></span><br><span class="line">maxLength := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;    <span class="comment">// 将字符串每个字符取出，组成切片</span></span><br><span class="line">    <span class="comment">// 目前该方法只支持英文，若想支持因为之外的其他多字节内容，使用 range []rune(s) </span></span><br><span class="line"><span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123;    <span class="comment">// 有该值且不是同一字符</span></span><br><span class="line">start = lastI + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">maxLength = i - start +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">lastOccurred[ch] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cache :=  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">  cache[<span class="string">"name"</span>] = <span class="string">"ccmouse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go指针特别说明</title>
      <link href="2019/10/16/%E7%89%B9%E5%88%AB%E8%AF%B4%E6%98%8E/"/>
      <url>2019/10/16/%E7%89%B9%E5%88%AB%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>要区分Go语言和Python的本质区别：</p><p>Go语言是变量存的是一片内存地址，修改内容时修改的是内存地址中的内容<br>而python中是变量只是标签，每次修改，改变的是变量（标签）指向地方，内存中的内容没有变。</p><ul><li><p>Python创建一个内容时，是先在内存中开辟相应的空间放内容，然后使用一个变量名（标签）来指向这个地方，所以多个变量之间相互赋值的时候，这些变量都指向了同一块内存空间，通过其中一个变量对内容进行修改则会改动所有的，因为都是指向了一个内容。</p></li><li><p>Go语言是先创建一个变量，根据变量的类型开辟大小的空间，再往内存中放置东西。多变量（必须是同种类型变量）之间相互赋值时，进行的是复制（拷贝）操作，各变量之间是独立的个体，对其中一个修改，是不会影响到其他内容的。所以Go的变量赋值很强调类型。</p></li></ul><p>某个类型的变量只能就收同种类型的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">bb := arr</span><br><span class="line">fmt.Printf(<span class="string">"arr address: %p\n"</span>,&amp;arr)</span><br><span class="line">fmt.Printf(<span class="string">"bb address: %p\n"</span>,&amp;bb)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"bb: %d\n"</span>,bb)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">fmt.Printf(<span class="string">"bb: %d\n"</span>,bb)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">arr address: <span class="number">0xc000018240</span></span><br><span class="line">bb address: <span class="number">0xc000018260</span>   </span><br><span class="line">bb: [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">bb: [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>解释：通过打印两个变量的内存地址可以发现，地址是不同的，所以Golang中的变量相互赋值实际上拷贝操作，所以修改其中一个列表的值，也不会影响另外一个列表。</p><p>Slice 等映射类型除外。 （Slice及以下内容参考下篇 Go基础之内建容器）</p><p>Go语言的所有方法一旦有返回值的都是重新创建了新的内容，需要使用新的变量去接收。如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">b := <span class="built_in">append</span>(arr, <span class="number">9</span>) <span class="comment">// 这里实际上是先创建了一个len为2，cap为16的[]int类型的变量并开辟了内存空间，然后接收了append函数返回的内容,arr和b不是指向的同一个内容，但是由于arr为slice类型，对arr现有内容的改变影响到b</span></span><br><span class="line">fmt.Printf(<span class="string">"arr address: %p\n"</span>,&amp;arr)</span><br><span class="line">fmt.Printf(<span class="string">"bb address: %p\n"</span>,&amp;bb)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"bb: %d\n"</span>,bb)</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"arr: %d\n"</span>,arr)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"bb: %d\n"</span>,bb)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">arr address: <span class="number">0xc00009c0c0</span></span><br><span class="line">bb address: <span class="number">0xc00009c0e0</span></span><br><span class="line">bb: [<span class="number">0</span> <span class="number">0</span> <span class="number">9</span>]</span><br><span class="line">arr: [<span class="number">0</span> <span class="number">3</span>]</span><br><span class="line">bb: [<span class="number">0</span> <span class="number">3</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>为了能够修改原值，定义函数的时候使用指针，这样一来，通过指针，修改了原先内存中的值。</p><p><strong><em>使用数组指针作为函数形参的时候，函数内使用该指针变量的时候不需要使用</em>，只需要正常数组的使用方式即可，由于Go的语法糖，会自动转化为(<em>数组)。但是Slice不行，如下：</em></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(s *[]<span class="keyword">int</span>,v <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  *s = <span class="built_in">append</span>(*s,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(s *[]<span class="keyword">int</span>, v <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">*s = <span class="built_in">append</span>(*s, v)</span><br><span class="line"><span class="keyword">return</span> (*s)[<span class="built_in">len</span>(*s)<span class="number">-1</span>]  <span class="comment">// 必须使用(*s)[]的形式进行调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>总之要转换思想，Python中修改变量的值可以通过其他变量间接修改，因为Python的变量只是标签，但是Go中变量是分配了内存的，想修改，只能通过修改自身的值。</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之指针</title>
      <link href="2019/10/16/%E6%8C%87%E9%92%88/"/>
      <url>2019/10/16/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> pa *<span class="keyword">int</span> = &amp;a   <span class="comment">// &amp;a 就是取a的地址</span></span><br><span class="line">*pa = <span class="number">3</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>Go语言中的指针不能进行计算</strong><br>注意：这里的Golang指针类型变量不能进行运算指的是指针本身（pa），而不是指针指向的变量值（*pa）。</p><h2 id="参数传递问题"><a class="header-anchor" href="#参数传递问题">¶</a>参数传递问题</h2><p>Python中的参数传递根据参数是否是可变类型非为值传递和引用传递（实际上都是引用传递）。</p><p>Golang:</p><ul><li>Go只有 <strong>值传递</strong> 这一种方式。</li><li>但是这并不意味着Go在传递的时候都要将内容进行拷贝一份，而是可以使用指针类型，传递指针变量的值（指向内容的地址），和c的用法一样。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a,b *<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  *b, *a = *a, *b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a, b := <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">  swap(&amp;a,&amp;b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的swap实现方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b,a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a,b := <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">  a,b = swap(a,b) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的实现原理是不同的，前者本质上使用的是Go语言的“多重赋值”的特性实现的变量交换任务。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之函数</title>
      <link href="2019/10/14/%E5%87%BD%E6%95%B0function/"/>
      <url>2019/10/14/%E5%87%BD%E6%95%B0function/</url>
      
        <content type="html"><![CDATA[<p><code>func eval(a,b int, op string) int</code>定义的方式和变量类似，都是函数名在前，返回值类型在后，类型是用来指定函数返回值得类型，若函数没有返回值，则不需要指定函数类型。</p><h2 id="函数返回值"><a class="header-anchor" href="#函数返回值">¶</a>函数返回值</h2><p>Go语言的函数可以返回多个值。（Python也可以），只有一个返回值的时候，可以直接指定返回值的类型，或者使用括号，如<code>func eval(a,b int, op string) (i int)</code>，但是有多个返回值的时候一定要使用括号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接指定函数的返回值类型，而不需要写参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不写返回值参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实指定返回值的参数，即这里的q，r 没有太大的意义，对调用者而言没有区别，只是起到了提示作用，便捷的地方在调用的时候编辑器会自动帮我们创建生成接受返回值的参数q，r。但是有一种情况，返回值的参数有大用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  q = a / b</span><br><span class="line">  r = a % b</span><br><span class="line">  <span class="keyword">return</span>     <span class="comment">// 此时只要直接return即可返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这个例子中，如果在声明时设置了返回值参数，此时在函数内就可以直接使用了，否则的话需要先声明才能使用。</strong></p><ul><li>但是使用这种方式，只要函数体一长，很容易搞不清赋值情况</li><li>且返回值参数一定要写</li></ul><p>所以建议还是使用第一种方式。</p><p>可以返回多个返回值带来便利的同时也会产生问题，如必须使用相应个数的参数来接受返回值，否则会报错（Go不像Python一样可以使用<code>[下标]</code>的方式来取得值，Python返回的是元组，所以可以使用下标），这就要求我们必须使用与返回值个数匹配的参数去接受，但是Go严格的语法要求<font color="red">函数内</font>所有定义的参数都必须使用到，否则报编译错误，此时我们就可以使用<code>_</code>来接受不需要的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用_来接受不需要的值</span></span><br><span class="line">q, _ := div(a, b)</span><br></pre></td></tr></table></figure><h2 id="多个返回值的正常用法"><a class="header-anchor" href="#多个返回值的正常用法">¶</a>多个返回值的正常用法</h2><p><font color="red">注意：</font>不要滥用函数的多返回值，一般的常用法是用来定义一个参数用来返回错误<code>error</code>的，即一个正常的返回值，一个出现异常返回的错误值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;  <span class="comment">//  f返回值可以直接类型，如这里的int和error</span></span><br><span class="line">  <span class="keyword">switch</span> op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">      <span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">      <span class="keyword">return</span> a - b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">      <span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">      q, _ := div(a, b)</span><br><span class="line">      <span class="keyword">return</span> q, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 不使用原先的panic()函数，会中断程序的运行，而是采用fmt.Errorf()构造异常</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(  </span><br><span class="line">        <span class="string">"unsupported operation: %s"</span>, op)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> result, err := eval(<span class="number">3</span>, <span class="number">4</span>, <span class="string">"x"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Error:"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式编程"><a class="header-anchor" href="#函数式编程">¶</a>函数式编程</h2><p>Go语言是函数式编程，函数式一等公民：参数，变量，返回值都可以是函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 为了获取函数名</span></span><br><span class="line">  p := reflect.ValueOf(op).Pointer()</span><br><span class="line">  opName := runtime.FuncForPC(p).Name()</span><br><span class="line">  fmt.Printf(<span class="string">"Calling function %s with args "</span> + <span class="string">"(%d, %d)\n"</span>, opName, a, b)</span><br><span class="line">  <span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为自带的math.Pow()方法的参数和返回值要求是float64，所以这里进行重写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(a), <span class="keyword">float64</span>(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(apply(pow, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">Calling function main.pow with args (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><p>除了传递手写的函数，也可以直接使用匿名函数(为省略了函数名的函数，除了函数名其他函数组件一个不能少)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(apply(</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(</span><br><span class="line">        <span class="keyword">float64</span>(a), <span class="keyword">float64</span>(b)))</span><br><span class="line">    &#125;, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">Calling function main.main.func1 with args (<span class="number">3</span>, <span class="number">4</span>)    </span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><p>第一个main是包名，第二个main是func main()的，由于是匿名的函数，所以第三个是func1。</p><h2 id="其他语言中函数的特性"><a class="header-anchor" href="#其他语言中函数的特性">¶</a>其他语言中函数的特性</h2><p>因为Go的语法较为简洁，一起其他语言的特性都不包含，如默认参数，可选参数，函数重载等。</p><p>但是支持可变参数列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;     <span class="comment">// ...为golang的语法糖，此处表示可以接受多个int类型的参数</span></span><br><span class="line">  s := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">    s += numbers[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数列表的类型是相应类型的列表形式， 如上面的例子中的可变参数的类型是<code>[]int</code>。</p><p>此外需要注意的是：</p><ul><li>一个函数中只能有一个可变参数列表</li><li>在含有普通参数的情况下，可变参数列表必须放到参数列表的最后一项</li></ul><p>函数在含有参数以及返回值时，一定要对这些参数的类型进行规定（参数名 参数类型， 参数名2 参数类型），当参数类型相同时，可以只在参数列表的最后指明参数类型。<br>理论上函数可以返回多个返回值（但是必须在函数的定义中指明这些返回值的类型，指明返回值参数类型时，可以使用参数明，也可以不使用，且使用对应的变量去接受这些返回值），但是一般来说只能返两个参数（正常值，异常值）。</p><h2 id="函数语法要点回顾"><a class="header-anchor" href="#函数语法要点回顾">¶</a>函数语法要点回顾</h2><ul><li>返回值类型写在最后</li><li>可返回多个值</li><li>函数作为参数</li><li>没有默认参数，可选参数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之基本语法</title>
      <link href="2019/10/13/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>2019/10/13/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="if-条件语句"><a class="header-anchor" href="#if-条件语句">¶</a>if 条件语句</h2><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bounded</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> v &gt; <span class="number">100</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>if的条件不需要使用括号</strong></em><br>Golang中通过<code>{}</code>来标记代码块，而在python中使用代码缩进来标记代码块。</p><p>if条件语句可以像其他语言的for循环写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">"abc.txt"</span></span><br><span class="line">contents,err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似for写法</span></span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">"abc.txt"</span></span><br><span class="line"><span class="keyword">if</span> contents,err := ioutil.ReadFile(filename);err != <span class="literal">nil</span>&#123;  <span class="comment">// 将原先的赋值语句合并到if中</span></span><br><span class="line">  fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">需要注意的是，类似for写法也有弊端，就是此时合并在if中的赋值过程中创建的变量是不可以在if语句之外被使用的</font></p><ul><li><p>if的条件可以赋值</p></li><li><p><em><strong>if的条件里赋值的变量作用域就在这个if语句中</strong></em></p></li></ul><h2 id="switch语句"><a class="header-anchor" href="#switch语句">¶</a>switch语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;  <span class="comment">// 有返回值的函数，要求需要指定函数的类型</span></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">int</span> </span><br><span class="line">  <span class="keyword">switch</span> op&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">    result = a + b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">    result = a - b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">    result = a * b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">    result = a / b</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unsupported operator:"</span> + op)  <span class="comment">// panic()函数的作用，打印括号内的内容（即报错）并终止程序</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch会自动break，除非使用fallthrough</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grade</span><span class="params">(score <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">g := <span class="string">""</span></span><br><span class="line"><span class="keyword">switch</span> &#123; <span class="comment">// switch之后可以不添加语句也可以执行</span></span><br><span class="line"><span class="keyword">case</span> score &lt;<span class="number">0</span> || score &gt; <span class="number">100</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Wrong score: %d"</span>, score))</span><br><span class="line"><span class="keyword">case</span> score &lt; <span class="number">60</span>:</span><br><span class="line">g = <span class="string">"F"</span></span><br><span class="line"><span class="keyword">case</span> score &lt; <span class="number">80</span>:</span><br><span class="line">g = <span class="string">"C"</span></span><br><span class="line"><span class="keyword">case</span> score &lt; <span class="number">90</span>:</span><br><span class="line">g = <span class="string">"B"</span></span><br><span class="line"><span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">g = <span class="string">"A"</span></span><br><span class="line">&#125;</span><br><span class="line">  fmt.Println(<span class="string">"hello"</span>)  <span class="comment">// 一旦panic()函数执行，就会中断程序的进行，此处的语句也就不会执行</span></span><br><span class="line"><span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch后可以没有语句</p><h2 id="循环语句for"><a class="header-anchor" href="#循环语句for">¶</a>循环语句for</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span> ; i&lt;= <span class="number">100</span>; i++&#123;</span><br><span class="line">  sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">for 循环的初始条件中创建变量的时候，只能使用推导写法<code>:</code>创建变量，且和if条件判断一样，在条件中创建的变量只能在其内部使用，无法在循环之外使用。</font></p><p>for 的条件里不需要添加括号</p><p>for条件里可以省略初始条件，结束条件，递增表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数转二进制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToBin</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">result := <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">lsb := n % <span class="number">2</span></span><br><span class="line">result = strconv.Itoa(lsb) + result  <span class="comment">// strconv.Itoa()作用将参数变成字符串类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是for循环中没有初始条件和递增条件，只有结束条件，则可以连分号都不用写---- 实际上就是别的语言的while循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFileContents</span><span class="params">(reader io.Reader)</span></span> &#123;</span><br><span class="line">scanner := bufio.NewScanner(reader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置可以连结束条件也没有，此时就是死循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forever</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"abc"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中将死循环设计的如此便捷，有一部分原因是因为我们在Go语言中要经常使用死循环</p><h2 id="基本语法要点回顾"><a class="header-anchor" href="#基本语法要点回顾">¶</a>基本语法要点回顾</h2><ul><li>for，if 后面的条件没有括号和冒号，写在大括号内</li><li>if条件里也可定义变量</li><li>没有while</li><li>switch不需要break，也可以直接switch多个条件，不需要在switch后指定对象，case后可以接条件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础之变量</title>
      <link href="2019/10/11/%E5%8F%98%E9%87%8F/"/>
      <url>2019/10/11/%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在Go语言中只存在值类型。</p><p>Go语言的变量都有相应的类型，必须经过声明才能使用。</p><h2 id="声明变量"><a class="header-anchor" href="#声明变量">¶</a>声明变量</h2><p>标准格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>当声明的变量较多时也可以使用批量格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">    c []<span class="keyword">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    e <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="内建变量类型"><a class="header-anchor" href="#内建变量类型">¶</a>内建变量类型</h2><ul><li>bool 布尔类型</li><li>string 字符串类型，实际上是一个[]byte字节数组。</li><li>整数 (u)int (u)int8 (u)int16 (u)int32 (u)int64 uintptr   其中，int为不规定长度的整型，根据操作系统的位数决定，ptr在Go语言中是指针的意思，指针的长度也是跟着操作系统决定的</li><li>byte ，rune ，其中byte是8位的，rune是Go语言的char字符类型，不同于其他语言的1字节8位，rune是4字节32位的，实际上是int32的别名，可以混用。</li><li>浮点型 float32， float64 ，complex64， complex128 ，后面两者为复数，complex64的实部和虚部分别为float32位，complex128的实部和虚部分别为float64位。</li></ul><p><em><strong>Golang中严格区分单引号<code>'</code>和双引号<code>&quot;</code>，前者用来表示单个字符，后者用于表示字符串</strong></em></p><h2 id="强制类型转换"><a class="header-anchor" href="#强制类型转换">¶</a>强制类型转换</h2><ul><li>类型转换是强制的，没有隐式的转换，即转换的时候要使用int()这样进行强制转换</li></ul><h2 id="初始化变量值"><a class="header-anchor" href="#初始化变量值">¶</a>初始化变量值</h2><p>Go在声明变量的时候，自动对变量的内存区域进行初始化操作，即变量在初始化时没有进行赋值的情况下，类型会有相应的默认值。</p><ul><li>整型和浮点类型的默认值为0</li><li>字符串变量的默认值为空字符串类型</li><li>布尔类型的默认值为bool</li><li>切片、函数、指针变量的默认值为nil</li></ul><p><font color="red">Go语言的变量要求相当严格，要求<code>函数内的变量</code>一旦定义了，就必须使用到，否则报错。</font>但是对于函数外的变量没有要求，是可以定义了但是没有被使用。</p><h2 id="函数外的变量"><a class="header-anchor" href="#函数外的变量">¶</a>函数外的变量</h2><p>Go语言中在函数外的变量不是全局变量，而是叫包内变量，因为Go语言文件都是包内（package main），没有全局变量的说法，在包内的变量需使用var进行声明，且可以声明了不被使用。</p><p>函数外的变量（即包内的变量）是可以在函数内部使用的。</p><h2 id="标准格式"><a class="header-anchor" href="#标准格式">¶</a>标准格式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br><span class="line"><span class="keyword">var</span> hp <span class="keyword">int</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="编译器推导类型的格式"><a class="header-anchor" href="#编译器推导类型的格式">¶</a>编译器推导类型的格式</h2><p>在标准格式的基础上，将int省略后，编译器会尝试根据等号右边的表达式推导出变量的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = 表达式</span><br><span class="line"><span class="keyword">var</span> hp = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>此时，就会根据2的类型，自动推导出变量名hp的类型为int类型。</p><h2 id="短变量声明并初始化-–-只限在函数内使用"><a class="header-anchor" href="#短变量声明并初始化-–-只限在函数内使用">¶</a>短变量声明并初始化 – 只限在函数内使用</h2><p>var的变量声明还有更为精简的写法，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hp := <span class="number">100</span></span><br></pre></td></tr></table></figure><p>该写法为推导写法，编译器会自动根据右值类型推断出左值得对应类型</p><ul><li><font color="red">注意：由于使用类&quot;:=&quot;，而不是赋值的&quot;=&quot;，因此推导式左边的变量必须是没有定义过的变量。若是定义过得或报错。如：</font></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> hp <span class="keyword">int</span></span><br><span class="line">hp := <span class="number">100</span></span><br><span class="line">fmt.Println(hp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时会报错：no new variables on left side of :=</span></span><br></pre></td></tr></table></figure><ul><li>短变量声明的时候要求左边必须是新值，但是若左边有多个值的时候，此时只要在含有新的值得情况下，其他的值即使是重复的也没有问题。<br>综上，使用短变量必须是对新变量，完成新变量的声明和赋值。</li><li>注意：若使用短变量声明模式，需在函数内使用，<font color="red">若在函数之外，必须使用<code>var</code>关键字</font></li></ul><p>在函数内命名和包内变量同名的变量，实际上是创建了新的函数内变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a := <span class="number">3</span>  <span class="comment">// 此处的a是函数内部的变量，而函数外的包内变量a没有关系</span></span><br><span class="line">b = <span class="number">3</span>  <span class="comment">// 此处的b是函数外的包内变量在函数内进行调用</span></span><br><span class="line">fmt.Println(<span class="string">"函数变量a"</span>, a)  <span class="comment">// 3</span></span><br><span class="line">fmt.Println(<span class="string">"函数变量b，实际上是包内变量"</span>, b)  <span class="comment">//3</span></span><br><span class="line">outerVar()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outerVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"包内变量a"</span>, a)  <span class="comment">//1</span></span><br><span class="line">fmt.Println(<span class="string">"包内变量b"</span>, b)  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量交换"><a class="header-anchor" href="#变量交换">¶</a>变量交换</h2><p>使用Go语言的”多重赋值”的特性，可以轻松完成变量交换的任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">100</span></span><br><span class="line">b := <span class="number">200</span></span><br><span class="line"></span><br><span class="line">b,a = a,b</span><br></pre></td></tr></table></figure><h2 id="匿名变量"><a class="header-anchor" href="#匿名变量">¶</a>匿名变量</h2><p>使用“_”来代替接受值</p><h2 id="常量-–-Go中的常量不要求要大写表示"><a class="header-anchor" href="#常量-–-Go中的常量不要求要大写表示">¶</a>常量 – Go中的常量不要求要大写表示</h2><p>Go中的大小写有相应的含义，所以对于常量是不要求全部用大写展示的。</p><p>常量可以作为各种类型去使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a,b = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="keyword">int</span>(math.Sqrt(a*a+b*b))</span><br><span class="line"><span class="comment">// 原先要求math.Sqrt中的参数要为float64类型，但是由于使用const定义常量的时候没有使用类型，此时调用的时候ab可以是任何类型，相当于直接贴值过来的，当然也可以规定类型为float64，否则报错</span></span><br></pre></td></tr></table></figure><p>Go语言对于类型有严格的要求，如上面的<code>math.Sqrt()</code>函数要求参数类型必须是float64类型，此时传递float32都是不行的。</p><h3 id="枚举类型"><a class="header-anchor" href="#枚举类型">¶</a>枚举类型</h3><ul><li><p>注意一定要在const块中来声明</p></li><li><p><code>iota</code>专门用在常量的声明中，其初始值为0，且当一组值同时声明的时候，其会自增长。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">a = <span class="literal">iota</span>  <span class="comment">// 0</span></span><br><span class="line">b = <span class="literal">iota</span>  <span class="comment">// 1</span></span><br><span class="line">c = <span class="number">3</span> </span><br><span class="line">d = <span class="literal">iota</span>  <span class="comment">// 3 这里要注意，iota是逐行增加的，即使没有使用</span></span><br><span class="line">)</span><br><span class="line">  <span class="keyword">const</span>(    <span class="comment">// 像下面的声明中cpp会为0 之后的变量可以不进行手动赋值，会自动增值赋值</span></span><br><span class="line">  cpp = <span class="literal">iota</span></span><br><span class="line">    _</span><br><span class="line">    python</span><br><span class="line">    java</span><br><span class="line">    golang</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">const</span> e = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="literal">iota</span> <span class="comment">// 0 这里由于不是在一个组内进行声明，所以都是0</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a,b,c,d,e,f) <span class="comment">// 0 1 3 3 0 0</span></span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    kb</span><br><span class="line">    mb</span><br><span class="line">    gb</span><br><span class="line">    tb</span><br><span class="line">    pb</span><br><span class="line">  )</span><br><span class="line">  fmt.Println(b,kb,mb,gb,tb,pb) <span class="comment">// 1 1024 1048576 1073741824 1099511627776 1125899906842624</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lota</code> 可以作为种子，帮助完成自增</p><h2 id="布尔类型"><a class="header-anchor" href="#布尔类型">¶</a>布尔类型</h2><p>为bool类型，但是bool类型是不可以和整型进行相互转换的，<font color="red">声明布尔类型在没有赋值的情况下，默认的值为false</font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明方式一</span></span><br><span class="line"><span class="keyword">var</span>  a <span class="keyword">bool</span></span><br><span class="line">a = ture</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">a := <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="打印函数"><a class="header-anchor" href="#打印函数">¶</a>打印函数</h2><p>Println和Printf的区别：Println用于打印字符串和变量，Printf只可以打印出格式化的字符串,可以输出字符串类型的变量，不可以输出整变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableZeroValue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span>          <span class="comment">// 变量名在类型之前</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %q"</span>,a, s)  <span class="comment">// %q的作用是 显示用单引号围绕该值，因为string类型的默认值为空字符串，这样显示会更加直观一些</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">variableZeroValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量定义的要点"><a class="header-anchor" href="#变量定义的要点">¶</a>变量定义的要点</h2><ul><li><p>变量类型写在变量名之后</p></li><li><p>编译器可推测变量类型</p></li><li><p>没有char，只有rune，而且是32位的，可以作为是int32的别名</p></li><li><p>原生支持复数类型</p></li><li><p>变量一旦指定类型了，就不能接受其他类型的赋值（这点和Python不一样，Python中变量名只是标签）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"Y"</span> <span class="comment">// UTF-8</span></span><br><span class="line">s = <span class="number">1</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="comment">// cannot use 1 (type int) as type string in assignment</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 指令速查</title>
      <link href="2019/09/20/Git-%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
      <url>2019/09/20/Git-%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="提交-commit"><a class="header-anchor" href="#提交-commit">¶</a>提交 commit</h2><p>指定要提价的单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit [指定的文件名] -m "此次提交的注释"   # 若不添加文件，则默认将暂存区的所有文件提交</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &quot;此次提交的注释&quot;</span><br></pre></td></tr></table></figure><p>简化了操作，直接完成了 git add 和 git commit 的操作，但是注意，该操作只限定于对已经被追踪的文件，若有新的未被追踪的文件，则无法使用该命令。</p><h2 id="查看不同"><a class="header-anchor" href="#查看不同">¶</a>查看不同</h2><p>查看当前仓库中的文件和上一次提交的不同的地方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>查看执行 git add之后，暂存状态（还未git commit提交）和上次提交不同的地方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p>查看对已经执行git add后的文件进行修改后与上次提交之间的不同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><blockquote><p>在文件 git add 之后，又进行了修改，文件会有两个状态，分别是未add和未commit，此时使用git diff 查看到的不同是未add的和上次的区别，想要查看两次的区别，使用git diff HEAD,可以查看。</p></blockquote><p>查看与某个指定版本的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff hash值</span><br></pre></td></tr></table></figure><p><em><strong>以上所有的 git diff 指令均可添加文件名进行指定文件的查询</strong></em></p><h2 id="日志记录"><a class="header-anchor" href="#日志记录">¶</a>日志记录</h2><p>查看简略的日志记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>简略的日志记录，但是展示了完整的版本号信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><p>带时间线的图形化显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure><p>查看所有分支的所有操作记录（包括删除的分支记录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="版本回退"><a class="header-anchor" href="#版本回退">¶</a>版本回退</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 2.py 添加一个新文件</span><br><span class="line">git commit --amend --no-edit 提交</span><br></pre></td></tr></table></figure><p>参数解释：<br>–amend 参数：将这次改变放到上次的 commit 中<br>–no-edit 参数:不修改之前的 commit 评论，仍然使用之前的评论</p><p>结果： 替换了上次commit的版本，仍然使用之前的评论，版本号被修改，之前的版本号消失。</p><p>如果使用 <code>git commit --amend -m &quot;xxx&quot;</code> 命令，则表示将此次的提交合并到上次的提交记录中，且修改上次的提交注释，其他的信息不变（使用的还是上次的版本号）。</p><p>回退暂存区的内容，用于在 git add 之后反悔，使用 git reset 返回到 add 之前，可以添加文件名，若没有文件名，则默认还原所有的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [暂存区文件名]</span><br></pre></td></tr></table></figure><p>回到最近一次commit的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><p>回到HEAD指向的commit的版本的前一个版本，效果等同于 <code>git reset --hard HEAD~2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>回到相应版本号所相应的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><p><em><strong>回退到对应的版本之后，此时使用 git log 只能查看到当前回退所在的版本之前的日志，回退版本之后的日志无法查看，此时可以使用 git reflog 查看所有操作的日志</strong></em></p><h3 id="文件的版本回退"><a class="header-anchor" href="#文件的版本回退">¶</a>文件的版本回退</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout 版本号 -- 文件名</span><br><span class="line">注意: </span><br><span class="line">    -- 前后都有一个空格  </span><br><span class="line">    命令只会对指定文件进行版本的回退，而不是整个git仓库的文件</span><br><span class="line">git reset是将整个仓库的版本回退到某个记录，但是git checkout则是将某个单独的文件的版本回退到某个版本</span><br></pre></td></tr></table></figure><h2 id="分支"><a class="header-anchor" href="#分支">¶</a>分支</h2><p>创建分支方式一</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><p>查看所有分支的情况，分支之前的*，表示当前所处在的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>创建分支方式二</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名 # 使用该方式创建的分支可以在创建完成后直接进入到该分支下。</span><br></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><blockquote><p>注意：若当前分支中有 git add 之后，没有进行提交的文件，此时是不能切换分支的</p></blockquote><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><blockquote><p>注意:使用该命令时，当前所在的分支一定不能是要删除的分支</p></blockquote><p>合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m 需要被合并的分支名</span><br></pre></td></tr></table></figure><p>参数解释：<br>–no-ff ：需要和 -m 参数一起使用，表示需要设置合并分支的消息，此时会新建一个节点，表示为合并的节点，不添加该参数时表示不添加合并信息，此时的节点信息为合并的分支的最新节点的信息。</p><blockquote><p>注意：合并的对象，若想将分支b的内容合并到分支a中,则需要在分支a中使用git merge b进行。</p></blockquote><h2 id="冲突"><a class="header-anchor" href="#冲突">¶</a>冲突</h2><p>当合并的两个分支都对同一个文件做了修改，合并的时候就会提示冲突，此时 git 的处理方式是：提示有冲突的文件，在该文件中使用git的标志标示出来，由用户决定保留的内容，之后再由用户手动commit，完成本次的合并提交。</p><p>合并之后，冲突的分支中的内容不变（本来分支中的内容就不会变），虽然此时和主分支中冲突文件的内容不同，因为解决冲突的问题，版本管理器也就认为这两个文件是一样的了。</p><h2 id="暂存，临时修改"><a class="header-anchor" href="#暂存，临时修改">¶</a>暂存，临时修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">临时修改：git stash</span><br><span class="line"></span><br><span class="line">git stash  将当前的工作区 存起来</span><br><span class="line">此时可以切换到别的分支，或者创建新的分支来完成别的工作</span><br><span class="line"></span><br><span class="line">再切换到当前分支，使用git stash pop 就可以继续之前的工作了</span><br></pre></td></tr></table></figure><h2 id="删除存储的文件"><a class="header-anchor" href="#删除存储的文件">¶</a>删除存储的文件</h2><p>同时删除工作区和索引中的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件名</span><br></pre></td></tr></table></figure><p>仅从索引中删除文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件名</span><br></pre></td></tr></table></figure><blockquote><p>此方式删除后，本地文件还存在，只是不希望这个文件被版本控制。此删除方式多用在修改 .gitignore 文件时，因为修改 .gitignore 文件后，若被忽略的文件在之前已经被添加到仓库中，文件忽略是没有效果的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo基础命令</title>
      <link href="2019/06/14/hello-world/"/>
      <url>2019/06/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
