<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monaco:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Your advantages today will be replaced by future trends, so keep learning.">
<meta property="og:type" content="website">
<meta property="og:title" content="Skylor Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Skylor Blog">
<meta property="og:description" content="Your advantages today will be replaced by future trends, so keep learning.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Skylor Tang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Skylor Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Skylor Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/01/%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8tmux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8tmux/" class="post-title-link" itemprop="url">终端神器tmux命令提示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 20:16:55" itemprop="dateCreated datePublished" datetime="2021-06-01T20:16:55+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 20:40:43" itemprop="dateModified" datetime="2021-04-29T20:40:43+08:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/01/%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8tmux/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/01/%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8tmux/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Tmux 就是会话与窗口的"解绑"工具，将它们彻底分离，提供了强大的终端复用以及会话保存功能。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/01/%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8tmux/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/27/RabbitMQ-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/27/RabbitMQ-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">RabbitMQ 基础部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-27 20:54:09 / 修改时间：20:55:45" itemprop="dateCreated datePublished" datetime="2021-04-27T20:54:09+08:00">2021-04-27</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/27/RabbitMQ-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/27/RabbitMQ-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>AMQP： Advaced Message Queuing Protocol 高级消息队列协议，RabbitMQ完全满足该协议。</p>
<p>消息中间件（Message-oriented middleware, MOM）是一种软件或者硬件基础设施，通过它可以在分布式系统中发送和接受消息。RabbitMQ通过高级路由和消息分发工功能巧妙地实现了这一角色，即使需要满足广域网环境下实现可靠性所应达到的容错条件，分布式系统也可以很容易与其他系统进行互连。</p>
<p>消息中间件使用于需要可靠的数据传送的分布式环境。采用消息中间件的系统中，不同的对象之间通过传递消息来激活对方的事件，以完成相应的操作。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候再将消息转发给接收者。<strong>消息中间件能在不同平台之间通信，它常被用来屏蔽各种平台及协议之间的特性，实现应用程序之间的协同，其优点在于能够在客户和服务器之间提供同步和异步的连接，并且在任何时刻都可以将消息进行传送或者存储转发（这也是比远程过程调用更进步的原因）</strong>。</p>
<p>本文的所有操作，均采用Python的pika库来完成RabbitMQ的操作。尽管还有其他的第三方库，单是因为都遵循AMQP协议，所以提供的调用方法参数等大致差不多，个别会设置一些独有的参数。</p>
<h3 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h3>
<p>AMQ三个抽象组件：</p>
<p>交换器<code>Exchange</code>：接收发送到RabbitMQ的消息并决定把它们投递到何处(由Exchange将消息路由到一个或多个队列中（或者丢弃）)。</p>
<p>队列<code>Queue</code>：负责存储接收到的消息，同时也可能包含处理消息的配置信息。消息可以只存储在内存中，也可以存储在硬盘中，然后以先进先出的顺序进行投递。</p>
<p>绑定：使用绑定来定义队列和交换器之间的关系。使用绑定或者绑定键（BindingKey）对于某些交换器类型，绑定同时告知交换器如何对消息进行过滤从而决定能够投递到队列的消息。当一条消息到交换器时，应用程序使用路由键（RoutingKey）属性来进行匹配。</p>
<p>RabbitMQ运转流程：</p>
<p>生产者发送消息的过程：</p>
<pre><code>1.生产者连接到RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）。
2.生产者声明一个交换器（Exchange），并设置相关属性，比如交换机类型、是否持久化等。
3.生产者声明一个队列并设置相关属性（通过创建的通道开启），比如是否排他、是否持久化、是否自动删除等。
4.生产者通过绑定键将交换器和队列绑定起来。
5.生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。
6.响应的交换器根据接收到的路由键查找相匹配的队列。
7.如果找到，则将从生产者发送过来的消息存入相应的队列中。
8.如果没有找到，则根据生成者配置的属性选择丢弃还是回退给生产者。
9.关闭信道。
10.关闭连接。
</code></pre>
<p>消费者接收消息的过程：</p>
<pre><code>1.消费者连接到RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）。
2.消费者向RabbitMQ Broker请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作。
3.等待 RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。
4.消费者确认（ack）接收到的消息。
5.RabbitMQ从队列中删除相应的已经被接收的消息。
6.关闭信道。
7.关闭连接。
</code></pre>
<h4 id="连接和通道"><a class="header-anchor" href="#连接和通道">¶</a>连接和通道</h4>
<p>连接和通道：</p>
<p>无论是生产者和消费者都需要通过TCP连接和RabbitMQ Broker建立连接，一个连接就是一个TCP连接。建立连接之后，用户就可以在连接的基础上建立一个AMQP信道，每个信道会被赋值一个唯一的ID(在各自的连接中不同，不同的连接重新算)，信道是建立在TCP上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过信道完成的。</p>
<p>这样设计的理由：<br>
TCP的创建和销毁是非常消耗资源的，遇到使用高峰，就会遇到性能瓶颈，采用NIO的做法，实现TCP连接复用，不仅可以减少性能开销，同时还便于管理。</p>
<p>每个线程都把持一个信道，所以信道复用了Conneciton的TCP连接。</p>
<p>RabbitMQ可以保证每个信道的私密性。当每个信道的流量不是很大的时候，复用单一的Connection可以在产生性能瓶颈的情况下有效地节省TCP的连接资源。但是当信道本身的流量很大的时候，多个信道复用同一个Connection就会产生性能瓶颈，进而整体的流量就会被限制了，此时就需要开辟多个Connection，将这些信道均摊道这些Connection中。</p>
<p><font color="red">信道不是线程安全的，如果有多个线程，应该保证每个线程独享一个信道。</font></p>
<h5 id="pika的使用"><a class="header-anchor" href="#pika的使用">¶</a>pika的使用</h5>
<h6 id="连接Connection以及信道Channel的创建。"><a class="header-anchor" href="#连接Connection以及信道Channel的创建。">¶</a>连接Connection以及信道Channel的创建。</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line">credential = pika.PlainCredentials(<span class="string">&quot;guest&quot;</span>, <span class="string">&quot;guest&quot;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">55013</span>, credentials=credential))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()  <span class="comment"># 创建一个通道</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以创建多个通道，生产者发送消息、创建交换器、交换器和通道的绑定都是通过通道对象来实现的，但是通道只是负责通信，这些操作放到好几个channel对象来做也是没有问题的。（因为channel是非线程安全的，所以多线程中应该保持每个线程独占一个channel。）</p>
</blockquote>
<h5 id="交换器exchange和队列queue"><a class="header-anchor" href="#交换器exchange和队列queue">¶</a>交换器exchange和队列queue</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;hello&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>,  durable=<span class="literal">True</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;helloqueue&#x27;</span>, durable=<span class="literal">True</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;hello&#x27;</span>, queue=<span class="string">&#x27;helloqueue&#x27;</span>, routing_key=<span class="string">&#x27;xx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建交换器以及队列都是通过信道对象完成，创建的的时候交换器和队列没有直接关系，可以使用多个通道完成（不是说只能通过同一个通道创建的交换器和队列才有关系，信道只是传递操作指令的通道）。</p>
<p>信道可以声明已经存在的交换器或者队列，如果声明的参数完全匹配现存的交换器或者队列，RabbitMQ就什么都不做，并成功返回，如果参数不一致，则报错<code>pika.exceptions.ChannelClosedByBroker: (406, &quot;PRECONDITION_FAILED - inequivalent arg 'durable' for queue 'hello' in vhost '/': received 'true' but current is 'false'&quot;)</code><strong>也就是说不能出现同名的交换器和队列，交换器和队列都是唯一的</strong>。</p>
</blockquote>
<h6 id="交换器声明方法的常用属性："><a class="header-anchor" href="#交换器声明方法的常用属性：">¶</a>交换器声明方法的常用属性：</h6>
<p><code>channel.exchange_declare(exchange, exchange_type, passive, durable, auto_delete, internal, arguments)</code></p>
<ul>
<li><code>exchange</code>:  交换器名称。</li>
<li><code>exchange_type</code>:  交换器类型（fanout, direct, topic, headers)，默认使用的是direct，为RoutingKey和BindingKey完全匹配。</li>
<li><code>passive</code>: 默认为False。</li>
<li><code>durable</code>:  默认为False，用于设置是否持久化，持久化可以将交换器存盘，这样在服务器重启的时候不会丢失相关信息。</li>
<li><code>auto_delete</code>: 默认为False, 用于设置是否自动删除，自动删除的前提是在交换器至少与一个队列或者交换器绑定后，之后所有的与这个交换器绑定的队列或者交换器都与此解绑，此时这个交换器会自动删除。</li>
<li><code>internal</code>: 默认为False，用于设置是否是内置的，如果是内置的交换器，客户端无法直接发送消息到这个交换器中，只能通过其他交换器路由到该交换器（设置方式和绑定queue类似，通过channel.exchange_bind()设置）。</li>
<li><code>arguments</code>: 其他的一些结构化的参数，如alternate-exchange（用于设置备份交换机）。</li>
</ul>
<p>与之对应还有一个交换器的删除方法：<code>exchange_delete(self, exchange=None, if_unused=False)</code>，is_unused为True,则表示只有在交换器未被使用的情况下才会被删除。</p>
<h6 id="队列声明方法的常用属性："><a class="header-anchor" href="#队列声明方法的常用属性：">¶</a>队列声明方法的常用属性：</h6>
<p><code>channel.queue_declare(queue, passive, durable, exclusive, auto_delete, arguments)</code></p>
<ul>
<li><code>queue</code>: 队列名称。</li>
<li><code>passive</code>: 默认值为False。Only check to see if the queue exists and raise ChannelClosed if it doesn’t.</li>
<li><code>durable</code>: 默认为False，用于设置是否持久化，如果为True，则会存盘，在RabbitMQ服务重启的时候，队列就不会消失。<em>（信息是存储按照先后顺序存储在队列中的，只要队列不消失，数据就不会消失，和交换器没有关系（交换器只是负责数据的路由的）。交换的的持久化是在硬盘中存储交换器的相关信息，否则一旦重启服务，没有持久化的交换器就会消失。）</em></li>
<li><code>exclusive</code>: 默认为Flase，用于设置使用当前连接Connection创建的队列是排他队列（该队列只能在当前连接内使用，所以当前的连接内的channle都是能够使用的，然后在连接关闭的时候，该排他队列会自动删除（无论是否设置了durable参数进行持久化，都会被删除），此外，因为排他队列只能当前连接使用，所以此时其他连接中也是不能建立同名的排他队列的（本来是能够获的该队列的，但是由于是排他所以无法使用，要报错。））</li>
<li><code>auto_delete</code>: 默认为False，设置为True之后，当队列创建之后，所有与该队列连接的消费者都断开的时候，即没有消费者连接该队列的时候，该队列会自动删除。</li>
<li><code>arguments</code>: 设置队列的一些其他参数，如 x-message-ttl、 x-expires、x-max-length、 x-max-length-bytes、x-dead-letter-exchange、 x-dead-letter-routing-key、 x-max-priority等。</li>
</ul>
<p>与之对应队列删除的方法：<code>channel.queue_delete(queue, if_unused=False, if_empty=False) </code>，is_unused为True,则表示只有在队列未被使用的情况下才会被删除。is_empty表示只有当队列为空的时候才能被删除。</p>
<p><code>channel.queue_purge(queue)</code> 用于清空队列，不会删除队列。</p>
<h6 id="队列和交换器的绑定"><a class="header-anchor" href="#队列和交换器的绑定">¶</a>队列和交换器的绑定</h6>
<p><code>channel.queue_bind(queue, exchange, routing_key=None, arguments=None)</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/Celery-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/Celery-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Celery 基本使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 21:09:03" itemprop="dateCreated datePublished" datetime="2021-03-20T21:09:03+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 22:02:57" itemprop="dateModified" datetime="2021-04-12T22:02:57+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">开发问题</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/20/Celery-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/20/Celery-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Celery是Python开发的分布式任务调度模块，本身不含消息服务，它使用第三方消息服务来传递任务，目前，Celery支持的消息服务有RabbitMQ、Redis甚至是数据库。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/20/Celery-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/10/Ajax-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/10/Ajax-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">Ajax 跨域问题解决方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-10 08:24:59" itemprop="dateCreated datePublished" datetime="2021-03-10T08:24:59+08:00">2021-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-11 09:23:18" itemprop="dateModified" datetime="2021-04-11T09:23:18+08:00">2021-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">开发问题</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Flask/" itemprop="url" rel="index"><span itemprop="name">Flask</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Ajax/" itemprop="url" rel="index"><span itemprop="name">Ajax</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/10/Ajax-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/10/Ajax-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于浏览器安全方面的限制，大多数Ajax请求遵守“同源策略”，也就是说无法从不同的域、子域或协议中获取数据。本文主要通过CORS解决Ajax跨域请求的问题。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/10/Ajax-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/Python-%E5%85%83%E7%B1%BB%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/Python-%E5%85%83%E7%B1%BB%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">Python 元类编程思考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 10:41:13" itemprop="dateCreated datePublished" datetime="2020-09-13T10:41:13+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-14 19:02:27" itemprop="dateModified" datetime="2020-09-14T19:02:27+08:00">2020-09-14</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/09/13/Python-%E5%85%83%E7%B1%BB%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/13/Python-%E5%85%83%E7%B1%BB%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1ca0b9c777d">https://www.jianshu.com/p/c1ca0b9c777d</a></p>
<h2 id="什么是元类"><a class="header-anchor" href="#什么是元类">¶</a>什么是元类</h2>
<p>python中一切皆对象，type创建了一切对象，包括类、函数等。类创建了实例对象，而类本身也是对象，创建类的类就是元类。<br>
元类（metaclass）可以控制类的创建过程，它主要做三件事： 1.拦截类的创建 2.修改类的定义 3.返回修改后的类对象。type就是Python中最基础的一个元类。</p>
<h2 id="使用type动态的创建类"><a class="header-anchor" href="#使用type动态的创建类">¶</a>使用type动态的创建类</h2>
<p>type除了用于返回当前对象的类型之外，还可以用于动态的创建类。chuang<br>
#三个参数 ： 类的名称， 类的基类tuple类型， 类属性和类方法实例方法 dict类型</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/03/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/03/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">算法数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-03 18:12:55" itemprop="dateCreated datePublished" datetime="2020-08-03T18:12:55+08:00">2020-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-20 09:35:16" itemprop="dateModified" datetime="2020-10-20T09:35:16+08:00">2020-10-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/08/03/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/08/03/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="算法复杂度"><a class="header-anchor" href="#算法复杂度">¶</a>算法复杂度</h2>
<p>算法复杂度分为时间复杂度和空间复杂度。<br>
时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体现在运行某个算法时计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度。）</p>
<h3 id="时间复杂度"><a class="header-anchor" href="#时间复杂度">¶</a>时间复杂度</h3>
<p>时间复杂度排序：<br>
O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n²logn) &lt; O(n³)</p>
<p>简单快速判断算法的时间复杂度（适用于大部分简单的代码）</p>
<ul>
<li>确定问题规模 n</li>
<li>循环减半过程  --&gt; logn</li>
<li>k层关于n的循环 --&gt; nᵏ</li>
<li>复杂情况 --&gt; 根据算法执行过程判断</li>
</ul>
<h3 id="空间复杂度"><a class="header-anchor" href="#空间复杂度">¶</a>空间复杂度</h3>
<p>空间复杂度：评估算法内存占用大小的式子<br>
空间复杂度的表现方式和时间复杂度一致：</p>
<ul>
<li>算法使用了几个变量： O(1)</li>
<li>算法使用了长度为n的以为列表： O(n)</li>
<li>算法使用了m行n列的二维列表： O(mn)</li>
<li>递归需要使用到系统栈的空间，因为需要记录上次递归中函数的位置，每走一层就需要消耗1个空间，所以没走k层，就需要消耗O(k)的空间</li>
</ul>
<p>空间换时间</p>
<p>冒泡后 选标记前 插移位 快归位(找到元素应有的位置)递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_time</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    简易算法时间装饰器</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s running time: %s secs.&quot;</span> % (func.__name__, t2-t1))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p><strong>以下所有的排序算法的实现，都是基于列表的下标完成的</strong></p>
<h2 id="递归问题"><a class="header-anchor" href="#递归问题">¶</a>递归问题</h2>
<p>递归的特点： 1.调用自身 2.结束条件<br>
递归案例： 汉诺塔问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span>(<span class="params">n, a, b ,c</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n 表示圆盘个数</span></span><br><span class="line"><span class="string">    三个参数代表三个柱子相对位置</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        hanoi(n-<span class="number">1</span>, a, c, b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;moving from %s to %s&#x27;</span> %(a, c))</span><br><span class="line">        hanoi(n-<span class="number">1</span>, b, a, c)</span><br><span class="line"></span><br><span class="line">hanoi(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>算法解析：<br>
为了保证小的盘子只能放在大的盘子之上，将n个盘子分为两个部分（1以及n-1两个部分），1 表示最后的一个大盘子，n-1 看作一个整体。</p>
<h2 id="列表查找"><a class="header-anchor" href="#列表查找">¶</a>列表查找</h2>
<p>列表查找（线性表查找）：从列表中查找指定元素</p>
<ul>
<li>输入：列表、待查找元素</li>
<li>输出：元素下标（未找到元素时一般返回None或-1）</li>
</ul>
<p>list类型内置查找函数：index()   —  是线性（顺序）查找，因为二分查找要求列表是有序列表，故采用的是线性查找</p>
<h3 id="顺序查找-Linear-Search"><a class="header-anchor" href="#顺序查找-Linear-Search">¶</a>顺序查找 (Linear Search)</h3>
<p>也叫线性查找，从列表的第一个元素开始，顺序进行搜索</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_search</span>(<span class="params">li, val</span>):</span></span><br><span class="line">    <span class="keyword">for</span> ind, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(li):</span><br><span class="line">        <span class="keyword">if</span> v == val:</span><br><span class="line">            <span class="keyword">return</span> ind</span><br><span class="line">    <span class="keyword">else</span>:                                       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><em><strong>python 中独创了 <code>for...else...</code> 以及 <code>while...else...</code> 语法，用于在循环结束之后直接执行else中的内容，好处是当循环中因为break退出时，else中的内容将不在执行。</strong></em></p>
<h3 id="二分查找-Binary-Search"><a class="header-anchor" href="#二分查找-Binary-Search">¶</a>二分查找 (Binary Search)</h3>
<p>又叫折半查找，从有序列表的初始候选区 li[0:n] 开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。</p>
<p>算法的前提：查找目标<code>必须是排序好的</code>列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">li, val</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(li) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span>  </span><br><span class="line">        <span class="keyword">if</span> li[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; val:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：涉及到循环减半，所以复杂度是O(logn)</p>
<p>小结：<br>
list类型内置查找函数<code>index()</code> 是线性（顺序）查找，因为二分查找要求列表是有序列表，故采用的是线性查找，<br>
二分查找要求列表的顺序为有序列表，而排序算法的复杂度都大于O(n)，所以在选用查找方式的时候就需要斟酌：</p>
<ul>
<li>有序列表，肯定采用二分查找（binary serarch）</li>
<li>无序列表，看查找的次数，如果查找只进行你一次，为了避免采用二分查找的列表排序的过程的消耗，推荐采用线性查找（linear search）<br>
如果进行多次查找，可采用二分查找，此时排序的消耗时间可以忽略。</li>
</ul>
<h2 id="列表排序"><a class="header-anchor" href="#列表排序">¶</a>列表排序</h2>
<p>将无序列表变成有序的列表</p>
<ul>
<li>输入： 列表</li>
<li>输出： 有序列表</li>
</ul>
<p>排序方式：升序与降序</p>
<p>内置排序函数： sort()</p>
<h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序">¶</a>冒泡排序</h3>
<p>冒泡排序的一趟过程：列表每两个相邻的数，如果前面比后面大，则交换两个数。（箭头只会到倒数第二个元素）  —&gt; 导致列表中的最大数的排到末尾。<br>
最大值所在的区为有序区，剩下的为无序区，每一趟从无序区中得到一个最大值放到有序区中。<br>
循环的次数（趟数）为列表长度n-1，因为最后一个元素不需要进行了。</p>
<p>代码的关键点： 趟、无序区范围</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 排序的趟数 = 总元素个数 - 1 因为剩下的最后一个元素(表首)不需要排序</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):  <span class="comment"># 总长度-有序区长度 - 1 = 无序区长度 -1 </span></span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:  <span class="comment"># 当前为升序排序，若降序则改为小于即可</span></span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">li = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line">bubble_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n²)</p>
<p>冒泡排序算法改进：<br>
以上的实现中，默认是对所有的元素都进行了比较查看，<br>
可能会存在的情况是说在一趟排序中，如<code>[9, 8, 7, 1, 2, 3, 4]</code>这样，在进行了3次冒泡之后，已经不需要再进行排序了，所以可以通过设置标记的方式将不在排序之后退出代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  </span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>): </span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>
<p>算法改进（设置了标记值）之后，当列表值是顺序的时候，此时列表只会遍历一边，此时就达到了冒泡排序的最好情况时间复杂度 <code>O(n)</code>。</p>
<p>算法要点：每次循环找出并固定表尾的最大值。</p>
<h3 id="选择排序"><a class="header-anchor" href="#选择排序">¶</a>选择排序</h3>
<p>遍历列表，每次找出列表中的最小值，继续找剩下的列表中的最小值，即多次遍历列表，每次取最小数。</p>
<p>一般实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort_simple</span>(<span class="params">li</span>):</span></span><br><span class="line">    li_new = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">        min_val = <span class="built_in">min</span>(li)  <span class="comment"># O(n)</span></span><br><span class="line">        li_new.append(min_val)</span><br><span class="line">        li.remove(min_val) <span class="comment"># O(n)</span></span><br><span class="line">    <span class="keyword">return</span> li_new</span><br></pre></td></tr></table></figure>
<p>算法的时间复杂度为 O(n²)，该算法虽然实现了选择排序的功能，但却另外开辟了内存空间，我们需要做到 <code>原地排序</code> ，即不额外创建新的列表，而只在当前待排序的列表上进行操作。</p>
<p>改进方案：<br>
将找出的小值从开头开始放，原先位置上的值与小值所在的位置进行交换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># i表示第几趟， 减少1 是最后剩下的一定是最大的数</span></span><br><span class="line">        min_loc = i  <span class="comment"># 将无序区第一个元素作为最小值进行比较，为了好进行位置交换操作，所以采用下标的形式</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(li)):  <span class="comment"># 此处使用i+1作为第一个元素，去除了自己和自己比的过程</span></span><br><span class="line">            <span class="keyword">if</span> li[j] &lt; li[min_loc]:</span><br><span class="line">                min_loc = j  <span class="comment"># 记录最小值的下标</span></span><br><span class="line">        li[i], li[min_loc] = li[min_loc], li[i]</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n²)</p>
<p>算法要点：<br>
每次得到表首的最小值，通过做标记，每次找出相对的较小值记录下标，一趟找出无序区的最小值与有序区某位交换位置。</p>
<h3 id="插入排序"><a class="header-anchor" href="#插入排序">¶</a>插入排序</h3>
<p>类似打牌插牌，初始手里（有序区）只有一张牌，每次（从无序区）摸一张牌，插入到手里已有牌的正确位置。</p>
<p>思路：<br>
头部第一个数据为有序区第一个值，然后从第二个数据开始做为无序区提供的值（使用参数记录元素值，因为位置需要提供给有序区），与有序区中现有值进行比较，确定插入的位置，现有值按序挪动位置，占用无序区数据的位置。</p>
<blockquote>
<p>挪位置的规则：从有序区最后一个值与待插入值进行大小比较，如果大于待插入值，则该元素移动（下标+1）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(li)):  <span class="comment"># i表示待插入的元素的下标</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 因为其所在位置要提供给有序区挪位，故记录</span></span><br><span class="line">        j = i - <span class="number">1</span>  <span class="comment"># j表示有序区最后元素的下标</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span>  li[j] &gt; tmp :</span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j+<span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n²)</p>
<p>最好情况时间复杂度：O(n)  顺序情况，此时内部while不执行。</p>
<p>算法要点：和选择排序的起始下标不同，为1开始，因为默认0已经是有序区的最小值。</p>
<h3 id="快速排序"><a class="header-anchor" href="#快速排序">¶</a>快速排序</h3>
<p>思路：<br>
取第一个元素p，使元素p归位（列表被分为两部分，左边都比p小，右边都比p大）。<br>
递归完成所有元素的排序（左右两部分分别归位（归位时都是取部分的第一个值作为归位元素），直到归位元素一侧元素个数为1或者0），从而完成整个列表的排序。<br>
所以，排序只要实现元素归位功能，然后递归即可。</p>
<p>快排算法框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">data, left, right</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    data 表示待排序的列表</span></span><br><span class="line"><span class="string">    left 待排序列表的起始下标</span></span><br><span class="line"><span class="string">    right 待排序列表的终点下标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:  <span class="comment"># 递归的终止条件，当左右相等的时候说明列表中只有一个元素，此时不需要进行排序</span></span><br><span class="line">        mid = partition(data, left, right)  <span class="comment"># mid 为归位元素的下标</span></span><br><span class="line">        quick_sort(data, left, mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(data, mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>归位算法实现：<br>
归位，指回到其该有的位置（在排序后应该在的位置），实现步骤如下：</p>
<ol>
<li>以列表的第一个值为待归位的元素（归位元素：使该元素左边的元素都是小于归位元素，右边的元素都大于归位元素），并记录该元素的值，此时列表产生一个空位。</li>
<li>从列表的最右边开始（因为步骤1选取列表第一个元素为待归位元素后，left指向的是待填补的空位），依次找小于待归位元素的值，没有就往前一个找，找到后，将元素放到空位left上，此时右边的位置提供了一个空位，然后从左边开始找大于待归位元素的元素，依次找大于待归位元素的值，找到后当到right空位上。</li>
<li>以此右边左边这样循环找，直到left=right，此时的空位为待归位元素的位置（最后必定是重叠的，都指向了归位元素所在的空位），保证了左边的元素都小于等于，右边都大于等于归位元素。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, left, right</span>):</span></span><br><span class="line">    tmp = li[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 当两侧指针重叠，取消循环</span></span><br><span class="line">        <span class="comment"># 一定要先从右边开始找，因为此时左侧有空位</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;=tmp:  <span class="comment"># 从右边往左找</span></span><br><span class="line">            right -= <span class="number">1</span>  <span class="comment"># 一旦大于等于tmp，往左一步</span></span><br><span class="line">        li[left] = li[right]  <span class="comment"># 将右边找出的小的值放在空位上</span></span><br><span class="line">        <span class="comment"># 右边找到填补空位后，再从左边开始找填补右边的空位</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]  <span class="comment"># 左边的值填补到右边的空位上</span></span><br><span class="line">    li[left] = tmp  <span class="comment"># 循环结束后，此时left = right ，并且都指向了空位</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># left 和 right 是同一个值</span></span><br></pre></td></tr></table></figure>
<p>快速排序的时间复杂度：O(nlogn)</p>
<p>复杂度的粗略估计依据：</p>
<ul>
<li>递归分层，对半分 <code>n/2</code>，每次减半，一共要分logn层，为 O(logn)</li>
<li>每层从全局上看是从左往右扫，扫描整个列表一次，所以每层的时间复杂度为 O(n)</li>
</ul>
<p>所以时间复杂度是 O(nlogn)</p>
<p>空间复杂度：O(logn)<br>
算法使用到了递归，递归需要消耗系统的内存资源，考虑平均情况下递归分层为 logn 层，所以使用空间复杂度为 O(logn)。</p>
<p>快速排序的问题，递归：</p>
<ul>
<li>python有递归最大深度的限制（可以更改），默认的递归深度是有限制的，当递归深度超过默认值的时候，就会引发RuntimeError。<br>
递归深度解决方式：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)  <span class="comment"># 表示递归深度为100w</span></span><br></pre></td></tr></table></figure>
</li>
<li>递归会消耗相当大的系统资源 — 内存</li>
</ul>
<p>快速排序最坏情况：<br>
好的情况下每次分层都是能够对半分 <code>n/2</code>，所以分层要分logn层，为 O(logn) ，但是最坏的情况，如 <code>[5,4,3,2,1]</code> 这种有顺序的列表，当前算法选取的left每次都是最大值，会导致分层的时候不是对半分，而是分为 <code>1</code> 和 <code>n-1</code> 两个部分，这就导致递归分层是的层数和 <code>n</code> 相同，此时分层的时间复杂度为 O(n)，所以最坏的情况下的时间复杂度为 O(n²)。同理，此时对应的最坏空间复杂度就为O(n)。</p>
<p>解决措施： 为了避免有序的列表使用快排产生的问题，此时可以使用 <code>随机主元</code> 的方式，即随机选取需要归位的元素，而非使用left位置的元素，这样可以一定程度上减轻倒序列表的影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_partition</span>(<span class="params">li, left, right</span>):</span></span><br><span class="line">    i = random.randint(left, right)  <span class="comment"># 随机产生需要归位的元素下标</span></span><br><span class="line">    tmp = li[i]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> right &gt; i <span class="keyword">and</span> li[right] &gt;= tmp:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[i] = li[right]</span><br><span class="line">        i = right  <span class="comment"># 将i指向新的空位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; i <span class="keyword">and</span> li[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[i] = li[left]</span><br><span class="line">        i = left</span><br><span class="line">    li[i] = tmp</span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p>通过运行时间分析，在处理倒序列表时，性能提升到处理一般数据的性能，在常规列表的测试下，性能与选取left位置元素相差无几。</p>
<p>算法要点：配合动画理解<br>
判断的标准始终是左边指针小于右指针，i始终指向的是空位。<br>
默认采用的以左边第一个为待归位值，实际上是一种特殊的情况，在代码实现中left和right即作为了元素指针，又作为空位指针。</p>
<h3 id="堆排序"><a class="header-anchor" href="#堆排序">¶</a>堆排序</h3>
<h4 id="树和二叉树"><a class="header-anchor" href="#树和二叉树">¶</a>树和二叉树</h4>
<p>树是一种数据结构<br>
一些概念：</p>
<ul>
<li>节点的度：表示某个节点的分叉个数</li>
<li>树的度：书中度最多的节点的度为树的度</li>
</ul>
<p>二叉树定义：</p>
<ul>
<li>度不超多2的树</li>
<li>每个节点最多有两个孩子节点</li>
</ul>
<p>完全二叉树：叶节点只能出现在最下层和次下层，并且最下层的节点都集中在该层最左边的若干位置的二叉树。<br>
满二叉树：一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树，满二叉树是特殊的完全二叉树。</p>
<p>二叉树的存储方式：</p>
<ul>
<li>链式存储方式</li>
<li>顺序存储方式：使用列表来存储</li>
</ul>
<p>完全二叉树父节点和左孩子节点的编号下标的关系： i -&gt; 2i+1     (i从0开始)<br>
完全二叉树父节点和左孩子节点的编号下标的关系： i -&gt; 2i+2     (i从0开始)<br>
反之，从孩子节点找父节点都可以采用 (孩子节点编号-1)//2 ，注意使用的是整除。</p>
<h4 id="堆"><a class="header-anchor" href="#堆">¶</a>堆</h4>
<p>一种特殊的完全二叉树。<br>
大根堆：一个完全二叉树，满足任一父节点都比其他孩子节点大。<br>
小根堆：一个完全二叉树，满足任一父节点都比其他孩子节点小。</p>
<p>升序排序采用大根堆排序，利用堆的向下调整的性质实现。<br>
向下调整性质：<br>
当根节点的左右子树都已经是堆（假设是最大值）的时候，但根不满足堆，可以通过一次向下的调整来将其变成一个堆。<br>
向下调整原理：<br>
根节点不是最大值，从其两个子节点中选取较大的值替换现在的根节点（选两者的较大值保证了堆的性质，能保证根大于孩子节点），出现的空位再使用空位节点的两个子节点以及之前的根节点中的较大值最为根节点值替换，以此类推，最后的空位使用出来的变量替换。</p>
<p>堆排序的过程：</p>
<ol>
<li>建立一个堆（升序使用的大根堆）。</li>
<li>得到堆顶的元素，为当前数据中的最大值。</li>
<li>去除堆顶，将堆的最后一个叶子结点（选取最后一个叶子节点，是为了保证经过调整之后，最后得到的树是一个完全二叉树）的元素放到堆顶，此时可通过一次调整性质得到大根堆。</li>
<li>将堆顶元素抛出，为当前数据中的第二大值。</li>
<li>重复步骤3，直到堆为空。</li>
</ol>
<p>堆的构造：<br>
一个完全二叉树，从最后一个非叶子节点开始，对每个小的子树进行向下调整，最后得到的就是一个堆。</p>
<h4 id="堆排序代码实现"><a class="header-anchor" href="#堆排序代码实现">¶</a>堆排序代码实现</h4>
<p>算法实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    大根堆向下调整实现</span></span><br><span class="line"><span class="string">    注意对的前提是此堆除了堆顶外，其他部分已经满足大根堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param li: 列表</span></span><br><span class="line"><span class="string">    :param low: 堆的根节点</span></span><br><span class="line"><span class="string">    :param high： 堆的最后一个元素的位置</span></span><br><span class="line"><span class="string">    :return</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># 开始指向根节点</span></span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># 开始指向左孩子节点</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 将堆顶元素存储</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:  <span class="comment"># 只要j没有越界，就表示i指向的节点不是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j+<span class="number">1</span>] &gt; li[j]:  <span class="comment"># 如果有右孩子节点，且相对较大</span></span><br><span class="line">            j = j + <span class="number">1</span>  <span class="comment"># 将j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &gt; tmp:</span><br><span class="line">            li[i] = li[j]  <span class="comment"># 直接兑换，因为以j为根的子树已经是大根堆，所以li[j]此时已经是最大的了</span></span><br><span class="line">            i = j  <span class="comment"># 同理，指向下一层，执行同样的步骤，为tmp找位置</span></span><br><span class="line">            j = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="comment"># 首先构造一个大根堆</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 倒推，从最后一个父节点开始找所有的父节点</span></span><br><span class="line">        <span class="comment"># i表示建堆开始的时候调整的部分的根的下标</span></span><br><span class="line">        sift(li, i, n-<span class="number">1</span>)  <span class="comment"># 从最后一个堆开始，每个小堆都可以使用向下调整得到大根堆，循环结束后，整个大根堆构造完成</span></span><br><span class="line">        <span class="comment"># 传递的high参数使用了一个小技巧</span></span><br><span class="line">    <span class="comment"># 开始挨个提出大根堆堆顶元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):  <span class="comment"># 从最后一个元素开始，用于替换为树的根节点，剩下的最后一个不需要进行调整，所以到0即可</span></span><br><span class="line">        li[<span class="number">0</span>], li[i] = li[i], li[<span class="number">0</span>]  <span class="comment"># 堆顶和最后一个元素交换，存储堆顶最大值，将最后一个叶子节点值放到堆顶开始调整</span></span><br><span class="line">        sift(li, <span class="number">0</span>, i-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>
其中，sift()函数的时间复杂度为O(logn)，这是因为最坏的情况需要进行二叉树的深度次数大概是logn，即当前完全二叉树的根值需要放到最底层的叶子节点位置才完成了大根堆。</p>
<p>实际表现堆排序相对快速排序要稍微慢一些。</p>
<h4 id="heapq模块"><a class="header-anchor" href="#heapq模块">¶</a>heapq模块</h4>
<p>python内置的堆排序模块heapq， 其中的 _siftdown() 方法实现的就是向下调整。<br>
heapq 表示的意思是 heap queue , 即用堆实现的优先队列（优先队列指小的元素先出，或者大的元素先出）。<br>
使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heapq.heapify(li)  <span class="comment"># 建堆，建造一个小根堆</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(li))  <span class="comment"># 往外弹出一个最小的元素</span></span><br></pre></td></tr></table></figure>
<h4 id="堆的思想的应用"><a class="header-anchor" href="#堆的思想的应用">¶</a>堆的思想的应用</h4>
<p>topk 问题：现有n个数，设计算法得到前k大的数（k &lt; n）。<br>
解决该问题的几种方式：</p>
<ul>
<li>排序后进行切片 O(nlogn)，k &lt; n，此处忽略切片的复杂度 O(k)，只考虑了排序的时间复杂度（排序采用时间复杂度更低的快排或者堆排）。</li>
<li>使用复杂度为 O(n²) 的排序算法，但只进行k次排序（因为topk问题只要前k大的数），总的时间复杂度为 O(kn)，当数据多，k小的时候，该算法明显优于方法1。</li>
<li>采用堆，思路和堆排序的实现类似，但是堆的元素只有k个，时间复杂度为 O(nlogk)。</li>
</ul>
<p>使用堆解决 topk 问题思路：</p>
<ol>
<li>取列表前 k 个元素建立一个 <strong>小根堆</strong>，堆顶就是目前第 k 大的数（ k 个元素中的最小的那个元素）。</li>
<li>依次向后遍历原列表，将列表中的元素与当前小根堆的堆顶元素比较，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素（此时堆内的元素就是目前 k 个最大的元素，堆顶是 k 个元素中最小的），并且对堆进行依次调整。</li>
<li>遍历列表所有元素后，倒序弹出堆顶元素。</li>
</ol>
<blockquote>
<p>topk 问题一定要采用小根堆，因为堆中元素的大小关系，只能保证的是堆顶元素一定是最大的（使用大根堆）或者最小的（使用小根堆）。</p>
</blockquote>
<p>此方式的时间复杂度为 O(nlogk)，需要遍历所有的数 n，但是堆的元素个数始终只有 k 个，所以此时 sift() 函数的时间复杂度和 k 相关，为O(logk)，所以使用堆解决 topk 的时间复杂度为O(nlogk)</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    小根堆向下调整</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  </span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>  </span><br><span class="line">    tmp = li[low] </span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:  </span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j+<span class="number">1</span>] &lt; li[j]:  </span><br><span class="line">            j = j + <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">if</span> li[j] &lt; tmp:</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j  </span><br><span class="line">            j = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span>(<span class="params">li, k</span>):</span></span><br><span class="line">    heap = li[<span class="number">0</span>:k]</span><br><span class="line">    <span class="comment"># 建堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((k-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift(heap, i, k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 遍历列表剩余元素，如果比堆顶元素大，就替换并重新调整小根堆</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最初的根堆：&#x27;</span>, heap)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>] = li[i]</span><br><span class="line">            sift(heap, <span class="number">0</span>, k-<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;小排序：&#x27;</span>, heap)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;完成：&#x27;</span>, heap)</span><br><span class="line">    <span class="comment"># 倒序输出堆中的元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        heap[<span class="number">0</span>], heap[i] = heap[i], heap[<span class="number">0</span>]</span><br><span class="line">        sift(heap, <span class="number">0</span>, i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a class="header-anchor" href="#归并排序">¶</a>归并排序</h3>
<p>归并：将两个有序的列表合并为一个有序的列表</p>
<p>归并排序步骤：</p>
<ol>
<li>分解：将列表越分越小，直至分成一个元素为一个列表。</li>
<li>终止条件： 一个元素是有序的。</li>
<li>合并： 将两个有序列表归并，列表越来越大。</li>
</ol>
<p>算法实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">li, low, mid, high</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    归并</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    i = low</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    ltmp = []  <span class="comment">#  设置临时变量</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;= mid <span class="keyword">and</span> j &lt;= high:  <span class="comment"># 只要左右两边都有数</span></span><br><span class="line">        <span class="keyword">if</span> li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># while执行完，两部分肯定有一部分是没有值的</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    li[low:high+<span class="number">1</span>] = ltmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:  <span class="comment"># 至少有两个元素，递归，只有一个元素时不需要处理</span></span><br><span class="line">        mid = (low+high) // <span class="number">2</span></span><br><span class="line">        merge_sort(li, low, mid)</span><br><span class="line">        merge_sort(li, mid+<span class="number">1</span>, high)</span><br><span class="line">        merge(li, low, mid, high)  <span class="comment"># 通过递归，此函数第一次执行的时候，一定是两个各位1个元素的列表的集合。</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>
空间复杂度：O(n)<br>
之前的排序都是原地排序，但是归并排序需要使用一个中间列表存储一次归并后的列表，所以需要使用额外的空间，需要考虑空间复杂度</p>
<p>Python 内置的 <code>list.sort()</code> 方法内部实现是基于归并排序的 <code>TimSort</code> 排序算法，是结合了归并排序以及插入排序的排序算法。</p>
<h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3>
<p>一般情况下，就运行时间而言：<br>
快速排序 &lt; 归并排序 &lt; 堆排序</p>
<p>三种排序算法的缺点：</p>
<ul>
<li>快速排序：极端情况下（倒序）效率低，为 O(n²)。</li>
<li>归并排序：需要额外的内存开销。</li>
<li>堆排序： 在快的排序算法中相对较慢 。</li>
</ul>
<p><img src="/2020/08/03/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4.jpg" alt="常规算法时间空间复杂度"></p>
<p>排序的稳定性：当两个元素的值一样的时候，保证他们的相对位置不变。<br>
一般的，挨个比较的都是稳定的，如冒泡排序、插入排序、归并排序等。</p>
<h3 id="希尔排序"><a class="header-anchor" href="#希尔排序">¶</a>希尔排序</h3>
<p>由插入排序变形而来，是一种分组插入排序。<br>
步骤：</p>
<ol>
<li>首先取一个整数d𝟭=n/2，将元素分为d𝟭个组，每组相邻两个元素之间的距离为 d𝟭，在各组内进行直接插入排序。</li>
<li>取第二个整数d𝟮=d𝟭/2， 重复上述分组排序过程，直到d𝐢=1，即所有元素在同一个组内进行直接插入排序。</li>
</ol>
<p>希尔排序每趟并不使元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort_gap</span>(<span class="params">li, gap</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i- gap</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; tmp:</span><br><span class="line">            li[j+gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j+gap] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    d = <span class="built_in">len</span>(li) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> d &gt;= <span class="number">1</span>:</span><br><span class="line">        insert_sort_gap(li, d)</span><br><span class="line">        d //= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>和插入排序的性能对比：强于普通的插入排序，稍慢于堆排序（所以也比快速排序以及归并排序慢）</p>
<p>希尔排序的时间复杂度：没有明确的值，取决于 gap 的选择，不同的 gap，得到的时间复杂度也不相同，我们选取的 gap 为 N/2ᴷ，时间复杂度介于 O(nlogn) 和 O(n²) 之间。</p>
<h3 id="计数排序"><a class="header-anchor" href="#计数排序">¶</a>计数排序</h3>
<p>是一个非基于比较的排序算法。<br>
<strong>前提条件是，需要知晓待排序的列表中的元素值的范围。</strong></p>
<p>解决诸如以下问题：<br>
对列表进行排序，已知列表中数的范围都在0到100之间，设计时间复杂度为O(n)的排序算法。</p>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span>(<span class="params">li, max_count=<span class="number">100</span></span>):</span></span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_count+<span class="number">1</span>)]  <span class="comment"># 建立一个用于计数的列表，列表的下标用于记录数，下标上的值作为统计的个数</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">        count[val] += <span class="number">1</span></span><br><span class="line">    li.clear()  <span class="comment"># 使用原先的列表空间作为排序后的列表空间</span></span><br><span class="line">    <span class="keyword">for</span> ind, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(count):  <span class="comment"># 操作的对象不是n(这里的排序对象li），所以不参与时间复杂度计算，涉及到n的部分实际上就是li.append(ind)的过程，为O(n)，所以整体的时间复杂度为O(n)</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(val):  </span><br><span class="line">            li.append(ind)</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">li = [random.randint(<span class="number">0</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line">count_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>
<p>它的优势在于在对一定范围内的整数排序时，它的复杂度为 Ο(n+k)（其中k是整数的范围），快于其他任何的 <code>比较排序</code> 算法。当然这是一种牺牲空间换取时间的做法，而且当 O(k)&gt;O(nlog(n)) 的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是 O(nlog(n)), 如归并排序，堆排序）。</p>
<h3 id="桶排序"><a class="header-anchor" href="#桶排序">¶</a>桶排序</h3>
<p>在计数排序中，如果元素范围比较大，为了构造相应的列表就会消耗大量的资源，此时可以使用桶排序的方式进行改造(避免了未存在的元素占用列表空间)。<br>
桶排序（Bucket Sort）：首先将元素分在不同的桶中，再对每个桶中元素进行排序。</p>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span>(<span class="params">li, n=<span class="number">100</span>, max_num=<span class="number">10000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n : 桶的个数</span></span><br><span class="line"><span class="string">    max_num: 所有的数中的最大值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    bucketes = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 创建桶</span></span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> li:  <span class="comment"># 数据入桶</span></span><br><span class="line">        i = <span class="built_in">min</span>(var // (max_num//n), n-<span class="number">1</span>) <span class="comment"># i 表示 var 放到几号桶里，桶号从0开始</span></span><br><span class="line">        <span class="comment"># 使用min(.., n-1)是为了处理临界情况，超过的数放到最后的桶中</span></span><br><span class="line">        bucketes[i].append(var)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bucketes[i])-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> bucketes[i][j] &lt; bucketes[i][j-<span class="number">1</span>]:</span><br><span class="line">                bucketes[i][j], bucketes[i][j-<span class="number">1</span>] = bucketes[i][j-<span class="number">1</span>], bucketes[i][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    sorted_li = []</span><br><span class="line">    <span class="keyword">for</span> buc <span class="keyword">in</span> bucketes:</span><br><span class="line">        <span class="comment"># sorted_li += buc</span></span><br><span class="line">        sorted_li.extend(buc)</span><br><span class="line">    <span class="keyword">return</span> sorted_li</span><br></pre></td></tr></table></figure>
<p>分析：<br>
代码的核心内容是<code>i = min(var // (max_num//n), n-1) </code>，该语句巧妙的完成了分桶以及数据的入桶，这是一种平均情况下的分桶策略，对于如果数据分布集中的情况下，可以对集中部分的桶再进行分桶，这取决于具体的数据情况。<br>
分桶的桶的数量取决于数据中的最大值。</p>
<p>桶排序的表现取决于数据的分布，假使大部分的数据都集中在一个桶中，则性能就取决于一个桶的排序性能，而我们使用桶排序的目的是为了将数据分散在不同的桶中，每个桶中存储等量较少值，然后对较少的值进行排序，这样排序性能才会有所提升。也就是需要对不同数据排序时采取不同的分桶策略。</p>
<p>平均情况的时间复杂度：O(n+k)<br>
最坏情况时间复杂度：O(n²k)<br>
空间复杂度：O(nk)<br>
*k 通过n和m算出（n表示数据的个数，m表示桶的个数），k表示一个桶的大小。</p>
<p>优化建议：桶内数据的排序方式、不同数据分布下，分桶的策略。</p>
<h3 id="基数排序"><a class="header-anchor" href="#基数排序">¶</a>基数排序</h3>
<p>类似关键字排序，基于桶排序，但是不使用桶内排序，而是借助桶的顺序（0-9的桶），完成每个数位上的数值大小的排序，从而实现所有数据的排序。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    max_num = <span class="built_in">max</span>(li)  <span class="comment"># 最大值的位数决定了循环的次数</span></span><br><span class="line">    it = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">10</span> ** it &lt;= max_num:</span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> var <span class="keyword">in</span> li:</span><br><span class="line">            digit = (var // <span class="number">10</span> ** it) % <span class="number">10</span></span><br><span class="line">            buckets[digit].append(var)</span><br><span class="line">        <span class="comment"># 分桶完成</span></span><br><span class="line">        li.clear()</span><br><span class="line">        <span class="keyword">for</span> buc <span class="keyword">in</span> buckets:</span><br><span class="line">            li.extend(buc)  <span class="comment"># 把数据直接写会原来的数组，此时数组已经完成了个位数的排序，然后继续执行十位数的排序，依次进行。</span></span><br><span class="line">        it += <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p>关键点：没有使用内部排序，而是借助0-9的桶的相对位置来完成数据的排序。<br>
时间复杂度：O(kn)<br>
空间复杂度：O(k+n)<br>
k表示数字的位数，代码中的it。</p>
<p>分析：基数排序的时间复杂度是线性的，相比于非线性的快速排序，在特定的情况下的数据</p>
<h3 id><a class="header-anchor" href="#">¶</a></h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/23/Base64-%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/23/Base64-%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">Base64 编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-23 22:32:18" itemprop="dateCreated datePublished" datetime="2020-07-23T22:32:18+08:00">2020-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-18 11:22:37" itemprop="dateModified" datetime="2020-12-18T11:22:37+08:00">2020-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">开发问题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/07/23/Base64-%E7%BC%96%E7%A0%81/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/23/Base64-%E7%BC%96%E7%A0%81/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/07/23/Base64-%E7%BC%96%E7%A0%81/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/Flask%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Flask%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">Flask初探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:51:22 / 修改时间：21:13:39" itemprop="dateCreated datePublished" datetime="2020-06-01T20:51:22+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Flask/" itemprop="url" rel="index"><span itemprop="name">Flask</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/01/Flask%E5%88%9D%E6%8E%A2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/01/Flask%E5%88%9D%E6%8E%A2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Flask是目前十分流行的web框架，采用Python编程语言来实现相关功能。它被称为微框架(microframework)，“微”并不是意味着把整个Web应用放入到一个Python文件，微框架中的“微”是指Flask旨在保持代码简洁且易于扩展，Flask框架的主要特征是核心构成比较简单，但具有很强的扩展性和兼容性，程序员可以使用Python语言快速实现一个网站或Web服务。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/01/Flask%E5%88%9D%E6%8E%A2/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/24/Django-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/Django-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Django+Vue 前后端分离项目的跨域请求问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 10:36:01" itemprop="dateCreated datePublished" datetime="2020-05-24T10:36:01+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 09:51:18" itemprop="dateModified" datetime="2020-06-08T09:51:18+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">开发问题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/05/24/Django-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/05/24/Django-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>解决在先后端分离的项目中，由于跨端口导致的跨域请求问题...</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/24/Django-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="Your advantages today will be replaced by future trends, so keep learning.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/Django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Django静态资源配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 18:54:25" itemprop="dateCreated datePublished" datetime="2020-04-30T18:54:25+08:00">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 09:23:18" itemprop="dateModified" datetime="2020-06-09T09:23:18+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">开发问题</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Django/" itemprop="url" rel="index"><span itemprop="name">Django</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/04/30/Django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="静态文件"><a class="header-anchor" href="#静态文件">¶</a>静态文件</h2>
<p>静态文件的配置，一般需要使用到以下几个参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL</span><br><span class="line">STATIC_ROOT</span><br><span class="line">STATICFILES_DIRS</span><br></pre></td></tr></table></figure>
<h3 id="STATIC-URL"><a class="header-anchor" href="#STATIC-URL">¶</a>STATIC_URL</h3>
<p><code>STATIC_URL</code> 是必须设置的，提供了静态文件访问的映射关系，如设置 <code>STATIC_URL='/static/'</code> 时（名字可以自定义，这个是访问所有的静态文件的根名），访问静态文件的路径就是 <code>127.0.0.1：8000/static/静态文件名</code>。在设置了该参数之后，Django实际上就有了访问静态文件的能力，所以说该参数是必须设置的。</p>
<p>在开发模式下（DEBUG设置为True），Django提供了静态文件代理的功能，会自动识别每个 app下静态文件（前提是，这些静态文件夹必须设置在每个app之下，且使用的名字必须是static，这是因为Django内部做了相应的处理，只有名字 <code>static</code> 才会被Django自带的静态文件代理服务器识别），提供访问。</p>
<p>设置app下的静态文件夹的时候，内部最好有一个用当前app名字命名的文件夹，并在该文件夹下放置相应的静态文件（这是因为不做区分，万一多个app之间有同名的静态文件，Django就会混淆），此时这些静态文件的访问地址就是： 127.0.0.1：8000/static/app命名的文件夹/相应的静态文件<br>
例如，第三方插件xadmin这个app就是这样设计的：<br>
<img src="/2020/04/30/Django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/xadmin.png" alt="第三方插件xadmin图片"></p>
<p>此外，设置了该参数之后，在模板层通过引入 <code>&#123; % load staticfiles % &#125;</code> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>标签，可以在模板中使用 <code>href=&quot;&#123; % static 'css/reset.css' % &#125;&quot;</code><sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup> 构建静态资源路径的构建，这样当对 <code>STATIC_URL</code> 指定的静态文件的根名方法改变的时候，不需要修改模板中的访问路径，依然能够访问，效果和<code>&#123; % url '' % &#125;</code><sup class="footnote-ref"><a href="#fn1" id="fnref1:2">[1:2]</a></sup>类似。</p>
<h3 id="STATICFILES-DIRS"><a class="header-anchor" href="#STATICFILES-DIRS">¶</a>STATICFILES_DIRS</h3>
<p>只在开发模式下有效，对于一些公共的静态文件，或者在项目中自建app的时候不想为每个app单独设置静态文件夹，为了方便管理，可以单独在项目的根目录下设置一个文件夹统一管理所有的静态文件（但是这个文件夹无法被开发模式下Django自带的静态文件代理服务定位到，所以必须使用STATICFILES_DIRS进行设置），设置如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局静态文件访问配置</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">&#x27;集中管理的文件名&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 也可以设置多个静态文件夹</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">&#x27;static&#x27;</span>),</span><br><span class="line">    os.path.join(BASE_DIR,  <span class="string">&#x27;xxx/static&#x27;</span>)  <span class="comment"># 可以设置多个静态文件查找路径</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样在项目根目录下创建 <code>集中管理的文件名</code>文件，在里面放置静态文件，此时静态文件的访问地址是 <code>127.0.0.1：8000/static/集中管理的文件名中的静态文件</code> 。</p>
<blockquote>
<p>STATICFILES_DIRS 的设置只是提供给开发模式下的Django自带静态文件代理服务定位静态文件用的。</p>
</blockquote>
<h3 id="STATIC-ROOT"><a class="header-anchor" href="#STATIC-ROOT">¶</a>STATIC_ROOT</h3>
<p>在Django项目部署上线的时候，DEBUG需要设置为False，Django 不再提供静态文件代理功能，app自带的静态文件夹分布在各app下无法访问到，此时需使用 <code>pyhton manage.py collectstatic</code> 收集所有的静态文件，STATIC_ROOT就是用来设置所有的静态文件的聚合目录，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;static&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用 <code>python manage.py collectstatic</code> 之后，django会把所有的static文件都复制到STATIC_ROOT文件夹下。</p>
<h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3>
<ol>
<li>无论是开发模式还是生产环境下，Django项目都依赖STATIC_URL=’/static/'的设置，因为这提供了静态文件访问的映射关系，有了他，Django才能够访问静态文件。</li>
<li>STATICFILES_DIRS用于指定在项目根目录下统一管理的静态文件夹的名字，但只是在开发过程中有效以及使用，生产环境下，所有的静态文件都将被收集到统一的目录下（包括 STATICFILES_DIRS 的），交给第三方静态服务器调度提供。</li>
<li>若存在app下的static和STATICFILES_DIRS设置中同名的文件，默认访问的是STATICFILES_DIRS设置的静态文件下的，所以在app下的static中再设置一个app名的文件夹对静态文件管理，这样在访问时加上app名127.0.0.1：8000/static/app名，这样可以有效避免一些重名问题。</li>
<li>关于static目录的位置设置使用建议，若website中的每个app的独立性非常强的话，就在每个单独的app下设置static目录，这样app就会支持热插拔，独立性强。若app的独立性不强，app之间相互联系的话，建议使用集中管理static的方法。但是无论使用哪种方式，在项目部署的时候，都会进行静态文件的收集，由第三方静态服务器管理。</li>
</ol>
<h2 id="media文件"><a class="header-anchor" href="#media文件">¶</a>media文件</h2>
<p>设置和static类似，因为在开发模式下（DEBUG需要设置为True），Django并不提供media文件的代理服务，所以即使在开发模式下，也需要手动设置medai文件的代理。</p>
<h3 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h3>
<p>需要同时设置MEDIA_URL和MEDIA_ROOT</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># media文件的路径</span></span><br><span class="line">MEDIA_URL = <span class="string">&quot;/media/&quot;</span> <span class="comment"># 可以改名</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;media&#x27;</span>)  <span class="comment"># media为放置 media文件的文件夹名</span></span><br></pre></td></tr></table></figure>
<p>解释：<br>
设置<code>MEDIA_ROOT</code>后，Django做了一定的处理，能够使上传的文件传到<code>MEDIA_ROOT</code>指定的文件中，如models.py中指定的模型有些有 <code>upload_to=&quot;org/%Y/%m&quot;</code>，这样指定后，就会在media中创建 <code>org/年/月</code> 的文件夹存储文件。此时仅仅设置 <code>MEDIA_ROOT</code> 参数，就可以完成上传时自动放到设置的media目录下。但是此时的图片访问地址是当前所在页面的地址，加上存储的地址，为<code>当前所在地址/org/%Y/%m/图片</code>。</p>
<p>若想访问到meida中的地址，还需要设置<code>MEDIA_URL=&quot;/media/&quot; </code>，设置之后访问media的路径就变成了<code>127.0.0.1：8000/media/org/%Y/%m/图片</code>。但是目前通过这个地址还是访问不了media（这点和static不同），Django没有对media的访问做处理，还需要我们手动对url的访问处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目urls.py中设置url</span></span><br><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve  <span class="comment"># 静态文件处理的view，该方法接受path参数</span></span><br><span class="line"><span class="comment"># 配置上传文件的访问url</span></span><br><span class="line">url(<span class="string">r&#x27;^media/(?P&lt;path&gt;.*)$&#x27;</span>, serve, &#123;<span class="string">&quot;document_root&quot;</span>: MEDIA_ROOT&#125;),</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span>(<span class="params">request, path, document_root=<span class="literal">None</span>, show_indexes=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这个方法serve是一个专门用于处理静态文件的view，这里的用法就和我们定义一个view视图处理url请求一样，&lt;path&gt;中设置的参数path会传递给view处理函数，也就是这里的serve函数，</span></span><br><span class="line"><span class="string">&#123;&quot;document_root&quot;: MEDIA_ROOT&#125;这叫额外参数，为dict类型，额外参数只能被视图函数（这里的serve）读取</span></span><br><span class="line"><span class="string">通过serve参数可见，设置的path和document_root都是serve()的参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此时就完成了media文件的访问。</p>
<h3 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h3>
<p>媒体文件都是通过models.py中模型通过设置 <code>upload_to</code> 字段将文件的路径存储在数据库中，文件存储在MEDIA_ROOT设置的路径之中，所以在使用的时候，数据库中只能读取到 <code>upload_to</code> 时的路径 <code>/org/年/月/文件名</code>，而这个路径是不完整的，想要访问到文件还需要添加MEDIA_URL设置的前缀。<br>
在模板层中想要获得MEDIA_URL设置的前缀可以view视图进行传递，然后在模板层中使用 <code>data-url=&quot;&#123; &#123; MEDIA_URL &#125; &#125; &#123; &#123; org.image &#125; &#125;&quot;</code><sup class="footnote-ref"><a href="#fn1" id="fnref1:3">[1:3]</a></sup>，但是这样写的话，意味着要在每个views中传递MEDIA_URL参数，这是非常不好的。可以使用类似注入的方式，将MEDIA_URL注入到模板中，使其可以在模板中直接被调用。<br>
Django自带了一些注入，如在模板中，直接可以使用<code>&#123; % if request.user.is_authenticated % &#125;</code><sup class="footnote-ref"><a href="#fn1" id="fnref1:4">[1:4]</a></sup>调用request.user设置直接使用user进行操作，这是因为在settings.py中的进行了如下的设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR, <span class="string">&#x27;templates&#x27;</span>)]  <span class="comment"># 该项目一定要配置</span></span><br><span class="line">        ,</span><br><span class="line">        <span class="string">&#x27;APP_DIRS&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;context_processors&#x27;</span>: [</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.debug&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.request&#x27;</span>,  <span class="comment"># 注册了该条语句，能够使用request</span></span><br><span class="line">                <span class="string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,  <span class="comment"># 能够直接使用user， 返回的也是request.user</span></span><br><span class="line">                <span class="string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return context variables required by apps that use Django&#x27;s authentication</span></span><br><span class="line"><span class="string">    system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If there is no &#x27;user&#x27; attribute in the request, use AnonymousUser (from</span></span><br><span class="line"><span class="string">    django.contrib.auth).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(request, <span class="string">&#x27;user&#x27;</span>):</span><br><span class="line">        user = request.user </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AnonymousUser</span><br><span class="line">        user = AnonymousUser()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: user,</span><br><span class="line">        <span class="string">&#x27;perms&#x27;</span>: PermWrapper(user),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>django中已经提供好了<code>django.template.context_processors.media</code>只要添进去即可<br>
我们看一下这个函数media的逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">media</span>(<span class="params">request</span>):</span></span><br><span class="line">  	<span class="keyword">return</span> &#123;<span class="string">&#x27;MEDIA_URL&#x27;</span>: settings.MEDIA_URL&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑相当简单，这样我们也可以模仿使用类似的方式定义我们自己的context_processors<br>
之后再模板中使用图片的方式为：src=&quot;{ { MEDIA_URL } }{ { hot_course.image } }&quot;<sup class="footnote-ref"><a href="#fn1" id="fnref1:5">[1:5]</a></sup></p>
<p>若不不使用模板层的<code>context_processors</code>注入方法，还可以使用image model（models.ImageField）的自带属性方法url，他会自动拼接形成一个可以方法的url，如src=&quot;{ { hot_course.image.url } }&quot;<sup class="footnote-ref"><a href="#fn1" id="fnref1:6">[1:6]</a></sup>。实际使用中也推荐使用该种方法，因为不需要做额外的操作，直接调用图片属性的url，即可自动拼接成图片相应的访问地址。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Django模版语法中，此处的两个中括号之间以及中括号和百分号之间是没有空格的，由于hexo的限制，写在一起无法显示，故作此说明。 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a> <a href="#fnref1:2" class="footnote-backref">↩︎</a> <a href="#fnref1:3" class="footnote-backref">↩︎</a> <a href="#fnref1:4" class="footnote-backref">↩︎</a> <a href="#fnref1:5" class="footnote-backref">↩︎</a> <a href="#fnref1:6" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Skylor Tang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Skylor Tang</p>
  <div class="site-description" itemprop="description">Your advantages today will be replaced by future trends, so keep learning.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skylor Tang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'bva4r4SJYiDLdhU1ALkqpbqw-gzGzoHsz',
      appKey     : 'bWLTGKg8MzPrXsAvC3YDMehj',
      placeholder: "欢迎留言",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
