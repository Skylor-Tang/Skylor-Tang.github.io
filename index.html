<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Your advantages today will be replaced by future trends, so keep learning.">
<meta property="og:type" content="website">
<meta property="og:title" content="Skylor Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Skylor Blog">
<meta property="og:description" content="Your advantages today will be replaced by future trends, so keep learning.">
<meta property="article:author" content="Skylor Tang">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Skylor Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Skylor Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/30/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/" itemprop="url">Go基础之面向接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-30T18:21:33+08:00">
                2020-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向接口"><a href="#面向接口" class="headerlink" title="面向接口"></a>面向接口</h1><p>golang是一门面向接口的语言，没有传统的继承和多态，golang的面向对象仅支持封装（通过定义结构实现，type struct_name struct），而继承和多态是通过接口来实现的。所以golang的接口要比其他语言灵活的多。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Traversal <span class="keyword">interface</span> &#123;</span><br><span class="line">  Traverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  traversal := getTraversl()</span><br><span class="line">  traversal.Traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>duck typing</p>
<ul>
<li>描述事物的外部行为而非内部结构</li>
<li>严格说go属于结构化类型系统，类似duck typing </li>
</ul>
<p>Go中的duck typing </p>
<ul>
<li>同时能实现多个接口</li>
<li>同时具有python, c++的duck typing的灵活性 — 只要实现了某个方法，就能被调用</li>
<li>又具有Java的类型检查 — 不是动态语言的运行时检查，也不是静态语言的编译时才检查，而是在实现代码的过程中就知道必须要</li>
</ul>
<h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><ul>
<li><p>接口由使用者定义，而非传统的为某个被调用者实现某个方法，告诉其他调用者，我实现了该方法，你们可以调用我。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(url <span class="keyword">string</span>) <span class="keyword">string</span>   <span class="comment">// 注意：interface中定义函数不需要使用func关键字，会自动识别为函数，因为interface内部本身都是函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Get(<span class="string">"www.xxx.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上为接口的定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r Retriever    <span class="comment">// 此处的Retriever是上面的接口对象</span></span><br><span class="line">	r = mock.Retriever&#123;<span class="string">"this is a fack xxx.com"</span>&#125; <span class="comment">// 此处可见，接口类型变量可以接受其实现类型的变量</span></span><br><span class="line">	fmt.Println(download(r))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock包中定义实现接口的方法</span></span><br><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;      <span class="comment">// 注意，结构名要大写，因为是要在本包外被调用</span></span><br><span class="line">	Contents <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Contents</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上为接口的实现</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>接口的实现是隐式的</p>
</li>
<li><p>只要实现接口里的方法，不需要指明说 我是实现了某个接口，只要实现了接口的（全部）方法即可</p>
<p>上面的例子中，定义了含有Get方法的接口，并定义了一个使用该接口类型（Retriever类型）的函数，在该函数中调用了接口定义的Get方法</p>
<p>实现接口的时候，只要实现了该接口中定义的方法之后，就能够被download函数使用，虽然该函数接受的是接口类型，但是是能够接受该接口类型的实现类型的。接口类型变量可以接受其实现类型的变量。</p>
</li>
<li><p>和Python中的type typing类似的地方在于都是只要实现了某个方法，就能被调用（Python中通过魔法函数实现）。</p>
</li>
<li><p>但是要注意，因为接口本身功能的要求，实现时，必须实现接口内定义的所有的类型</p>
</li>
<li><p>可以有多个结构实现了同一个接口，一个结构也可以同时实现多个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> all <span class="keyword">struct</span> &#123;</span><br><span class="line">	content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a all)</span> <span class="title">Post</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"post"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a all)</span> <span class="title">Get</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"get"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AllMethod</span><span class="params">(r Retriever, m MyTest)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Get(<span class="string">"http://www.baidu.com"</span>) + <span class="string">" "</span> + m.Post(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := all&#123;<span class="string">"aaa"</span>&#125;</span><br><span class="line">	fmt.Println(AllMethod(m, m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">get post</span><br></pre></td></tr></table></figure>

<h2 id="接口的值类型"><a href="#接口的值类型" class="headerlink" title="接口的值类型"></a>接口的值类型</h2><p>因为go语言中都是值类型，所以定义变量的时候，值实际是应该有值的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r Retriever <span class="comment">// 此处的Retriever是上面的接口对象</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T %v\n"</span>,r,r)</span><br><span class="line">	r = mock.Retriever&#123;<span class="string">"this is a fack xxx.com"</span>&#125;<span class="comment">// 此处可见，接口类型变量可以接受其实现类型的变量</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T %v\n"</span>,r,r)</span><br><span class="line">	r = <span class="built_in">real</span>.Retriever&#123;</span><br><span class="line">		UserAgent: <span class="string">"Mozilla/5.0"</span>,</span><br><span class="line">		Timeout: time.Minute,    <span class="comment">// 一旦换行，每个k/v值后需要添加逗号</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%T %v\n"</span>,r,r)</span><br><span class="line">	fmt.Println(reflect.TypeOf(r))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">mock.Retriever &#123;this is a fack xxx.com&#125;</span><br><span class="line"><span class="built_in">real</span>.Retriever &#123;Mozilla/<span class="number">5.0</span> <span class="number">1</span>m0s&#125;</span><br><span class="line"><span class="built_in">real</span>.Retriever</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = &amp;<span class="built_in">real</span>.Retriever&#123;</span><br><span class="line">		UserAgent: <span class="string">"Mozilla/5.0"</span>,</span><br><span class="line">		Timeout: time.Minute,    <span class="comment">// 一旦换行，每个k/v值后需要添加逗号</span></span><br><span class="line">	&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v\n"</span>,r,r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">*<span class="built_in">real</span>.Retriever &amp;&#123;Mozilla/<span class="number">5.0</span> <span class="number">1</span>m0s&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/%E5%8C%85%E5%92%8C%E5%B0%81%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/30/%E5%8C%85%E5%92%8C%E5%B0%81%E8%A3%85/" itemprop="url">Go基础之包和封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-30T20:10:23+08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>通过命名来实现封装</p>
<ul>
<li>名字一般使用CamelCase</li>
<li>首字母大写：public</li>
<li>首字母小写：private</li>
</ul>
<p>相对于 包 而言，若一个外部的包想要访问本包内定义的结构，和  结构的方法（不仅仅是结构，定义的一般方法若想被其他包使用，也是要大写首字母的），这些命名，包括结构内变量的命名都要采用大写。</p>
<p>但是在同一个包下的内容可以随便调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value       <span class="keyword">int</span></span><br><span class="line">	Left, Right *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node Node)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(node.Value, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">SetValue</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Setting Value to nil "</span> +</span><br><span class="line">			<span class="string">"node. Ignored."</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	node.Value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(value <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Node&#123;Value: value&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><ul>
<li>每个目录一个包，只能是同一种包</li>
<li>main包包含可执行入口– main函数，只有main包才能有main函数</li>
<li>为结构定义的方法必须放在同一个包内</li>
<li>可以是同一个包内的不同文件，对包外来说，只要知道包名，都可以使用，不需要知道文件名</li>
</ul>
<p>使用时，import导入的是存放包的目录名，同一个目录下只能有一种包名，用来表示包内文件的关系，以及被其他包使用时的开头 <code>包名.方法或变量</code>。但是为了不产生歧义，最好使用的时候，包名和目录名设置成一致的即可。</p>
<h2 id="如何扩充系统类型或者别人的类型"><a href="#如何扩充系统类型或者别人的类型" class="headerlink" title="如何扩充系统类型或者别人的类型"></a>如何扩充系统类型或者别人的类型</h2><p>在含有继承的语言中，可以通过继承的方式来扩充原有的功能，但是在go中是没有继承的概念的。Go采用以下两种方式来扩充：</p>
<ul>
<li>定义别名</li>
<li>使用组合</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用组合的方式来完成    扩充自定义的treeNode结构，增加后序遍历的功能</span></span><br><span class="line"><span class="keyword">type</span> myTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	node *tree.Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *myTreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> myNode == <span class="literal">nil</span> || myNode.node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	left := myTreeNode&#123;myNode.node.Left&#125;</span><br><span class="line">	right := myTreeNode&#123;myNode.node.Right&#125;</span><br><span class="line"></span><br><span class="line">	left.postOrder()</span><br><span class="line">	right.postOrder()</span><br><span class="line">	myNode.node.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用别名的方式来完成  扩充[]int切片类型，提供Push、Pop、IsEmpty的功能</span></span><br><span class="line"><span class="keyword">package</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment">// A FIFO queue.</span></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span>    <span class="comment">// 使用type 定义了[]int类型的别名 Queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pushes the element into the queue.</span></span><br><span class="line"><span class="comment">// 		e.g. q.Push(123)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	*q = <span class="built_in">append</span>(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pops element from head.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	head := (*q)[<span class="number">0</span>]</span><br><span class="line">	*q = (*q)[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if the queue is empty or not.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GOPATH环境变量"><a href="#GOPATH环境变量" class="headerlink" title="GOPATH环境变量"></a>GOPATH环境变量</h1><ul>
<li>默认在~/go（Unix，Linux）</li>
<li>官方推荐：所有项目和第三方库都放在同一个GOPATH下</li>
<li>也可以将每个项目放在不同的GOPATH</li>
<li>GO在 编译 的时候会自动到每个GOPATN下找到自己所依赖的包</li>
</ul>
<p>正常情况下  go get golang.org/x/tools/cmd/goimports</p>
<p>使用gopm来获取无法下载的包</p>
<p>go get -v github.com/gpmgo/gopm</p>
<ul>
<li>go build 来编译</li>
<li>go install 产生pkg文件和可执行文件</li>
<li>go run 直接编译运行</li>
</ul>
<p>gopath下三个文件夹，bin 放go install的可执行文件， pkg 存放包文件，src  为项目源代码，也是可以使被掉</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/14/Docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/14/Docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4/" itemprop="url">Docker 基本使用以及命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-14T14:45:11+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Docker是基于Go实现的云开源项目。<br>Docker的主要目标是“Build, Ship and Run Any App,Anywhere”，也就是通过对用用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB项目或者数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。将应用运行在Docker容器上面，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<font color="red">只需要一次配置文件，换到别的机器上就可以一键部署，大大简化了操作。</font><br>Docker解决了运行环境和配置问题软件容器，方便做持续继承并有助于整体发布的容器虚拟化技术。</p>
<h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><ul>
<li>虚拟机<br>缺点：1.占用资源多 2.冗余步骤多 3.启动慢</li>
<li>容器虚拟化技术<br>Linux容器（Linux Containers，简称LXC），不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器就可以将软件运行所需要的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套完整的操作系统，只需要软件工作所欲的库资源和设置。系统因此而变的高效轻量并保证部署在任何的环境中的软件始终如一的运行。</li>
<li>Docker与传统的虚拟化方式的不同<ul>
<li>传统虚拟技术是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该操作系统上在运行所需应用进程</li>
<li>Docker容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟，因此容器与传统虚拟器更为轻便。</li>
<li>每个容器之间相互间隔，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。</li>
</ul>
<ul>
<li>优势</li>
</ul>
</li>
<li>DevOps开发自运维，一次构建、随处运行（提供全部的资源以及环境，避免冲突）<ul>
<li>更快速的应用交付和部署</li>
<li>更便捷的升级和扩缩容</li>
<li>更简单的系统运维</li>
<li>更高效的计算资源利用</li>
</ul>
<ul>
<li>仓库，Docker Hub官网： <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></li>
</ul>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li><p>CentOS仅发行版本中的内核支持Docker</p>
</li>
<li><p>运行在CentOS7上，要求系统为64位，系统内核版本在3.10以上。</p>
</li>
<li><p>运行在CENTOS6.5或者更高版本的CentOS上，要求系统为64位、系统内核版本为2.6.32-431或者更高版本。</p>
</li>
<li><p>查看系统的内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>Docker架构图<br><img src="https://i.loli.net/2019/11/29/Oxyms6T5DVv3XJH.jpg" alt="docker架构.png"></li>
</ul>
<h3 id="基本组成（三要素）"><a href="#基本组成（三要素）" class="headerlink" title="基本组成（三要素）"></a>基本组成（三要素）</h3><ul>
<li>镜像（image)<br>一个只读的模板。可以用来创建Docker容器，一个镜像可以创建很多容器。</li>
<li>容器（container)<br>是用镜像创建的运行实例，Docker利用容器独立运行一个或一组应用。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</li>
<li>仓库（repository)<br>仓库是集中存放镜像文件的场所。仓库（Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。仓库分为公开仓库（Public）和私有仓库（Private)两种形式。最大的公开仓库是Docker Hub（<a href="https://hub.docker/com/），存放了大量的镜像供用户下载，国内的公开仓库包括阿里云、网易云等。" target="_blank" rel="noopener">https://hub.docker/com/），存放了大量的镜像供用户下载，国内的公开仓库包括阿里云、网易云等。</a></li>
</ul>
<h3 id="小结，正确理解仓库-镜像-容器这几个概念"><a href="#小结，正确理解仓库-镜像-容器这几个概念" class="headerlink" title="小结，正确理解仓库/镜像/容器这几个概念"></a>小结，正确理解仓库/镜像/容器这几个概念</h3><p>Docker本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是一个image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>见官方文档：https://docs.docker.com/install/linux/docker-ce/centos/</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><hr>
<ul>
<li><p>安装完成后使用<code>sudo systemctl start docker</code>启动docker服务，一定要先启动docker服务，尤其是在重启宿主机后，docker服务没有启动。</p>
</li>
<li><p>推荐使用阿里云镜像加速：注册阿里云，搜索容器镜像服务，按照提示进行申请</p>
</li>
<li><p>配置完阿里云镜像后，使用<code>docker info</code>命令查看<code>Registry Mirrors</code>项是否是阿里云镜像的地址</p>
</li>
<li><p>通过运行hello-world镜像来验证是否正确安装了Docker Engine-Community 。运行<code>docker run hello-world</code>命令。</p>
<ul>
<li>docker run 镜像，运行相应的镜像，运行时首先会在本地寻找此镜像，若没有，会自动从设置的仓库中进行拉取，然后在容器中运行</li>
<li>第一次运行时，会得到提示：<code>Unable to find image &#39;hello-world:latest&#39; locally</code>，意思是本地没有该镜像，然后从仓库拉取，并在容器中运行</li>
<li><code>hello-world:latest</code>后面的<code>:latest</code>为版本号，不写，则默认为latest</li>
<li>run的过程<ol>
<li>在Docker本机中寻找该镜像，看本机是否有该镜像，若有，则以该镜像为模板生产容器实例运行</li>
<li>若本地没有则去Docker Hub上查找该镜像（若设置了阿里云镜像，则在阿里云镜像进行查找），能找到则下载该镜像到本地，以该镜像为模板生产容器实例运行</li>
<li>若未能找到，则返回失败，找不到该镜像</li>
</ol>
</li>
</ul>
</li>
<li><p>底层原理</p>
<ul>
<li><p>Docker是怎么工作的<br>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器，容器，是一个运行环境，就是所谓的集装箱。</p>
</li>
<li><p>Docker为什么快</p>
<ul>
<li><p>docker有着比虚拟机更少的抽象层。不需要Hypervisor实现硬件资源虚拟化，运行在docker上的程序直接使用的都是实际物理机硬件资源。因此在CPU、内存利用率上都有着更为明显的优势<br><img src="https://i.loli.net/2019/11/29/K9tEiTJuX5lnRdO.jpg" alt="docker.png"></p>
</li>
<li><p>docker利用的是宿主机的内核，而不是Guest OS。docker直接利用宿主机的操作系统，新建一个docker容器只需要几秒钟。</p>
</li>
</ul>
</li>
<li><p>Docker和虚拟机的区别</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/11/29/LsfpxybV6eXDHO5.jpg" alt="docker与虚拟机的区别.jpg"></p>
</li>
</ul>
<h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><ul>
<li><p>docker info，对Docker信息的概括</p>
</li>
<li><p>docker version，查看Docker的版本</p>
</li>
<li><p>docker –help，Docker命令的帮助</p>
</li>
<li><p>docker镜像命令</p>
<ul>
<li><p>docker images：列出<font color='red'>本地</font>主机上所有的镜像，通过在最后指定镜像的名字，可以查看相应镜像的名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY       TAG           IMAGE ID         CREATED           SIZE</span><br><span class="line">hello-world      latest        fce289e99eb9     11 months ago     1.84kB</span><br></pre></td></tr></table></figure>

<p>各项的说明：</p>
<ul>
<li>REPOSITORY：镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建的时间</li>
<li>SIZE：镜像大小</li>
</ul>
<p>同一个仓库源下可以有多个TAG，代表这个仓库源的不同版本，我们可以使用<code>REPOSITORY:TAG</code>来定义不同的镜像。如果不指定一个镜像的版本标签，例如你只使用ubuntu，docker将默认使用ubuntu:latest镜像。</br></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a：列出本地所有的镜像（含中间映像层）</li>
<li>-q：只显示镜像ID</li>
<li>–digests：显示镜像的摘要信息</li>
<li>–no-trunc：显示完整的镜像信息</li>
<li>-qa：组合命令，显示所有的本地镜像的ID</li>
</ul>
</li>
<li><p>docker search 镜像名： 从<a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>中查找某个镜像（尽管之前配置了阿里云镜像，但是这里查找镜像还是从Docker Hub上查找，拉取的时候从阿里云上拉）</br></p>
<p>OPTIONS说明：</p>
<ul>
<li>-s：指定显示STARTS数不小于某个值的镜像，如docker search -s 30 tomcat指定STARTS超过30的Tomcat镜像</li>
<li>–no-trunc：显示完整的信息，不要省略，docker search -s 30 –no-trunc tomcat</li>
<li>–automated：只列出automated build（自动构建）类型的镜像，即列出AUTOMATED为ok的镜像</li>
</ul>
</li>
<li><p>docker pull 镜像名：下载镜像，可以在镜像名后添加 <code>:版本号</code> 来下载指定版本的镜像，默认不添加的时候下载latest的版本</p>
</li>
<li><p>docker rmi 镜像名[镜像ID]：删除镜像，多个镜像时，默认不添加时版本是删除latest版本的。docker rmi -f 镜像名强制删除，如果有某个镜像被多个镜像调用，则必须使用-f强制删除所有相关的镜像。</p>
<ul>
<li>删除多个：docker rmi 镜像名1[镜像ID] 镜像名2[镜像ID]</li>
<li>删除全部：docker rmi -f $(docker images -qa)，docker images -qa为组合命令，显示所有的镜像的ID</li>
</ul>
</li>
</ul>
</li>
<li><p>docker容器命令（以centos镜像为例）</p>
<ul>
<li><p>新建并启动容器：docker run [OPTIONS] IMAGES [COMMAND]</p>
<p>OPTIONS说明：</p>
<ul>
<li><p>–name=’容器新名字’：为容器指定一个新的名字</p>
</li>
<li><p>-d：后台运行容器，并返回容器ID，也即启动守护式容器</p>
</li>
<li><p>-i：以交互模式运行容器，通常与-t同时使用；</p>
</li>
<li><p>-t：为容器重新分配一个伪输入终端，通常与-i同时使用； docker run -it 镜像 实际是得到一个容器的终端进行交互</p>
</li>
<li><p>-P：随机端口映射</p>
</li>
<li><p>-p：指定端口映射，有以下四种格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip:hostPort:containerPort</span><br><span class="line">ip::containerPort</span><br><span class="line">hostPort:containerPort</span><br><span class="line">containerPort</span><br></pre></td></tr></table></figure>

<p><strong>注意，<code>run 镜像：版本号</code>，如果未添加版本，则默认是latest版本的，所以若下载的不是latest版本，你不添加对应的版本号，则会去下载latest版本并运行。</strong></p>
</li>
</ul>
<p>COMMAND说明：</p>
<ul>
<li>该项目是可选项，可以指定运行容器时附加运行的指令，使用<code>docker run -it 镜像</code>创建实例的时候，即使不指定COMMAND为<code>/bin/bash</code>，默认不写该项时也是使用的这个。不使用-it参数，或者创建时没有指定一个前台运行的进程，创建的容器都会在创建之后由于没有前台进程而被自动kill掉。</li>
<li><strong>每个镜像都设置了其容器默认执行的相应的COMMAND，使得容器在被创建的时候，如果没有手动执行COMMAND，则会自动调用相应的默认的COMMAND指令，如tomcat镜像设置了其容器的默认COMMAND为”catalina.sh run”，这样tomcat容器一创建完成就会调用这个命令，开始执行tomcat服务器。</strong></li>
</ul>
<p><strong>使用docker run [OPTIONS] IMAGES [COMMAND]时的 [OPTIONS] 很重要，像对于centos这种，由于其没有默认的前台进程，如果使用-d作为守护式进程启动的话，由于docker本身的问题，这个容器一被创建就会由于没有前台进程而会被自动kill，且使用docker start也无法启动该容器，所以除非有特殊需要，以后台运行时要指定一个前台进程，或者就使用-it以交互式的方式运行</strong></p>
<p>疑问：为什么使用<code>docker run -d centos</code>创建的容器，没有添加COMMAD时，会被kill，但是使用docker ps查看时显示COMMADN为<code>/bin/bash</code>，自带的？，那为什么又会被kill呢？</br><em>这是docker本身的问题，Docker容器需要运行一个使其保持活动状态的进程。只要命令继续运行，容器将继续运行。而centos自带的/bin/bash会一执行玩就结束了，所以没有前台进程，该容器就被终止了，所以需要能使容器长时间挂起的方法，即所以可以：</em></p>
<ol>
<li>执行一个死循环</li>
<li>使用<code>docker run -dit centos</code>即使用-d启动守护式容器的同时，使用-it为其分配一个交互式伪终端即可</li>
</ol>
</li>
<li><p>查看docker内运行的进程：<code>docker ps</code> 默认显示当前正在运行的容器</p>
<p>OPTIONS说明：</p>
<ul>
<li>-a：列出当前所有正在运行的容器+历史上运行过的</li>
<li>-l：显示最近创建的容器</li>
<li>-n：显示最近n个创建的容器</li>
<li>-q：静默模式，只显示容器编号</li>
<li>–no-trunc：不截断输出</li>
</ul>
</li>
<li><p>退出容器：</p>
<ul>
<li>exit：容器停止退出</li>
<li>ctrl+P+Q：容器不停止退出</li>
</ul>
</li>
<li><p>启动容器：<code>docker start 容器ID或者容器名</code>（若没有使用docker run –name 设置别名，则使用的的是默认的容器名）</p>
<ul>
<li>启动成功后会返回对应的容器ID，启动的容器执行的COMMAND为使用docker run命令创建容器时执行的COMMAND。</li>
<li><font color='red'>可以通过<code>docker exec -it 容器ID bashShell</code>命令以命令行形式进入容器进行交互，如/bin/bash就会打开一个终端。</font></li>
</ul>
</li>
<li><p>重启容器：<code>docker restart 容器ID或者容器名</code>，重启成功后会返回对应的容器ID</p>
</li>
<li><p>停止容器：<code>docker stop 容器ID或者容器名</code>，关闭成功后会返回对应的容器ID</p>
</li>
<li><p>强制停止：<code>docker kill 容器ID或者容器名</code></p>
</li>
<li><p>删除已停止的容器：<code>docker rm 容器ID或者容器名</code>，一定要是停止的，否则会报冲突</p>
</li>
<li><p>删除没有停止的容器：<code>docker rm -f 容器ID或者容器名</code>，先关闭容器然后再删除</p>
</li>
<li><p>一次性删除多个容器</p>
<ul>
<li>docker rm -f $(docker ps -a -q)</li>
<li>docker ps -a -q | xargs docker rm</li>
</ul>
</li>
<li><p>灵活运用组合命令，如启动最近刚创建的容器，使用<code>docker start $(docker ps -lq)</code></p>
<ul>
<li>解释：docker start需要容器ID，docker ps -lq添加了-q，使其只返回容器ID.</li>
</ul>
</li>
</ul>
</li>
<li><p>重要</p>
<ul>
<li><p>启动守护式容器：<code>docker run -d 镜像名</code></p>
<ul>
<li>注意该命令没有指定创建容器要执行的命令COMMAND（且该镜像创建的容器默认的COMMAND不是一个长久的前台进程，如centos镜像的默认COMMAND为<code>&quot;/bin/bash&quot;</code>会在一执行完成就结束了，但是tomcat的COMMADN为<code>&quot;catalina.sh run&quot;</code>这个前台进程会一直执行并等待）</br><br>此时使用docker ps发现没有正在运行的容器，因为Docker容器后台运行<font color='red'>必须</font>有一个前台进程，容器如果运行的不是那些一直挂起的命令（如运行top，tail），就会自动退出。<font color='red'>所以最佳的解决方案是，将你要运行的程序以前台的形式运行。</font></li>
</ul>
</li>
<li><p>查看容器日志：<code>docker logs -f -t --tail 容器ID</code></p>
<ul>
<li>-t：加入时间戳</li>
<li>-f：跟随最新的日志打印</li>
<li>–tail 数字：显示最后的多少条</li>
</ul>
<p>所谓日志，就是docker容器终端的操作以及输出，直接使用<code>docker run 镜像</code>或者<code>docker run -d 镜像的</code>方式创建的容器会直接停止（即使用docker ps是无法查看的，即没有再运行），原因是因为docker在后台启动后，没有前台交互，无事可做，所以自动kill了，但是在创建时添加参数如<code>docker run -d centos /bin/sh -c &quot;while true;do echo hello skylor;sleep 2;done&quot;</code>这条命令的作用是创建centos的容器并且在容器中不断输出hello skylor，这样docker容器就一直有一个运行的前台进程，就不会自动kill了。</br><br>或者使用-d启动的容器，会后台打印日志，如tomcat容器，这种容器使用-d以后台启动的方式启动后就不会直接被kill掉。</br><br>另外，在使用<code>docker start 容器ID</code>方式启动后容器会继续运行这个命令。</p>
</li>
<li><p>查看容器内运行的进程：<code>docker top 容器ID</code></p>
<ul>
<li>docker容器本质是就是运行的一个精简版的linux系统，所以大部分的linux命令和docker是通用的，有一些命令不行，另外由于是精简版，比如centos就没有vim，只有自带的vi，想使用vim，需要手动下载。</li>
</ul>
</li>
<li><p>查看容器内部的细节：<code>docker inspect 容器ID</code></p>
<ul>
<li>能够查看所有存在的容器的内部信息，不仅是正在运行的容器。以键值对的形式展示内部细节。</li>
</ul>
</li>
<li><p>进入<font color="red">正在运行的</font>容器并以命令行交互，注意是正在运行的容器，所以容器若是关闭的，需先使用<code>docker start 容器ID</code>命令进行启动容器。</p>
<ul>
<li>docker exec -it 容器ID bashShell， bashShell可以直接是操作命令，这样执行后，会直接返回命令的执行结果，而如果是/bon/bash，则会新开一个容器的终端并进入。</li>
<li>docker attach 容器ID，此时重新进入容器执行的默认的COMMAND。</li>
<li>以上两种方式的区别： attach直接进入容器启动命令的终端，不会启动新的进程，exec是在容器中打开新的终端，并且可以启动新的进程。</br><br><strong>推荐使用docker exec -it 容器ID bashShell的方式，因为这样会再新打开一个shell进行交互，使用exit退出时仅仅退出了新开启的shell，而不会由于退出原始的shell而导致容器被关闭</strong></li>
</ul>
</li>
<li><p>将容器内的文件拷贝到主机上，<code>docker cp 容器ID：容器的内路径 目的主机路径</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul>
<li><p>是什么，镜像时一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的内容，包括代码、运行时、库、环境变量和配置文件。</p>
<ul>
<li><p>UnionFS联合文件系统：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统实Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<ul>
<li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各种文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li>
</ul>
</li>
<li><p>Docker镜像加载原理</p>
</li>
<li><p>分层的镜像，一个镜像是由好几层各种的其他的镜像叠加而成，当多个镜像都有相同的镜像层时只需保存一个。</p>
</li>
<li><p>为什么Docker镜像要采用这种分层结构呢：共享资源，比如说，有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一个base镜像，同时内存中也只需要加载一份base镜像，就可以为所有的容器服务了。而且镜像的每一层都可以被共享。</p>
</li>
</ul>
</li>
<li><p>特点：镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下都叫“镜像层”。</p>
</li>
<li><p>Docker镜像commit操作补充</p>
<ul>
<li><p>docker commit 提交<font color='red'>容器</font>副本使之成为一个新的镜像</p>
</li>
<li><p>docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名：[标签名]</p>
</li>
</ul>
</li>
</ul>
<h3 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h3><ul>
<li><p>创建的容器对象只是关闭，没有删除的情况下，容器内的内容是不会丢失的，但是一旦容器被删除，则保存的内容就会丢失（当然也可以是使用docker commit生成一个新的镜像，使得数据成为镜像的一一部分保存下来），此时就需要使用Docker容器数据卷。</p>
</li>
<li><p>能干什么：容器间继承和共享数据，做数据的持久化，类似redis中的rdb和aof文件</p>
</li>
<li><p>是什么：卷就是目录或者文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性，卷的设计目的就是数据的持久化，完全能独立于容器的生存周期，因此Docker不会在容器删除时，删除其挂载的数据卷（类似于外置的活动存储器）<br>特点： </p>
<ol>
<li>数据卷可在容器之间共享或重用数据—-使用同一个本地目录，实现了两个容器之间的数据共享</li>
<li>数据卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
</li>
<li><p>数据卷：容器内添加</p>
<ul>
<li><p>直接命令添加</p>
<ul>
<li>命令：<code>docker run -it -v /宿主机（即本地）绝对路径目录:/容器内目录  镜像名</code>，/宿主机（即本地）绝对路径目录和容器内目录都可以先不存在，而是由docker创建，如果 -v 之后只有一个路径，则此路径为容器内目录，而宿主机目录则由docker默认创建，目录为``/var/lib/docker/volumes/`下。</li>
<li>查看数据卷是否挂载成功：使用<code>docker inspect 容器ID</code>查看<code>Volumes</code>和<code>VolumesRW</code>可以看到卷路径</li>
<li>容器和宿主机之间数据共享：在容器或主机的任意一方的共享目录中的所有操作都是共享的，文件属性也是一致的，任意一方的修改，另外一方都能看到并使用。</li>
<li>容器停止退出后，主机修改后数据是否同步：任然同步，内容是一致的</li>
<li>（带权限的）命令：<code>docker run -it -v /宿主机（即本地）绝对路径目录:/容器内目录:ro  镜像名</code>，其中的<code>:ro</code>的意思为readonly只读，使用此命令后，使用<code>docker inspect 容器ID</code>查看<code>VolumesRW</code>值为false，意思不是可读可写，而是变成了只读，即容器内的目录只能读，而不能写。（类比于外置活动硬盘进行了写保护）</li>
</ul>
</li>
<li><p>DockerFile添加</p>
<ul>
<li><p>是什么，是Docker镜像的编译文件</p>
</li>
<li><p>使用过程：</p>
<ol>
<li><p>根目录下创建docker文件夹并进入</p>
</li>
<li><p>可在Dockerfile中使用VOLUME指令来给镜像添加一个或者多个数据卷</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME[&quot;&#x2F;dataVolumeContainer&quot;,&quot;&#x2F;dataVolumeContainer2&quot;,&quot;&#x2F;dataVolumeContainer3&quot;]</span><br></pre></td></tr></table></figure>

<p>  说明，出于可移植和分享考虑，用<code>-v 主机目录：容器目录</code>这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样特定的目录，所以VOLUME设置的都是<font color='red'>在容器上的目录</font>。</p>
</li>
<li><p>File构建<br>  创建一个Dockerfile脚本</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos </span><br><span class="line">VOLUME [&quot;&#x2F;dataVolumeContainer&quot;,&quot;&#x2F;dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;finished,-------success&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>  类似相当于下面的命令（但是要注意的是，出于可移植性考虑，Dokcerfile并不会在本地创建文件夹）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;host1:&#x2F;dataVolumeContainer1 -v &#x2F;host2:&#x2F;dataVolumeContainer2 centos &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>build后生成镜像，将Dockerfile文件build为一个新的镜像，命令格式为 <code>docker build [OPTIONS] &lt;上下文路径/URL/-&gt;</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f &#x2F;root&#x2F;mydocker&#x2F;Dockerfile -t skylor&#x2F;centos .</span><br></pre></td></tr></table></figure>

<p>  理解，这里的路径（上下文的问题），要注意，在执行该条命令的时候，有两种情况：</p>
<ol>
<li>是在含有要创建的镜像的Dockerfile文件所在的目录下，此时不使用-f指定Dockerfile文件的所在路径，docker会自动识别找到Dockerfile文件（当然前提是Dockerfile文件的命名必须是Dockerfile，而不能是其他的名字，如果是其他的名字，则就需要使用-f指定Dockerfile的具体路径，包括Dockerfile文件名）</li>
<li>是在任意的目录下，必须使用-f参数指定要创建的镜像的Dockerfile文件的所在路径（最好写全，也可以只要大致目录，docker会自动找到，同理，对于直接命名为Dockerfile的文件可以直接找到，但是对于命名为其他的Dockerfile文件，则需要写具体的路径，包括Dockerfile文件名）</li>
<li>上下文参数为根据当前执行<code>docker build</code>命令的目录为准，这个目录就是所谓的上下文，而在Dockerfile文件中执行COPY等命令时，如<code>COPY ./package.json /app/</code>这里的<code>.</code>指的是上下文路径，这是个相对路径，以上下文为基础。</br><br><strong>一般都是新建一个文件夹，然后在其中添加Dockerfile文件，然后只要使用 <code>docker build -t 镜像名：版本号 .</code> 就完成了镜像的创建。</strong></li>
</ol>
</li>
<li><p>run容器</p>
</li>
<li><p>对于设置了卷的镜像，在使用run创建容器后，会有一个默认的主机的目录地址用于与容器内的目录进行共享</p>
</li>
<li><p>主机对应默认地址：使用<code>docker inspect 容器ID</code>进行查看</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>备注：在使用<code>docker run -it -v /host1:/dataVolumeContainer1 -v /host2:/dataVolumeContainer2 centos</code>的方式给容器挂载主机目录，Docker访问出现<code>cannot open directory.: Permission denied</code>时，解决办法为：添加–privileged=true参数，即  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;host1:&#x2F;dataVolumeContainer1 -v &#x2F;host2:&#x2F;dataVolumeContainer2 --privileged&#x3D;true centos</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数据卷容器：命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，这个用于挂载数据卷的容器，称之为数据卷容器</p>
<ul>
<li>命令：在创建容器时添加<code>--volumes-from</code>参数即可<ul>
<li>首先需要先创建一个含有数据卷的容器作为初始的数据卷容器</li>
<li>之后使用<code>docker run -it --volumes-from 数据卷容器ID 镜像</code>来创建新的容器，则该新建的容器会在其内部创建与数据卷容器含有相同的文件目录用于数据共享。</li>
<li>所有的共享的容器不需要是同一种镜像创建</li>
<li>新创建的容器也可以作为数据卷容器去被其他的新容器使用</li>
<li>任何的容器之间都可以进行数据共享</li>
<li>首先创建的的数据卷容器的本地目的可以同时对所有的容器进行共享</li>
</ul>
</li>
</ul>
<p>容器之间配置信息的传递，数据卷生命周期一致持续到没有容器使用它为止。</p>
</li>
</ul>
<h3 id="Dockerfile解析"><a href="#Dockerfile解析" class="headerlink" title="Dockerfile解析"></a>Dockerfile解析</h3><ul>
<li><p>是什么：Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
</li>
<li><p>构建三步骤：</p>
<ul>
<li>编写Dockerfile文件</li>
<li>docker build </li>
<li>docker run </li>
</ul>
</li>
<li><p>文件结构（以centos镜像为例）</p>
<ul>
<li><p>Dokcerfile内容基础知识</p>
<ul>
<li>每条保留字指令都必须是大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像层进行提交</li>
<li>最终暴露出来最终的镜像文件</li>
</ul>
</li>
<li><p>Docker执行Dockerfile文件的大致流程</p>
<ul>
<li>docker从基础镜像运行一个容器–对应于Dockerfile文件中的<code>FROM 镜像</code></li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行Dockerfile中的下一条指令知道所有指令都执行完成</li>
</ul>
</li>
</ul>
</li>
<li><p>Dockerfile体系结构（保留字指令）</p>
<ul>
<li><p>FROM：基础镜像，当前新镜像是基于哪个镜像的</p>
</li>
<li><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p>
</li>
<li><p>RUN：容器构建时要运行的命令</p>
</li>
<li><p>EXPOSE：当前容器对外暴露出的端口</p>
</li>
<li><p>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，如果不设置的话，默认应该是根目录 /</p>
</li>
<li><p>ENV：用来在构建镜像的过程中设置环境变量</p>
<ul>
<li>类似键值对的形式，如<code>ENV MY_PATH /usr/mytest</code>，是创建了一个名为MY_PATH，对应的值为/usr/mytest的环境变量，这个环境变量可以在后续的任何RUN指令中使用，也可以在其他指令中直接使用这些环境变量，如：<code>WORKDIR $MY_PATH</code></li>
</ul>
</li>
<li><p>ADD：拷贝加解压缩。将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p>
</li>
<li><p>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</p>
<ul>
<li>COPY src dest  &lt;— shell格式</li>
<li>COPY [“src”, “dest”]    &lt;— json格式</li>
</ul>
</li>
<li><p>VOLUME：容器数据卷，用于数据保存和持久化工作，如<code>VOLUME [&quot;/dataVolumeContainer&quot;, &quot;/dataVolumeContainer2&quot;]</code></p>
</li>
<li><p>CMD：指定一个容器启动时要运行的命令</p>
<ul>
<li>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</li>
</ul>
</li>
<li><p>ENTRYPOINT：指定一个容器启动时要运行的命令</p>
<ul>
<li>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数</li>
<li>和CMD的区别在，CMD会被docker run之后的参数替换，但是使用ENTRYPOINT时，docker run之后添加的命令不会覆盖掉ENTRYPOINT，而是变为追加模式，即将原有的命令和docker run新添加的命令组成一个新的命令去执行。</li>
</ul>
</li>
<li><p>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子镜像继承后父镜像的onbuild被触发，是一个触发器。</p>
</li>
<li><p>.dockerignore：类似于git中的.gitignore，用于设置需要忽略的上下文中的构建镜像时不需要用到的文件，使其在使用docker build时不需要都上传至docker引擎，而造成的速度缓慢。</p>
</li>
</ul>
</li>
<li><p>Dockerfile实际操作案例：镜像就是<a href="###Docker镜像">一堆分层的文件</a></p>
<ul>
<li><p>Base镜像（scratch）:Docker Hub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建而来的</p>
</li>
<li><p>自定义镜像 mycentos：对官方版的centos镜像重构为新的镜像mycentos，使其能够</p>
<ol>
<li>登录后的默认路径不在根目录</li>
<li>添加vim编辑器</li>
<li>支持使用ifconfig查看网络配置 </li>
</ol>
<p>Dokcerfile内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER skylor&lt;tang1996mei@126.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success-------------------ok&quot;</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure>

<p>docker引擎将Dockerfile文件分解为10个步骤，每执行一层会得到一个中间容器，但是在执行完该步骤之后会卸载这个生成的中间容器层，除此以外还有中间层镜像（很多镜像依赖这些中间层，所以中间层镜像是不能随意删除的）</br><br>使用<code>docker history 镜像名</code>查看镜像变更历史</p>
</li>
<li><p>CMD/ENTRYPOINT 镜像案例</p>
<ul>
<li>都是指定一个容器启动时要运行的命令</li>
<li>CMD: Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</li>
<li>ENTRYPOINT: 相比CMD，使用ENTRYPOINT时，docker run之后添加的命令不会覆盖掉ENTRYPOINT，而是变为追加模式，即将原有的命令和docker run新添加的命令组成一个新的命令去执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>自定义镜像 Tomcat9</p>
<ul>
<li><p>建立本地Dockerfile文件夹，<code>mkdir -p /root/mydockerfile/tomcat9</code></p>
</li>
<li><p>在上述目录下touch c.txt</p>
</li>
<li><p>将jdk和tomcat安装的压缩包拷贝进上一步的目录中，<code>apache-tomcat-9.0.8.tar.gz</code>,<code>jdk-8u171-linux-x64.tar.gz</code></p>
</li>
<li><p>在<code>/root/mydockerfile/tomcat9</code>目录下新建Dockerfile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">FROM  centos</span><br><span class="line">MAINTAINER skylor&lt;tang1996mei@126,com&gt;</span><br><span class="line"></span><br><span class="line"># 把宿主机当前上下文的copy.txt文件拷贝到容器&#x2F;usr&#x2F;local&#x2F;路径下</span><br><span class="line">COPY copy.txt &#x2F;usr&#x2F;local&#x2F;cincontainer.txt</span><br><span class="line"></span><br><span class="line"># 把java和tomcat添加到容器中</span><br><span class="line">ADD apache-tomcat-9.0.8.tar.gz &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br><span class="line"># 安装vim</span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line"># 设置工作访问时候的WORKDIR路径，登录落脚点</span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line"># 配置java和tomcat环境变量</span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_171</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">ENV CATALINA_HOME &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8</span><br><span class="line">ENV CATALINA_BASE &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME&#x2F;bin:$CATALINA_HOME&#x2F;lib:$CATALINA_HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line"># 容器运行时监听端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"># 启动时运行tomcat</span><br><span class="line"># ENTRYPOINT [&quot;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;startup.sh&quot;]</span><br><span class="line"># CMD [&quot;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;startup.sh &amp;&amp; tail -F &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;logs&#x2F;catalina.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建： 在当前目录下<code>docker build -t centos_tomcat9 .</code></p>
</li>
<li><p>run： <code>docker run -d -p 9080:8080 -v /hostdatavolume/centos_tomcat9/test:/usr/local/atache-tomcat-9.0.8/webapps/test -v /hostdatavolume/centos_tomcat9/tomcatlogs/:/usr/local/apache-tomcat-9.0.8/logs --privileged=true --name ct9 centos_tomcat9</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="几个基本镜像的使用"><a href="#几个基本镜像的使用" class="headerlink" title="几个基本镜像的使用"></a>几个基本镜像的使用</h3><ul>
<li><p>mysql镜像:</p>
<ul>
<li>run命令： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 12345:3306 --name mysql -v /hostdatavolume/mysql5.6/conf:/etc/mysql/conf.d -v /hostdatavolume/mysql5.6/logs:/logs -v /hostdatavolume/mysql5.6/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</span><br></pre></td></tr></table></figure>
<code>-e MYSQL_ROOT_PASSWORD=123456</code>是对mysql的明码进行设置</li>
</ul>
</li>
<li><p>redis镜像：</p>
<ul>
<li>run命令：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -v /hostdatavolume/redis3.2/data:/data -v /hostdatavolume/redis3.2/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>
<code>redis-server /usr/local/etc/redis/redis.conf --appendonly yes--appendonly yes</code>是redis用于配置数据持久化的</li>
</ul>
</li>
<li><p>说明： 需要使用端口的镜像，创建容器的时候都需要做端口映射，<code>-p 宿主机端口：容器使用端口</code>会将端口映射到本地的端口，使用<code>- P</code>则会随机分配一个端口。</p>
</li>
</ul>
<h3 id="本地镜像发布到阿里云"><a href="#本地镜像发布到阿里云" class="headerlink" title="本地镜像发布到阿里云"></a>本地镜像发布到阿里云</h3><ul>
<li><p>使用docker commit命令提交一个本地的修改容器为新的镜像</p>
<ul>
<li><p>docker commit 提交<font color='red'>容器</font>副本使之成为一个新的镜像</p>
</li>
<li><p>docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名：[标签名]</p>
</li>
</ul>
</li>
<li><p>阿里云提供了完善的提交方案</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/%E9%9D%A2%E5%90%91%E2%80%9C%E5%AF%B9%E8%B1%A1%E2%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/10/%E9%9D%A2%E5%90%91%E2%80%9C%E5%AF%B9%E8%B1%A1%E2%80%9D/" itemprop="url">Go基础之面向“对象”</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-10T20:21:33+08:00">
                2019-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">  Left, Right *TreeNode</span><br><span class="line">  Value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span> <span class="title">traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  root.Left.traverse()</span><br><span class="line">  fmt.Println(root.Value)</span><br><span class="line">  root.Right.traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>go语言仅支持封装，不支持继承和多态</li>
<li>继承和多态使用接口实现</li>
<li>go语言没有class ,只有struct</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> treeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value  <span class="keyword">int</span></span><br><span class="line">	Left, Right *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 以下分别使用了3中不同结构初始化方法</span></span><br><span class="line">	<span class="keyword">var</span> root treeNode</span><br><span class="line">	root = treeNode&#123;Value: <span class="number">3</span>&#125;</span><br><span class="line">  root.Left = &amp;treeNode&#123;&#125;   <span class="comment">// 此句的效果和使用new()的效果是一样的。</span></span><br><span class="line">	root.Right = &amp;treeNode&#123;<span class="number">5</span>, <span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">	root.Right.Left = <span class="built_in">new</span>(treeNode)    <span class="comment">// 内建函数new，将创建一个指定类型的匿名变量，返回的是类型指针</span></span><br><span class="line">	nodes_slice := []treeNode &#123;</span><br><span class="line">		&#123;Value: <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;&#125;,</span><br><span class="line">		&#123;<span class="number">6</span>,<span class="literal">nil</span>,&amp;root&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(nodes_slice)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[&#123;<span class="number">3</span> &lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">0</span> &lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">6</span> &lt;<span class="literal">nil</span>&gt; <span class="number">0xc00009c020</span>&#125;]</span><br></pre></td></tr></table></figure>

<p><code>new (Type) *Type</code>函数为内建函数，接受值为类型，会在内部申请一块该类型的空间并进行清零，然后返回指向该地址的指针，是一个值为空的结构的地址&amp;{}，和nil不一样。</p>
<p>上面演示了创建结构的创建以及初始化，初始化时可以只给个别值赋值，则其余值为该类型的零值，或者都不赋初值。赋值时采用类似字典的方式k:v 的形式进行赋值。</p>
<p>也可以使用<code>变量名.结构体内部变量</code>的方式来赋值</p>
<ul>
<li>不论地址还是结构本身，一律使用.来访问成员</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNode</span><span class="params">(value <span class="keyword">int</span>)</span> *<span class="title">treeNode</span></span>&#123;</span><br><span class="line">	<span class="comment">// 工厂函数</span></span><br><span class="line">	<span class="keyword">return</span> &amp;treeNode&#123;Value:value&#125;  <span class="comment">//c++中会有局部变量的问题，在c++中此处就是返回的局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">root.Left.Right = createNode(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用自定义工厂函数</li>
<li>注意返回了局部变量地址！（局部变量在函数执行结束后会进行垃圾回收，函数内声明的局部变量会消失，局部变量地址也就没有意义了）但是这在go语言中是没有问题的</li>
</ul>
<p>Go语言的结构创建在堆上还是栈上？</p>
<ul>
<li>不需要知道</li>
<li>堆上分配的会参与垃圾回收，Go语言会自动根据变量是否会被使用决定分配的情况，像上面的函数中的treeNode在函数退出后并没有消失，所以放在堆中，参与垃圾回收，当不在被使用后会被回收，而不是像c++中的函数内是局部变量，一旦退出函数后，就消失。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构方法一：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为结构定义方法， 放到结构外面  func (接收者) 函数名(普通参数) &#123;&#125;</span></span><br><span class="line"><span class="comment">// 事实上接受者是结构方法的第一个参数，类似Python中类实例方法的self参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(node.Value)</span><br><span class="line">&#125;</span><br><span class="line">root.<span class="built_in">print</span>()   <span class="comment">// print()函数有一个参数，为接收者 node</span></span><br></pre></td></tr></table></figure>

<p><code>(node treeNode)</code>是调用的结构对象，可以理解为将原先<code>func print(node treeNode)</code>后面的参数前移动了，<code>print()</code>函数名之后依然是可以放其他参数的，总的来说就是，将调用者前移，其他的和普通的函数调用没有区别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构方法二：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">setValue</span><span class="params">(value <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 值传递</span></span><br><span class="line">	<span class="comment">// 因为go语言都是值传递类型，所以此处的node都是值传递，将node复制了一份，执行修改操作并不会修改原始的数据，包括左右子树的指针类型</span></span><br><span class="line">	<span class="comment">// 所以node 使用指针</span></span><br><span class="line">	node.Value = value  <span class="comment">// go语言中，使用指针都可以省略*     (*node).Value = value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Go语言都是值传递，所以，若在此处使用值类型，对node的修改是不会反映到实际节点上的，因为在调用的时候是将节点重新复制了一份去操作的。所以，若设计到修改，都需传递指针。</p>
<p>因为结构方法node可以是值传递接受值，也可能是指针传递接受地址，所以，Go编译器对结构方法的调用相当智慧：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构方法的使用</span></span><br><span class="line">root.<span class="built_in">print</span>()   <span class="comment">// print()函数有一个参数，为接收者 node</span></span><br><span class="line">root.setValue(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 结构方法调用时相当人性化，会自动进行相应的转换</span></span><br><span class="line"><span class="comment">// root.print()中的node是值类型，root是值类型，这里会直接复制一份</span></span><br><span class="line"><span class="comment">// root.setValue()中的node是指针类型，而root是值，所以go会自动将node转为root的地址</span></span><br><span class="line">pRoot := &amp;root</span><br><span class="line">pRoot.<span class="built_in">print</span>()</span><br><span class="line">pRoot.setValue(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 这里的pRoot是指针类型，存储的是地址</span></span><br><span class="line"><span class="comment">// pRoot.print()中的node是值类型，这里会将pRoot地址的值得到复制一份</span></span><br><span class="line"><span class="comment">// pRoot.setValue()中node正好需要指针</span></span><br></pre></td></tr></table></figure>

<h2 id="结构方法小结"><a href="#结构方法小结" class="headerlink" title="结构方法小结"></a>结构方法小结</h2><ul>
<li><p>显示定义和命名方法的接受者   </p>
</li>
<li><p>只有指针才能改变结构内容</p>
</li>
<li><p>nil指针也可以调用方法！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">setValue</span><span class="params">(value <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Setting value to nill "</span> +</span><br><span class="line">			<span class="string">"node. Ignore"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	node.Value = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pRoot *treeNode  <span class="comment">// 指针类型的默认初始值为nil</span></span><br><span class="line">fmt.Println(pRoot.setValue(<span class="number">200</span>))</span><br></pre></td></tr></table></figure>

<p>会正常执行，因为nil也是可以直接使用的，但是要注意，nil直接使用了，但是这里不能取到value，所以做一下判断，直接return结束函数。</p>
</li>
</ul>
<h2 id="遍历树"><a href="#遍历树" class="headerlink" title="遍历树"></a>遍历树</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 中序遍历</span></span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	node.Left.traverse()  <span class="comment">// 相比c++ 和 java ，此处不需要先判断node.left != nil ，因为即使为nil，也是可以进行运算的</span></span><br><span class="line">	node.<span class="built_in">print</span>()</span><br><span class="line">	node.Right.traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Go中的nil可以进行运算，所以traverse()处不需要判断，只要进入方法后，判断一下就行。</p>
<h2 id="值接收者vs指针接收者"><a href="#值接收者vs指针接收者" class="headerlink" title="值接收者vs指针接收者"></a>值接收者vs指针接收者</h2><p>接收者是在<code>结构</code>方法中的概念，在结构方法中用来代表结构对象，类似于Python类实例方法中的self</p>
<ul>
<li>要改变内容的必须使用指针接收者</li>
<li>结构过大也考虑使用指针就收者，因为使用值接收者的话要拷贝，结构过大，造成资源浪费</li>
<li>一致性：如有指针接收者，最好都是指针接收者</li>
<li>值接收者是Go语言特有</li>
<li>值/指针接收者均可接收值/指针，Go编译器会自动转换</li>
<li>一般较多使用的时候都是指针接受者 ，因为涉及到改变内容的操作较多</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/01/pipenv%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/01/pipenv%E4%BD%BF%E7%94%A8/" itemprop="url">pipenv 使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-01T15:40:57+08:00">
                2019-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>保存包的依赖关系，不需要requirements.txt文件，使用<code>pipenv graph</code>来查看包的依赖关系</li>
<li>不需要先激活虚拟环境，只需要在虚拟环境的文件夹下直接使用<code>pipenv</code>命令即可，当然也可以使用<code>pipenv shell</code>激活当前的虚拟环境<ul>
<li>激活虚拟环境后可以使用Python自带的<code>pip list</code>来产看安装了哪些包，当然可以直接查看Pipfile文件，以及使用<code>pipenv graph</code>来查看包的依赖关系</li>
</ul>
</li>
<li>实际上是将虚拟环境和包管理联系起来，包的信息保存在项目中的Pipfile和Pipfile.lock中，代替了requirements.txt的作用，创建的虚拟环境需要和项目中的Pipfile、Pipfile.lock文件配合使用。在项目下使用<code>pipenv shell</code>激活相应的虚拟环境</li>
<li>删除虚拟环境的时候不需要先激活虚拟环境 </li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>使用<code>pip install pipenv</code>进行安装</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>使用之前先要创建一个文件夹，存档Pipfile文件<ul>
<li>建议修改Pipfile中的url，修改安装包时的源，改为国内的<code>https://mirrors.aliyun.com/pypi/simple</code></li>
</ul>
</li>
<li><code>pipenv --three</code>会使用当前系统的Python3创建环境</li>
<li>也可以使用<code>pipenv --python 版本号</code>来创建环境</li>
<li>创建完成后，使用<code>pipenv shell</code>激活虚拟环境<ul>
<li>注意，在未创建虚拟环境的情况下，使用该命令，会在当前文件夹下创建以文件夹命名的虚拟环境并启用该虚拟环境</li>
</ul>
</li>
<li>注意以下三个命令只能在创建好的文件夹下（即含有Pipfile文件的文件夹）执行<ul>
<li>使用<code>pipenv --where</code>显示项目目录信息，为当前创建的文件夹的路径</li>
<li>使用<code>pipenv --venv</code>显示虚拟环境定义的路径</li>
<li>使用<code>pipenv --py</code>显示Python解释器路径</li>
</ul>
</li>
</ul>
<h3 id="虚拟环境的使用"><a href="#虚拟环境的使用" class="headerlink" title="虚拟环境的使用"></a>虚拟环境的使用</h3><ul>
<li><p>在虚拟环境中<code>pipenv</code>基本代替<code>pip</code>的使用</p>
</li>
<li><p>安装库，并添加到Pipfile中</p>
<ul>
<li><code>pipenv install 模块</code>进行相应的库的安装<ul>
<li><code>pipenv install 模块==版本号</code>可以安装指定版本的库  </li>
<li>安装时，会创建Pipfile.lock文件，用来保证包不被恶意篡改，但是这个过程是耗时的，我们可以在安装模块的时候添加参数，跳过该步骤<code>pipenv install requests --skip-lock</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Pipfile文件的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[source]]                                                                                                            </span><br><span class="line">name = <span class="string">"pypi"</span>                                                                                                         </span><br><span class="line">url = <span class="string">"https://pypi.org/simple"</span>                                                                                       </span><br><span class="line">verify_ssl = true                                                                                                     </span><br><span class="line"></span><br><span class="line">[dev-packages]                                                                                                        </span><br><span class="line"></span><br><span class="line">[packages]                                                                                                            </span><br><span class="line"></span><br><span class="line">[requires]                                                                                                            </span><br><span class="line">python_version = <span class="string">"3.7"</span></span><br></pre></td></tr></table></figure>

<p>其中<code>[dev-packages]</code>为开发环境安装的包，使用<code>pipenv install --dev requests --skip-lock</code>创建在开发环境下的包</p>
</li>
<li><p><code>pipenv graph</code>查看当前安装的库以及依赖</p>
</li>
<li><p><code>pipenv update</code>会将当前安装的包全部卸载并安装最新的包</p>
</li>
<li><p><code>pipenv check</code>检查安全漏洞</p>
</li>
<li><p><code>pipenv uninstall --all</code>卸载全部包并从Pipfile中移除  </p>
</li>
<li><p><code>exit</code>退出当前的虚拟环境</p>
</li>
<li><p>使用<code>pipenv --rm</code>删除当前的虚拟环境</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/01/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/01/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" itemprop="url">Go基础之字符和字符串处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-01T01:20:23+08:00">
                2019-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>rune类型就相当于Go语言中的char，占4个字节，为int32别名</p>
<p>使用range遍历 <code>postion, rune</code>对</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"Yes我爱慕课网!"</span> <span class="comment">// UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%X "</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> s &#123;     <span class="comment">// ch is a rune</span></span><br><span class="line">  fmt.Printf(<span class="string">"(%d %X) "</span>, i, ch)</span><br><span class="line">  <span class="comment">// ch这里是int32,就是rune，为4字节，但是utf-8类型在这里转成了unicode2字节型存储</span></span><br><span class="line">  <span class="comment">// 所以4字节中只占了两个字节 (3 6211)</span></span><br><span class="line">  <span class="comment">// 因为遍历的是单个字节，但是返回的是position rune对，所以跳过了中间的字符的单字节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">59</span>      <span class="number">65</span>       <span class="number">73</span>    E6 <span class="number">88</span> <span class="number">91</span>   E7 <span class="number">88</span> B1    E6 <span class="number">85</span> <span class="number">95</span>    E8 AF BE   E7 BD <span class="number">91</span>    <span class="number">21</span> </span><br><span class="line">(<span class="number">0</span> <span class="number">59</span>) (<span class="number">1</span> <span class="number">65</span>) (<span class="number">2</span> <span class="number">73</span>)  (<span class="number">3</span> <span class="number">6211</span>)   (<span class="number">6</span> <span class="number">7231</span>)     (<span class="number">9</span> <span class="number">6155</span>)   (<span class="number">12</span> <span class="number">8</span>BFE)   (<span class="number">15</span> <span class="number">7</span>F51)  (<span class="number">18</span> <span class="number">21</span>)</span><br></pre></td></tr></table></figure>



<p>使用<code>utf8.RuneCountInString</code>获得字符的数量，因为使用len()只能获得字节数（英文占1个字节，中文3个utf-8编码下）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"len count"</span>:<span class="built_in">len</span>(s))    <span class="comment">//19</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Rune count:"</span>, utf8.RuneCountInString(s))     <span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<p>使用<code>[]byte</code>获得字节，使用<code>[]rune</code>会获得字符切片， 实际上是用该类型的切片进行强制转换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"Yes我爱慕课网!"</span> <span class="comment">// UTF-8</span></span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%X "</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">59</span> <span class="number">65</span> <span class="number">73</span> E6 <span class="number">88</span> <span class="number">91</span> E7 <span class="number">88</span> B1 E6 <span class="number">85</span> <span class="number">95</span> E8 AF BE E7 BD <span class="number">91</span> <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>使用<code>utf8.DecodeRune</code>将utf8解码为四字节unicode，但是Unicode中文编码只用了两个字节</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s := <span class="string">"我"</span> <span class="comment">// UTF-8</span></span><br><span class="line">  a := []<span class="keyword">byte</span>(s)</span><br><span class="line">  ch, size := utf8.DecodeRune(a)</span><br><span class="line">  fmt.Printf(<span class="string">"%X, %d"</span>,ch, size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">6211</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>字符串的其他操作，都在<code>strings.</code>包内</p>
<ul>
<li>Fieds Split Join</li>
<li>Contains, Index</li>
<li>ToLower ToUpper</li>
<li>Trim TrimRight TrimLeft</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/30/%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8-%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/30/%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8-%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87/" itemprop="url">Go基础之内建容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-30T18:21:33+08:00">
                2019-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr0 []<span class="keyword">int</span>      <span class="comment">// 这种写法是不对的，该写法为数组的切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span>              <span class="comment">// 定义数组的同时指定数组的长度</span></span><br><span class="line">arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;      <span class="comment">// 使用短变量声明的同时赋初始值</span></span><br><span class="line">arr3 := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">3</span>,<span class="number">8</span>:<span class="number">3</span>&#125;    <span class="comment">// 可以在指定数组长度之后，使用 下标：内容 的方式指定特定的值。</span></span><br><span class="line">arr3 := []<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">3</span>,<span class="number">8</span>:<span class="number">2</span>&#125;    	<span class="comment">// 若是没有指定数组长，则默认使用最大下标的值加1为长度值</span></span><br><span class="line">arr4 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;  <span class="comment">// 长度交给编译器 使用... 代替</span></span><br><span class="line"><span class="keyword">var</span> grid [<span class="number">4</span>][<span class="number">5</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li><p>变量名写在数组之前</p>
</li>
<li><p>不对数组长度规定的时候，一定要使用<code>...</code>来代替长度。</p>
</li>
<li><p><font color="red">Go的数组是指定长度的，一旦指定，不可以变化，但是数组的值是可以改变的</font></p>
</li>
</ul>
<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr3); i++&#123;</span><br><span class="line">  fmt.Println(arr3[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在遍历<font color="red">数组</font>的时候，有一个专门的关键字<code>range</code>关键字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> arr3 &#123;   <span class="comment">// range关键字专门用于获取数组的下标</span></span><br><span class="line">  fmt.Println(arr3[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rang关键字也可以用来获取值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> arr3 &#123;   <span class="comment">// range关键字专门用于获取数组的下标</span></span><br><span class="line">  fmt.Println(i, v )   <span class="comment">// i 是下标，v 为下标对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若只想获得值，可以使用_来接受下标</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr3&#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组是值类型-—-作为函数参数是值传递"><a href="#数组是值类型-—-作为函数参数是值传递" class="headerlink" title="数组是值类型 — 作为函数参数是值传递"></a>数组是值类型 — 作为函数参数是值传递</h2><ul>
<li>调用<code>func f(arr [10]int)</code>会拷贝数组</li>
</ul>
<p>是类型意味着在作为函数参数进行传递时，传递的是拷贝值，在函数体内对传递的数组进行操作，不会修改原有的数组。</p>
<p>Go语言中都是值传递，意味着传递时会拷贝。</p>
<p>Go语言中，<code>[5]int</code>和<code>[3]int</code>是两中不同的类型，不能相互之间被使用赋值。</p>
<p>若想传递的时候可以对数组进行改变而不是值传递，可以使用指针的方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">100</span>                   <span class="comment">// 注意此处</span></span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printArray(&amp;arr1)   <span class="comment">// 使用时，也传递的是数组的引用&amp;数组名</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中<code>arr[0] = 100</code>中，使用数组指针的话，可以不使用<code>*</code>进行调用，而是直接在函数内使用数组名，这是十分灵活以及方便的，当然也可以使用<code>*</code>，但是需要使用括号<code>(*arr)[0] = 100</code>这样的赋值方式。rang后可以直接用<code>for i:= range *arr</code>效果和<code>for i:= range arr</code>一致。</p>
<ul>
<li>在Go语言中一般不直接使用数组，而是使用的切片</li>
</ul>
<h1 id="切片（Slice-—-相当于可变数组"><a href="#切片（Slice-—-相当于可变数组" class="headerlink" title="切片（Slice)    —   相当于可变数组"></a>切片（Slice)    —   相当于可变数组</h1><p>Go语言数组的定长性和值值拷贝限制了其使用场景，Go提供了另一个数据类型slice， 是一种可变长数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]                       <span class="comment">// 切片下标不能超过原先数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s 就是切片 值为[2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>Slice “不是”值类型（当然，Go语言所有的类型都是值类型），但是Slice内部有一个数据结构，是对array的一个view视图，<font color="red" size="4">所以对Slice的操作也会影响到原array的数据内容。</font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	s1 := arr[<span class="number">2</span>:]</span><br><span class="line">	fmt.Println(<span class="string">"s1 = "</span>, s1)</span><br><span class="line">	s1[<span class="number">0</span>] = <span class="number">100</span>   <span class="comment">// 对切片进行操作，会修改原先的数组值</span></span><br><span class="line">	fmt.Println(<span class="string">"arr = "</span>,arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">s1 =  [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">arr =  [<span class="number">0</span> <span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>可见对切片的操作会反映到原数组上。<code>（ 和Python不一样，Python的slice是对数组的截断拷贝，对切片的操作不会影响到Python列表（数组））</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;     <span class="comment">// 此处使用的是切片，因为没有指定数组大小  </span></span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"arr[2:6] ="</span>, arr[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line">	fmt.Println(<span class="string">"arr[:6] ="</span>, arr[:<span class="number">6</span>])</span><br><span class="line">	s1 := arr[<span class="number">2</span>:]</span><br><span class="line">	fmt.Println(<span class="string">"s1 ="</span>, s1)</span><br><span class="line">	s2 := arr[:]</span><br><span class="line">	fmt.Println(<span class="string">"s2 ="</span>, s2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"After updateSlice(s1)"</span>)</span><br><span class="line">  updateSlice(s1)   <span class="comment">// 需要注意的是，函数updateSlices()接受的参数为切片，所以这里传递的参数也需要为切片</span></span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了切片，之前的对数组使用指针的操作就不需要了，而是使用切片，就可以实现同样的效果。唯一需要注意的是，含有切片参数的函数接受的参数也需要为切片。</p>
<h2 id="Reslice"><a href="#Reslice" class="headerlink" title="Reslice"></a>Reslice</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Println(<span class="string">"s"</span>,s)</span><br><span class="line">s = s[:<span class="number">3</span>]                    <span class="comment">// 切片可以在切片的基础上继续切片</span></span><br><span class="line">fmt.Println(<span class="string">"s"</span>,s)</span><br><span class="line">s = arr[:]</span><br><span class="line">fmt.Println(<span class="string">"s"</span>,s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">s [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">s [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">s [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>时刻注意，切片是对原数组的视图，只要不对切片进行修改操作，就不会对数组进行修改。</p>
<h2 id="Slice的扩展"><a href="#Slice的扩展" class="headerlink" title="Slice的扩展"></a>Slice的扩展</h2><p>切片含有一个cap()，capacity容量，会向后保存原始的数据。 使用<code>cap()</code>可以查看切片的容量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>s1 的值为<code>[2 3 4 5]</code>，s2的值为<code>[5 6]</code></li>
<li>slice可以向后扩展，不可以向前扩展</li>
<li><code>s[i]</code>不可以超越<code>len(s)</code>，向后扩展不可以超越底层数组<code>cap(s)</code>。如上面若是<code>s2 = s1[5]</code>是取不到值的。</li>
<li>向后拓展的值可以被新的切片取到。如上面的<code>s2 := s1[3:5]</code>。 </li>
</ul>
<h2 id="Slice-操作"><a href="#Slice-操作" class="headerlink" title="Slice 操作"></a>Slice 操作</h2><h3 id="向Slice添加元素"><a href="#向Slice添加元素" class="headerlink" title="向Slice添加元素"></a>向Slice添加元素</h3><p>使用<code>append(slice, val)</code>，注意的是，在添加的时候，若添加的内容的下标未超过原始数组的下标（但是在切片的容量之内），则添加的内容会覆盖掉原始数组相应位置的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">  </span><br><span class="line">  fmt.Println(<span class="string">"arr ="</span>, arr)</span><br><span class="line">	s1 = arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	s2 = s1[<span class="number">3</span>:<span class="number">5</span>] <span class="comment">// [s1[3], s1[4]]  实际上为 [arr[5], arr[6]]</span></span><br><span class="line">	fmt.Printf(<span class="string">"s1=%v, len(s1)=%d, cap(s1)=%d\n"</span>,</span><br><span class="line">		s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">	fmt.Printf(<span class="string">"s2=%v, len(s2)=%d, cap(s2)=%d\n"</span>,</span><br><span class="line">		s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line">	s3 := <span class="built_in">append</span>(s2, <span class="number">10</span>)     <span class="comment">// 此处添加的10 对应着arr[7]，原先的值被覆盖</span></span><br><span class="line">	s4 := <span class="built_in">append</span>(s3, <span class="number">11</span>)</span><br><span class="line">	s5 := <span class="built_in">append</span>(s4, <span class="number">12</span>)</span><br><span class="line">	fmt.Println(<span class="string">"s3, s4, s5 ="</span>, s3, s4, s5)</span><br><span class="line">	<span class="comment">// s4 and s5 no longer view arr.</span></span><br><span class="line">	fmt.Println(<span class="string">"arr ="</span>, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果arr = [0 1 2 3 4 5 6 7]</span></span><br><span class="line">s1=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="built_in">len</span>(s1)=<span class="number">4</span>, <span class="built_in">cap</span>(s1)=<span class="number">6</span></span><br><span class="line">s2=[<span class="number">5</span> <span class="number">6</span>], <span class="built_in">len</span>(s2)=<span class="number">2</span>, <span class="built_in">cap</span>(s2)=<span class="number">3</span></span><br><span class="line">s3, s4, s5 = [<span class="number">5</span> <span class="number">6</span> <span class="number">10</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">10</span> <span class="number">11</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]</span><br><span class="line">arr = [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>超出的部分，这里的11 和 12 ，此时的s2 和 s3因为有超出的原先arry的内容，所以这里的s2和s3就不再是原先数组arry的视图view了，而是在内存中重新开辟了新的arry，将原先的arry拷贝过来，并将长度设置更长。</p>
<p>原先的数组若没有被使用，就会被垃圾回收掉，但是这里的不会，因为调用了。</p>
<h2 id="Slice创建"><a href="#Slice创建" class="headerlink" title="Slice创建"></a>Slice创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>   <span class="comment">// Zero value for slice is nil</span></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125; <span class="comment">// 意思是先创建爱了一个数组[2 4 6 8]，然后又赋值给了一个 []int 切片</span></span><br><span class="line"><span class="comment">// 方式三： 在需要建造一个指定长度的切片，但是还不确定内部的值的情况下</span></span><br><span class="line">s2 := <span class="built_in">make</span>(Type, size[,<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%v len=%d cap=%d"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;</span><br><span class="line">  printSlice(s1)</span><br><span class="line"></span><br><span class="line">  s2 := <span class="built_in">make</span>([]<span class="keyword">int</span> , <span class="number">4</span>)</span><br><span class="line">  printSlice(s2)</span><br><span class="line"></span><br><span class="line">  s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span> ,<span class="number">19</span>)</span><br><span class="line">  printSlice(s3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span>] <span class="built_in">len</span>=<span class="number">4</span> <span class="built_in">cap</span>=<span class="number">4</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="built_in">len</span>=<span class="number">4</span> <span class="built_in">cap</span>=<span class="number">4</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="built_in">len</span>=<span class="number">6</span> <span class="built_in">cap</span>=<span class="number">19</span></span><br></pre></td></tr></table></figure>



<p><code>var s []int</code> ，Go语言的特性，使用var创建变量之后没有付初值的情况下，有一个zero值，而切片的zero就是nil。直接使用<code>var s []int</code>创建的切片没有值但是可以只用，cap在装不下的时候会进行扩充，每次在原先的基础上乘以2。</p>
<h2 id="Slice-的复制"><a href="#Slice-的复制" class="headerlink" title="Slice 的复制"></a>Slice 的复制</h2><p><code>copy(dst, src []Type) int</code>，将src中的内容拷贝到dst中，覆盖原先中的内容，超出的抹去 。</p>
<ul>
<li>为slice特有的方法，参数为切片类型 <code>[]Type</code> 。</li>
<li>返回值类型为int，返回的是实际复制了的内容的长度。</li>
</ul>
<h2 id="Slice-元素的删除"><a href="#Slice-元素的删除" class="headerlink" title="Slice 元素的删除"></a>Slice 元素的删除</h2><p>没有内建的函数来执行该操作，需手动执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">  fmt.Println(<span class="string">"Deleting elements from slice"</span>)</span><br><span class="line">  s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">  printSlice(s1)</span><br><span class="line">  <span class="comment">// 可以使用切片从中截断，将需要的部分进行相加组合，但是slice没有加法，所以采用append</span></span><br><span class="line">  s1 = <span class="built_in">append</span>(s1[:<span class="number">3</span>], s1[<span class="number">9</span>:]...)    <span class="comment">// append(slice []Type, elem ...Type)第二个参数为可变参数，	即可接受若干个Type类型的参数</span></span><br><span class="line">  printSlice(s1)</span><br><span class="line">  </span><br><span class="line">  fmt.Println(<span class="string">"Popping from front"</span>)</span><br><span class="line">	fornt := s1[<span class="number">0</span>]</span><br><span class="line">	s1 = s1[<span class="number">1</span>:]</span><br><span class="line">	fmt.Printf(<span class="string">"fornt=%d\n"</span>,fornt)</span><br><span class="line">	printSlice(s1)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Popping form back"</span>)</span><br><span class="line">	tail := s1[<span class="built_in">len</span>(s1)<span class="number">-1</span>]</span><br><span class="line">	s1 = s1[:<span class="built_in">len</span>(s1)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"tail=%d\n"</span>, tail)</span><br><span class="line">	printSlice(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">Deleting elements from slice</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] <span class="built_in">len</span>=<span class="number">12</span> <span class="built_in">cap</span>=<span class="number">12</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] <span class="built_in">len</span>=<span class="number">6</span> <span class="built_in">cap</span>=<span class="number">12</span></span><br><span class="line">Popping from front</span><br><span class="line">fornt=<span class="number">1</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] <span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">11</span></span><br><span class="line">Popping form back</span><br><span class="line">tail=<span class="number">6</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>] <span class="built_in">len</span>=<span class="number">4</span> <span class="built_in">cap</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Slice本身没有数据，是对底层array的一个view</li>
<li>添加元素时如果超越cap，系统会重新分配更大的底层数组，并将原来的arry拷贝过去。</li>
<li>由于值传递的关系，必须接受append的返回值 — 因为，slice 的三个指标 ptr指针，len长度， cap容量都可能发生变化，而一旦cap容量超过之后，系统就会重新分配新的更大的内存去存储该slice，所以必须要设置参数用来接受append的返回值。</li>
<li>S = append(s, val)</li>
</ul>
<p><font  color="red">Slice底层是对array的一个view,所以对Slice的修改会影响到底层的array,以及有关联的Slice（如同一个array的切片）</font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slicea := arr[:<span class="number">2</span>]</span><br><span class="line">sliceb := arr[:<span class="number">1</span>]</span><br><span class="line">fmt.Print(slicea)</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">fmt.Print(arr)</span><br><span class="line">fmt.Print(sliceb)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span>][<span class="number">8</span> <span class="number">1</span> <span class="number">2</span>][<span class="number">8</span>]</span><br></pre></td></tr></table></figure>



<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"name"</span>:    <span class="string">"ccmouse"</span>,</span><br><span class="line">		<span class="string">"course"</span>:  <span class="string">"golang"</span>,</span><br><span class="line">		<span class="string">"site"</span>:    <span class="string">"imooc"</span>,</span><br><span class="line">		<span class="string">"quality"</span>: <span class="string">"notbad"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// m2 == empty map</span></span><br><span class="line"><span class="comment">// 方式三：</span></span><br><span class="line"><span class="keyword">var</span> m3 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">// m3 == nil</span></span><br></pre></td></tr></table></figure>

<p>语法格式：<code>map[key的类型]value的类型</code>，还支持复合结构<code>map[K1]map[K2]V</code></p>
<p>注意区分方式二和方式三的区别，m2是一个为空的map，已经分配了内存，只是内容为空，而m3是的值为nil，是Go中的特殊类型0值，但是nil也可以参与运算。</p>
<h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Traversing map m"</span>)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，key 在Map中是无序的，是一个哈希Map</p>
<ul>
<li>Map不保证遍历顺序，如需顺序，需手动对key排序 – 取出所有的key 放到slice中（slice可以排序）进行排序，然后在按照key取出。</li>
<li>使用len获得元素个数</li>
</ul>
<p>Map的key：</p>
<ul>
<li>map使用哈希表，必须可以比较相等</li>
<li>除了slice、map、function的其他内建类型都可以作为key</li>
<li>不包含slice、map、function的Struct类型都可以作为key</li>
</ul>
<h2 id="Map操作"><a href="#Map操作" class="headerlink" title="Map操作"></a>Map操作</h2><ul>
<li><p>读操作：<code>courseName := m[&quot;course&quot;]</code>，当key不存在时，会打印ZeroValue值，如这里会打印空字符串’ ‘。读操作有两个返回值，第一个返回值为key对应的value值，第二个返回值为反映该key对应的value值是否存在的标志，若key存在，则返回true， 反之返回false。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> causeName, ok := m[<span class="string">"cause"</span>]; ok &#123;</span><br><span class="line">  fmt.Println(causeName)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"key 'cause' does not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除操作：<code>delete(map, key)</code>，该函数没有返回值。删除不存在的key也不会报错。</p>
</li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>创建： <code>make(map[string]int)</code></li>
<li>获取元素： <code>m[key]</code></li>
<li>key不存在时，获得Value类型的初始值</li>
<li>使用<code>value, ok := m[key]</code>来判断是否存在key</li>
<li>用<code>delete(map, key)</code>来删除一个key</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找最长不含有重复字符的子串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfNonRepeatingSubStr</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	lastOccurred := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	maxLength := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;    <span class="comment">// 将字符串每个字符取出，组成切片</span></span><br><span class="line">    <span class="comment">// 目前该方法只支持英文，若想支持因为之外的其他多字节内容，使用 range []rune(s) </span></span><br><span class="line">		<span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123;    <span class="comment">// 有该值且不是同一字符</span></span><br><span class="line">			start = lastI + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">			maxLength = i - start +<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastOccurred[ch] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cache :=  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">  cache[<span class="string">"name"</span>] = <span class="string">"ccmouse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/%E7%89%B9%E5%88%AB%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/16/%E7%89%B9%E5%88%AB%E8%AF%B4%E6%98%8E/" itemprop="url">Go指针特别说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-16T21:10:35+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要区分Go语言和Python的本质区别：</p>
<p>Go语言是变量存的是一片内存地址，修改内容时修改的是内存地址中的内容<br>而python中是变量只是标签，每次修改，改变的是变量（标签）指向地方，内存中的内容没有变。</p>
<ul>
<li><p>Python创建一个内容时，是先在内存中开辟相应的空间放内容，然后使用一个变量名（标签）来指向这个地方，所以多个变量之间相互赋值的时候，这些变量都指向了同一块内存空间，通过其中一个变量对内容进行修改则会改动所有的，因为都是指向了一个内容。</p>
</li>
<li><p>Go语言是先创建一个变量，根据变量的类型开辟大小的空间，再往内存中放置东西。多变量（必须是同种类型变量）之间相互赋值时，进行的是复制操作，对其中一个修改，是不会影响到其他内容的。所以Go的变量赋值很强调类型</p>
</li>
</ul>
<p>某个类型的变量只能就收同种类型的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">bb := arr</span><br><span class="line">fmt.Printf(<span class="string">"arr address: %p\n"</span>,&amp;arr)</span><br><span class="line">fmt.Printf(<span class="string">"bb address: %p\n"</span>,&amp;bb)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"bb: %d\n"</span>,bb)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">fmt.Printf(<span class="string">"bb: %d\n"</span>,bb)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">arr address: <span class="number">0xc000018240</span></span><br><span class="line">bb address: <span class="number">0xc000018260</span></span><br><span class="line">bb: [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">bb: [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>Slice 等映射类型除外。</p>
<p>Go语言的所有方法一旦有返回值的都是重新创建了新的内容，需要使用新的变量去接收。如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">b := <span class="built_in">append</span>(arr, <span class="number">9</span>) <span class="comment">// 这里实际上是先创建了一个len为2，cap为16的[]int类型的变量并开辟了内存空间，然后接收了append函数返回的内容,arr和b不是指向的同一个内容，但是由于arr为slice类型，对arr现有内容的改变影响到b</span></span><br><span class="line">fmt.Printf(<span class="string">"arr address: %p\n"</span>,&amp;arr)</span><br><span class="line">fmt.Printf(<span class="string">"bb address: %p\n"</span>,&amp;bb)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"bb: %d\n"</span>,bb)</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"arr: %d\n"</span>,arr)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"bb: %d\n"</span>,bb)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">arr address: <span class="number">0xc00009c0c0</span></span><br><span class="line">bb address: <span class="number">0xc00009c0e0</span></span><br><span class="line">bb: [<span class="number">0</span> <span class="number">0</span> <span class="number">9</span>]</span><br><span class="line">arr: [<span class="number">0</span> <span class="number">3</span>]</span><br><span class="line">bb: [<span class="number">0</span> <span class="number">3</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>为了能够修改原值，定义函数的时候使用指针，这样一来，通过指针，修改了原先内存中的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(s *[]<span class="keyword">int</span>,v <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  *s = <span class="built_in">append</span>(*s,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(s *[]<span class="keyword">int</span>, v <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, v)</span><br><span class="line">	<span class="keyword">return</span> (*s)[<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用数组指针的时候，不需要使用*，只需要正常数组的使用方式即可，由于Go的语法糖，会自动转化为(*数组)。但是Slice不行。</span></span><br></pre></td></tr></table></figure>





<p><strong><em>总之要转换思想，Python中修改变量的值可以通过其他变量间接修改，因为Python的变量只是标签，但是Go中变量是分配了内存的，想修改，只能通过修改自身的值。</em></strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/16/%E6%8C%87%E9%92%88/" itemprop="url">Go基础之指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-16T20:33:50+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> pa *<span class="keyword">int</span> = &amp;a   <span class="comment">// &amp;a 就是取a的地址</span></span><br><span class="line">*pa = <span class="number">3</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>Go语言中的指针不能进行计算</strong></p>
<h2 id="参数传递问题"><a href="#参数传递问题" class="headerlink" title="参数传递问题"></a>参数传递问题</h2><p>Python中的参数传递根据参数是否是可变类型进行分类。</p>
<ul>
<li>Go只有值传递一种方式</li>
<li>但是这并不意味着Go在传递的时候都要将内容进行拷贝一份，而是可以使用指针类型，和c的用法一样。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a,b *<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  *b, *a = *a, *b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a, b := <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">  swap(&amp;a,&amp;b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更好的swap实现方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b,a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a,b := <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">  a,b = swap(a,b) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/14/%E5%87%BD%E6%95%B0function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Skylor Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Skylor Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/%E5%87%BD%E6%95%B0function/" itemprop="url">Go基础之函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T18:32:23+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>func eval(a,b int, op string) int</code>定义的方式和变量类似，都是函数名在前，返回值类型在后，类型是用来指定函数返回值得类型，若函数没有返回值，则不需要指定函数类型。</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>Go语言的函数可以返回多个值。（Python也可以），只有一个返回值的时候，可以直接指定返回值的类型，或者使用括号，如<code>func eval(a,b int, op string) (i int)</code>，但是有多个返回值的时候一定要使用括号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接指定函数的返回值类型，而不需要写参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不写返回值参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实指定返回值的参数，即这里的q，r 没有太大的意义，对调用者而言没有区别，只是起到了提示作用，便捷的地方在调用的时候编辑器会自动帮我们创建生成接受返回值的参数q，r。但是有一种情况，返回值的参数有大用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  q = a / b</span><br><span class="line">  r = a % b</span><br><span class="line">  <span class="keyword">return</span>     <span class="comment">// 此时只要直接return即可返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是使用这种方式，只要函数体一长，很容易搞不清赋值情况</li>
<li>且返回值参数一定要写</li>
</ul>
<p>所以建议还是使用第一种方式。</p>
<p>可以返回多个返回值带来便利的同时也会产生问题，如必须使用相应个数的参数来接受返回值，否则会报错（Go不像Python一样可以使用<code>[下标]</code>的方式来取得值，Python返回的是元组，所以可以使用下标），这就要求我们必须使用与返回值个数匹配的参数去接受，但是Go严格的语法要求<font color="red">函数内</font>所有定义的参数都必须使用到，否则报编译错误，此时我们就可以使用<code>_</code>来接受不需要的返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用_来接受不需要的值</span></span><br><span class="line">q, _ := div(a, b)</span><br></pre></td></tr></table></figure>

<h2 id="多个返回值的正常用法"><a href="#多个返回值的正常用法" class="headerlink" title="多个返回值的正常用法"></a>多个返回值的正常用法</h2><p><font color="red">注意：</font>不要滥用函数的多返回值，一般的常用法是用来定义一个参数用来返回错误<code>error</code>的，即一个正常的返回值，一个出现异常返回的错误值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;  <span class="comment">//  f返回值可以直接类型，如这里的int和error</span></span><br><span class="line">  <span class="keyword">switch</span> op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">      <span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">      <span class="keyword">return</span> a - b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">      <span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">      q, _ := div(a, b)</span><br><span class="line">      <span class="keyword">return</span> q, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 不使用原先的panic()函数，会中断程序的运行，而是采用fmt.Errorf()构造异常</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(  </span><br><span class="line">        <span class="string">"unsupported operation: %s"</span>, op)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> result, err := eval(<span class="number">3</span>, <span class="number">4</span>, <span class="string">"x"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	fmt.Println(<span class="string">"Error:"</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>Go语言是函数式编程，函数式一等公民：参数，变量，返回值都可以是函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 为了获取函数名</span></span><br><span class="line">  p := reflect.ValueOf(op).Pointer()</span><br><span class="line">  opName := runtime.FuncForPC(p).Name()</span><br><span class="line">  fmt.Printf(<span class="string">"Calling function %s with args "</span> + <span class="string">"(%d, %d)\n"</span>, opName, a, b)</span><br><span class="line">  <span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为自带的math.Pow()方法的参数和返回值要求是float64，所以这里进行重写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(a), <span class="keyword">float64</span>(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(apply(pow, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">Calling function main.pow with args (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>除了传递手写的函数，也可以直接使用匿名函数(为省略了函数名的函数，除了函数名其他函数组件一个不能少)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(apply(</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(</span><br><span class="line">        <span class="keyword">float64</span>(a), <span class="keyword">float64</span>(b)))</span><br><span class="line">    &#125;, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">Calling function main.main.func1 with args (<span class="number">3</span>, <span class="number">4</span>)    </span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>第一个main是包名，第二个main是func main()的，由于是匿名的函数，所以第三个是func1。</p>
<h2 id="其他语言中函数的特性"><a href="#其他语言中函数的特性" class="headerlink" title="其他语言中函数的特性"></a>其他语言中函数的特性</h2><p>因为Go的语法较为简洁，一起其他语言的特性都不包含，如默认参数，可选参数，函数重载等。</p>
<p>但是支持可变参数列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;     <span class="comment">// ...为golang的语法糖，此处表示可以接受多个int类型的参数</span></span><br><span class="line">  s := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">    s += numbers[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数语法要点回顾"><a href="#函数语法要点回顾" class="headerlink" title="函数语法要点回顾"></a>函数语法要点回顾</h2><ul>
<li>返回值类型写在最后</li>
<li>可返回多个值</li>
<li>函数作为参数</li>
<li>没有默认参数，可选参数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Skylor Tang" />
            
              <p class="site-author-name" itemprop="name">Skylor Tang</p>
              <p class="site-description motion-element" itemprop="description">Your advantages today will be replaced by future trends, so keep learning.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skylor Tang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
